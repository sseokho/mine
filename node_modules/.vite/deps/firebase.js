import "./chunk-TFYBALIL.js";
import {
  Gc,
  Qc,
  Sc
} from "./chunk-DCGCXOMB.js";
import {
  Component,
  ComponentContainer,
  Deferred,
  ErrorFactory,
  FirebaseError,
  LogLevel,
  Logger,
  Provider,
  Sha1,
  __assign,
  __awaiter,
  __extends,
  __generator,
  __read,
  __spreadArray,
  __values,
  areCookiesEnabled,
  assert,
  assertionError,
  base64,
  base64Encode,
  calculateBackoffMillis,
  contains,
  createMockUserToken,
  deepCopy,
  errorPrefix,
  getGlobal,
  getModularInstance,
  index_esm_default,
  isAdmin,
  isBrowserExtension,
  isEmpty,
  isIndexedDBAvailable,
  isMobileCordova,
  isNodeSdk,
  isReactNative,
  isValidFormat,
  issuedAtTime,
  jsonEval,
  map,
  querystring,
  safeGet,
  stringLength,
  stringToByteArray,
  stringify,
  validateArgCount,
  validateCallback,
  validateContextObject,
  validateIndexedDBOpenable
} from "./chunk-B73Z2C6F.js";
import "./chunk-EQCVQC35.js";

// node_modules/@firebase/database/dist/index.esm.js
var name = "@firebase/database";
var version = "0.11.0";
var SDK_VERSION = "";
function setSDKVersion(version10) {
  SDK_VERSION = version10;
}
var DOMStorageWrapper = (
  /** @class */
  function() {
    function DOMStorageWrapper2(domStorage_) {
      this.domStorage_ = domStorage_;
      this.prefix_ = "firebase:";
    }
    DOMStorageWrapper2.prototype.set = function(key, value) {
      if (value == null) {
        this.domStorage_.removeItem(this.prefixedName_(key));
      } else {
        this.domStorage_.setItem(this.prefixedName_(key), stringify(value));
      }
    };
    DOMStorageWrapper2.prototype.get = function(key) {
      var storedVal = this.domStorage_.getItem(this.prefixedName_(key));
      if (storedVal == null) {
        return null;
      } else {
        return jsonEval(storedVal);
      }
    };
    DOMStorageWrapper2.prototype.remove = function(key) {
      this.domStorage_.removeItem(this.prefixedName_(key));
    };
    DOMStorageWrapper2.prototype.prefixedName_ = function(name10) {
      return this.prefix_ + name10;
    };
    DOMStorageWrapper2.prototype.toString = function() {
      return this.domStorage_.toString();
    };
    return DOMStorageWrapper2;
  }()
);
var MemoryStorage = (
  /** @class */
  function() {
    function MemoryStorage2() {
      this.cache_ = {};
      this.isInMemoryStorage = true;
    }
    MemoryStorage2.prototype.set = function(key, value) {
      if (value == null) {
        delete this.cache_[key];
      } else {
        this.cache_[key] = value;
      }
    };
    MemoryStorage2.prototype.get = function(key) {
      if (contains(this.cache_, key)) {
        return this.cache_[key];
      }
      return null;
    };
    MemoryStorage2.prototype.remove = function(key) {
      delete this.cache_[key];
    };
    return MemoryStorage2;
  }()
);
var createStoragefor = function(domStorageName) {
  try {
    if (typeof window !== "undefined" && typeof window[domStorageName] !== "undefined") {
      var domStorage = window[domStorageName];
      domStorage.setItem("firebase:sentinel", "cache");
      domStorage.removeItem("firebase:sentinel");
      return new DOMStorageWrapper(domStorage);
    }
  } catch (e) {
  }
  return new MemoryStorage();
};
var PersistentStorage = createStoragefor("localStorage");
var SessionStorage = createStoragefor("sessionStorage");
var logClient = new Logger("@firebase/database");
var LUIDGenerator = /* @__PURE__ */ function() {
  var id = 1;
  return function() {
    return id++;
  };
}();
var sha1 = function(str) {
  var utf8Bytes = stringToByteArray(str);
  var sha12 = new Sha1();
  sha12.update(utf8Bytes);
  var sha1Bytes = sha12.digest();
  return base64.encodeByteArray(sha1Bytes);
};
var buildLogMessage_ = function() {
  var varArgs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    varArgs[_i] = arguments[_i];
  }
  var message = "";
  for (var i = 0; i < varArgs.length; i++) {
    var arg = varArgs[i];
    if (Array.isArray(arg) || arg && typeof arg === "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
    typeof arg.length === "number") {
      message += buildLogMessage_.apply(null, arg);
    } else if (typeof arg === "object") {
      message += stringify(arg);
    } else {
      message += arg;
    }
    message += " ";
  }
  return message;
};
var logger = null;
var firstLog_ = true;
var enableLogging = function(logger_, persistent) {
  assert(!persistent || logger_ === true || logger_ === false, "Can't turn on custom loggers persistently.");
  if (logger_ === true) {
    logClient.logLevel = LogLevel.VERBOSE;
    logger = logClient.log.bind(logClient);
    if (persistent) {
      SessionStorage.set("logging_enabled", true);
    }
  } else if (typeof logger_ === "function") {
    logger = logger_;
  } else {
    logger = null;
    SessionStorage.remove("logging_enabled");
  }
};
var log = function() {
  var varArgs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    varArgs[_i] = arguments[_i];
  }
  if (firstLog_ === true) {
    firstLog_ = false;
    if (logger === null && SessionStorage.get("logging_enabled") === true) {
      enableLogging(true);
    }
  }
  if (logger) {
    var message = buildLogMessage_.apply(null, varArgs);
    logger(message);
  }
};
var logWrapper = function(prefix) {
  return function() {
    var varArgs = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      varArgs[_i] = arguments[_i];
    }
    log.apply(void 0, __spreadArray([prefix], __read(varArgs)));
  };
};
var error = function() {
  var varArgs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    varArgs[_i] = arguments[_i];
  }
  var message = "FIREBASE INTERNAL ERROR: " + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs)));
  logClient.error(message);
};
var fatal = function() {
  var varArgs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    varArgs[_i] = arguments[_i];
  }
  var message = "FIREBASE FATAL ERROR: " + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs)));
  logClient.error(message);
  throw new Error(message);
};
var warn = function() {
  var varArgs = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    varArgs[_i] = arguments[_i];
  }
  var message = "FIREBASE WARNING: " + buildLogMessage_.apply(void 0, __spreadArray([], __read(varArgs)));
  logClient.warn(message);
};
var warnIfPageIsSecure = function() {
  if (typeof window !== "undefined" && window.location && window.location.protocol && window.location.protocol.indexOf("https:") !== -1) {
    warn("Insecure Firebase access from a secure page. Please use https in calls to new Firebase().");
  }
};
var isInvalidJSONNumber = function(data) {
  return typeof data === "number" && (data !== data || // NaN
  data === Number.POSITIVE_INFINITY || data === Number.NEGATIVE_INFINITY);
};
var executeWhenDOMReady = function(fn) {
  if (isNodeSdk() || document.readyState === "complete") {
    fn();
  } else {
    var called_1 = false;
    var wrappedFn_1 = function() {
      if (!document.body) {
        setTimeout(wrappedFn_1, Math.floor(10));
        return;
      }
      if (!called_1) {
        called_1 = true;
        fn();
      }
    };
    if (document.addEventListener) {
      document.addEventListener("DOMContentLoaded", wrappedFn_1, false);
      window.addEventListener("load", wrappedFn_1, false);
    } else if (document.attachEvent) {
      document.attachEvent("onreadystatechange", function() {
        if (document.readyState === "complete") {
          wrappedFn_1();
        }
      });
      window.attachEvent("onload", wrappedFn_1);
    }
  }
};
var MIN_NAME = "[MIN_NAME]";
var MAX_NAME = "[MAX_NAME]";
var nameCompare = function(a, b) {
  if (a === b) {
    return 0;
  } else if (a === MIN_NAME || b === MAX_NAME) {
    return -1;
  } else if (b === MIN_NAME || a === MAX_NAME) {
    return 1;
  } else {
    var aAsInt = tryParseInt(a), bAsInt = tryParseInt(b);
    if (aAsInt !== null) {
      if (bAsInt !== null) {
        return aAsInt - bAsInt === 0 ? a.length - b.length : aAsInt - bAsInt;
      } else {
        return -1;
      }
    } else if (bAsInt !== null) {
      return 1;
    } else {
      return a < b ? -1 : 1;
    }
  }
};
var stringCompare = function(a, b) {
  if (a === b) {
    return 0;
  } else if (a < b) {
    return -1;
  } else {
    return 1;
  }
};
var requireKey = function(key, obj) {
  if (obj && key in obj) {
    return obj[key];
  } else {
    throw new Error("Missing required key (" + key + ") in object: " + stringify(obj));
  }
};
var ObjectToUniqueKey = function(obj) {
  if (typeof obj !== "object" || obj === null) {
    return stringify(obj);
  }
  var keys = [];
  for (var k in obj) {
    keys.push(k);
  }
  keys.sort();
  var key = "{";
  for (var i = 0; i < keys.length; i++) {
    if (i !== 0) {
      key += ",";
    }
    key += stringify(keys[i]);
    key += ":";
    key += ObjectToUniqueKey(obj[keys[i]]);
  }
  key += "}";
  return key;
};
var splitStringBySize = function(str, segsize) {
  var len = str.length;
  if (len <= segsize) {
    return [str];
  }
  var dataSegs = [];
  for (var c = 0; c < len; c += segsize) {
    if (c + segsize > len) {
      dataSegs.push(str.substring(c, len));
    } else {
      dataSegs.push(str.substring(c, c + segsize));
    }
  }
  return dataSegs;
};
function each(obj, fn) {
  for (var key in obj) {
    if (obj.hasOwnProperty(key)) {
      fn(key, obj[key]);
    }
  }
}
var doubleToIEEE754String = function(v) {
  assert(!isInvalidJSONNumber(v), "Invalid JSON number");
  var ebits = 11, fbits = 52;
  var bias = (1 << ebits - 1) - 1;
  var s, e, f, ln, i;
  if (v === 0) {
    e = 0;
    f = 0;
    s = 1 / v === -Infinity ? 1 : 0;
  } else {
    s = v < 0;
    v = Math.abs(v);
    if (v >= Math.pow(2, 1 - bias)) {
      ln = Math.min(Math.floor(Math.log(v) / Math.LN2), bias);
      e = ln + bias;
      f = Math.round(v * Math.pow(2, fbits - ln) - Math.pow(2, fbits));
    } else {
      e = 0;
      f = Math.round(v / Math.pow(2, 1 - bias - fbits));
    }
  }
  var bits = [];
  for (i = fbits; i; i -= 1) {
    bits.push(f % 2 ? 1 : 0);
    f = Math.floor(f / 2);
  }
  for (i = ebits; i; i -= 1) {
    bits.push(e % 2 ? 1 : 0);
    e = Math.floor(e / 2);
  }
  bits.push(s ? 1 : 0);
  bits.reverse();
  var str = bits.join("");
  var hexByteString = "";
  for (i = 0; i < 64; i += 8) {
    var hexByte = parseInt(str.substr(i, 8), 2).toString(16);
    if (hexByte.length === 1) {
      hexByte = "0" + hexByte;
    }
    hexByteString = hexByteString + hexByte;
  }
  return hexByteString.toLowerCase();
};
var isChromeExtensionContentScript = function() {
  return !!(typeof window === "object" && window["chrome"] && window["chrome"]["extension"] && !/^chrome/.test(window.location.href));
};
var isWindowsStoreApp = function() {
  return typeof Windows === "object" && typeof Windows.UI === "object";
};
function errorForServerCode(code, query2) {
  var reason = "Unknown Error";
  if (code === "too_big") {
    reason = "The data requested exceeds the maximum size that can be accessed with a single request.";
  } else if (code === "permission_denied") {
    reason = "Client doesn't have permission to access the desired data.";
  } else if (code === "unavailable") {
    reason = "The service is unavailable";
  }
  var error2 = new Error(code + " at " + query2._path.toString() + ": " + reason);
  error2.code = code.toUpperCase();
  return error2;
}
var INTEGER_REGEXP_ = new RegExp("^-?(0*)\\d{1,10}$");
var INTEGER_32_MIN = -2147483648;
var INTEGER_32_MAX = 2147483647;
var tryParseInt = function(str) {
  if (INTEGER_REGEXP_.test(str)) {
    var intVal = Number(str);
    if (intVal >= INTEGER_32_MIN && intVal <= INTEGER_32_MAX) {
      return intVal;
    }
  }
  return null;
};
var exceptionGuard = function(fn) {
  try {
    fn();
  } catch (e) {
    setTimeout(function() {
      var stack = e.stack || "";
      warn("Exception was thrown by user callback.", stack);
      throw e;
    }, Math.floor(0));
  }
};
var beingCrawled = function() {
  var userAgent = typeof window === "object" && window["navigator"] && window["navigator"]["userAgent"] || "";
  return userAgent.search(/googlebot|google webmaster tools|bingbot|yahoo! slurp|baiduspider|yandexbot|duckduckbot/i) >= 0;
};
var setTimeoutNonBlocking = function(fn, time) {
  var timeout = setTimeout(fn, time);
  if (typeof timeout === "object" && timeout["unref"]) {
    timeout["unref"]();
  }
  return timeout;
};
var AppCheckTokenProvider = (
  /** @class */
  function() {
    function AppCheckTokenProvider2(appName_, appCheckProvider) {
      var _this = this;
      this.appName_ = appName_;
      this.appCheckProvider = appCheckProvider;
      this.appCheck = appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.getImmediate({ optional: true });
      if (!this.appCheck) {
        appCheckProvider === null || appCheckProvider === void 0 ? void 0 : appCheckProvider.get().then(function(appCheck) {
          return _this.appCheck = appCheck;
        });
      }
    }
    AppCheckTokenProvider2.prototype.getToken = function(forceRefresh) {
      var _this = this;
      if (!this.appCheck) {
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            if (_this.appCheck) {
              _this.getToken(forceRefresh).then(resolve, reject);
            } else {
              resolve(null);
            }
          }, 0);
        });
      }
      return this.appCheck.getToken(forceRefresh);
    };
    AppCheckTokenProvider2.prototype.addTokenChangeListener = function(listener) {
      var _a7;
      (_a7 = this.appCheckProvider) === null || _a7 === void 0 ? void 0 : _a7.get().then(function(appCheck) {
        return appCheck.addTokenListener(listener);
      });
    };
    AppCheckTokenProvider2.prototype.notifyForInvalidToken = function() {
      warn('Provided AppCheck credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly.');
    };
    return AppCheckTokenProvider2;
  }()
);
var FirebaseAuthTokenProvider = (
  /** @class */
  function() {
    function FirebaseAuthTokenProvider2(appName_, firebaseOptions_, authProvider_) {
      var _this = this;
      this.appName_ = appName_;
      this.firebaseOptions_ = firebaseOptions_;
      this.authProvider_ = authProvider_;
      this.auth_ = null;
      this.auth_ = authProvider_.getImmediate({ optional: true });
      if (!this.auth_) {
        authProvider_.onInit(function(auth) {
          return _this.auth_ = auth;
        });
      }
    }
    FirebaseAuthTokenProvider2.prototype.getToken = function(forceRefresh) {
      var _this = this;
      if (!this.auth_) {
        return new Promise(function(resolve, reject) {
          setTimeout(function() {
            if (_this.auth_) {
              _this.getToken(forceRefresh).then(resolve, reject);
            } else {
              resolve(null);
            }
          }, 0);
        });
      }
      return this.auth_.getToken(forceRefresh).catch(function(error2) {
        if (error2 && error2.code === "auth/token-not-initialized") {
          log("Got auth/token-not-initialized error.  Treating as null token.");
          return null;
        } else {
          return Promise.reject(error2);
        }
      });
    };
    FirebaseAuthTokenProvider2.prototype.addTokenChangeListener = function(listener) {
      if (this.auth_) {
        this.auth_.addAuthTokenListener(listener);
      } else {
        this.authProvider_.get().then(function(auth) {
          return auth.addAuthTokenListener(listener);
        });
      }
    };
    FirebaseAuthTokenProvider2.prototype.removeTokenChangeListener = function(listener) {
      this.authProvider_.get().then(function(auth) {
        return auth.removeAuthTokenListener(listener);
      });
    };
    FirebaseAuthTokenProvider2.prototype.notifyForInvalidToken = function() {
      var errorMessage = 'Provided authentication credentials for the app named "' + this.appName_ + '" are invalid. This usually indicates your app was not initialized correctly. ';
      if ("credential" in this.firebaseOptions_) {
        errorMessage += 'Make sure the "credential" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
      } else if ("serviceAccount" in this.firebaseOptions_) {
        errorMessage += 'Make sure the "serviceAccount" property provided to initializeApp() is authorized to access the specified "databaseURL" and is from the correct project.';
      } else {
        errorMessage += 'Make sure the "apiKey" and "databaseURL" properties provided to initializeApp() match the values provided for your app at https://console.firebase.google.com/.';
      }
      warn(errorMessage);
    };
    return FirebaseAuthTokenProvider2;
  }()
);
var EmulatorTokenProvider = (
  /** @class */
  function() {
    function EmulatorTokenProvider2(accessToken) {
      this.accessToken = accessToken;
    }
    EmulatorTokenProvider2.prototype.getToken = function(forceRefresh) {
      return Promise.resolve({
        accessToken: this.accessToken
      });
    };
    EmulatorTokenProvider2.prototype.addTokenChangeListener = function(listener) {
      listener(this.accessToken);
    };
    EmulatorTokenProvider2.prototype.removeTokenChangeListener = function(listener) {
    };
    EmulatorTokenProvider2.prototype.notifyForInvalidToken = function() {
    };
    EmulatorTokenProvider2.OWNER = "owner";
    return EmulatorTokenProvider2;
  }()
);
var PROTOCOL_VERSION = "5";
var VERSION_PARAM = "v";
var TRANSPORT_SESSION_PARAM = "s";
var REFERER_PARAM = "r";
var FORGE_REF = "f";
var FORGE_DOMAIN_RE = /(console\.firebase|firebase-console-\w+\.corp|firebase\.corp)\.google\.com/;
var LAST_SESSION_PARAM = "ls";
var APPLICATION_ID_PARAM = "p";
var APP_CHECK_TOKEN_PARAM = "ac";
var WEBSOCKET = "websocket";
var LONG_POLLING = "long_polling";
var RepoInfo = (
  /** @class */
  function() {
    function RepoInfo2(host, secure, namespace, webSocketOnly, nodeAdmin, persistenceKey, includeNamespaceInQueryParams) {
      if (nodeAdmin === void 0) {
        nodeAdmin = false;
      }
      if (persistenceKey === void 0) {
        persistenceKey = "";
      }
      if (includeNamespaceInQueryParams === void 0) {
        includeNamespaceInQueryParams = false;
      }
      this.secure = secure;
      this.namespace = namespace;
      this.webSocketOnly = webSocketOnly;
      this.nodeAdmin = nodeAdmin;
      this.persistenceKey = persistenceKey;
      this.includeNamespaceInQueryParams = includeNamespaceInQueryParams;
      this._host = host.toLowerCase();
      this._domain = this._host.substr(this._host.indexOf(".") + 1);
      this.internalHost = PersistentStorage.get("host:" + host) || this._host;
    }
    RepoInfo2.prototype.isCacheableHost = function() {
      return this.internalHost.substr(0, 2) === "s-";
    };
    RepoInfo2.prototype.isCustomHost = function() {
      return this._domain !== "firebaseio.com" && this._domain !== "firebaseio-demo.com";
    };
    Object.defineProperty(RepoInfo2.prototype, "host", {
      get: function() {
        return this._host;
      },
      set: function(newHost) {
        if (newHost !== this.internalHost) {
          this.internalHost = newHost;
          if (this.isCacheableHost()) {
            PersistentStorage.set("host:" + this._host, this.internalHost);
          }
        }
      },
      enumerable: false,
      configurable: true
    });
    RepoInfo2.prototype.toString = function() {
      var str = this.toURLString();
      if (this.persistenceKey) {
        str += "<" + this.persistenceKey + ">";
      }
      return str;
    };
    RepoInfo2.prototype.toURLString = function() {
      var protocol = this.secure ? "https://" : "http://";
      var query2 = this.includeNamespaceInQueryParams ? "?ns=" + this.namespace : "";
      return "" + protocol + this.host + "/" + query2;
    };
    return RepoInfo2;
  }()
);
function repoInfoNeedsQueryParam(repoInfo) {
  return repoInfo.host !== repoInfo.internalHost || repoInfo.isCustomHost() || repoInfo.includeNamespaceInQueryParams;
}
function repoInfoConnectionURL(repoInfo, type, params) {
  assert(typeof type === "string", "typeof type must == string");
  assert(typeof params === "object", "typeof params must == object");
  var connURL;
  if (type === WEBSOCKET) {
    connURL = (repoInfo.secure ? "wss://" : "ws://") + repoInfo.internalHost + "/.ws?";
  } else if (type === LONG_POLLING) {
    connURL = (repoInfo.secure ? "https://" : "http://") + repoInfo.internalHost + "/.lp?";
  } else {
    throw new Error("Unknown connection type: " + type);
  }
  if (repoInfoNeedsQueryParam(repoInfo)) {
    params["ns"] = repoInfo.namespace;
  }
  var pairs = [];
  each(params, function(key, value) {
    pairs.push(key + "=" + value);
  });
  return connURL + pairs.join("&");
}
var StatsCollection = (
  /** @class */
  function() {
    function StatsCollection2() {
      this.counters_ = {};
    }
    StatsCollection2.prototype.incrementCounter = function(name10, amount) {
      if (amount === void 0) {
        amount = 1;
      }
      if (!contains(this.counters_, name10)) {
        this.counters_[name10] = 0;
      }
      this.counters_[name10] += amount;
    };
    StatsCollection2.prototype.get = function() {
      return deepCopy(this.counters_);
    };
    return StatsCollection2;
  }()
);
var collections = {};
var reporters = {};
function statsManagerGetCollection(repoInfo) {
  var hashString = repoInfo.toString();
  if (!collections[hashString]) {
    collections[hashString] = new StatsCollection();
  }
  return collections[hashString];
}
function statsManagerGetOrCreateReporter(repoInfo, creatorFunction) {
  var hashString = repoInfo.toString();
  if (!reporters[hashString]) {
    reporters[hashString] = creatorFunction();
  }
  return reporters[hashString];
}
var PacketReceiver = (
  /** @class */
  function() {
    function PacketReceiver2(onMessage_) {
      this.onMessage_ = onMessage_;
      this.pendingResponses = [];
      this.currentResponseNum = 0;
      this.closeAfterResponse = -1;
      this.onClose = null;
    }
    PacketReceiver2.prototype.closeAfter = function(responseNum, callback) {
      this.closeAfterResponse = responseNum;
      this.onClose = callback;
      if (this.closeAfterResponse < this.currentResponseNum) {
        this.onClose();
        this.onClose = null;
      }
    };
    PacketReceiver2.prototype.handleResponse = function(requestNum, data) {
      var _this = this;
      this.pendingResponses[requestNum] = data;
      var _loop_1 = function() {
        var toProcess = this_1.pendingResponses[this_1.currentResponseNum];
        delete this_1.pendingResponses[this_1.currentResponseNum];
        var _loop_2 = function(i2) {
          if (toProcess[i2]) {
            exceptionGuard(function() {
              _this.onMessage_(toProcess[i2]);
            });
          }
        };
        for (var i = 0; i < toProcess.length; ++i) {
          _loop_2(i);
        }
        if (this_1.currentResponseNum === this_1.closeAfterResponse) {
          if (this_1.onClose) {
            this_1.onClose();
            this_1.onClose = null;
          }
          return "break";
        }
        this_1.currentResponseNum++;
      };
      var this_1 = this;
      while (this.pendingResponses[this.currentResponseNum]) {
        var state_1 = _loop_1();
        if (state_1 === "break")
          break;
      }
    };
    return PacketReceiver2;
  }()
);
var FIREBASE_LONGPOLL_START_PARAM = "start";
var FIREBASE_LONGPOLL_CLOSE_COMMAND = "close";
var FIREBASE_LONGPOLL_COMMAND_CB_NAME = "pLPCommand";
var FIREBASE_LONGPOLL_DATA_CB_NAME = "pRTLPCB";
var FIREBASE_LONGPOLL_ID_PARAM = "id";
var FIREBASE_LONGPOLL_PW_PARAM = "pw";
var FIREBASE_LONGPOLL_SERIAL_PARAM = "ser";
var FIREBASE_LONGPOLL_CALLBACK_ID_PARAM = "cb";
var FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM = "seg";
var FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET = "ts";
var FIREBASE_LONGPOLL_DATA_PARAM = "d";
var FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM = "dframe";
var MAX_URL_DATA_SIZE = 1870;
var SEG_HEADER_SIZE = 30;
var MAX_PAYLOAD_SIZE = MAX_URL_DATA_SIZE - SEG_HEADER_SIZE;
var KEEPALIVE_REQUEST_INTERVAL = 25e3;
var LP_CONNECT_TIMEOUT = 3e4;
var BrowserPollConnection = (
  /** @class */
  function() {
    function BrowserPollConnection2(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
      var _this = this;
      this.connId = connId;
      this.repoInfo = repoInfo;
      this.applicationId = applicationId;
      this.appCheckToken = appCheckToken;
      this.authToken = authToken;
      this.transportSessionId = transportSessionId;
      this.lastSessionId = lastSessionId;
      this.bytesSent = 0;
      this.bytesReceived = 0;
      this.everConnected_ = false;
      this.log_ = logWrapper(connId);
      this.stats_ = statsManagerGetCollection(repoInfo);
      this.urlFn = function(params) {
        if (_this.appCheckToken) {
          params[APP_CHECK_TOKEN_PARAM] = _this.appCheckToken;
        }
        return repoInfoConnectionURL(repoInfo, LONG_POLLING, params);
      };
    }
    BrowserPollConnection2.prototype.open = function(onMessage, onDisconnect) {
      var _this = this;
      this.curSegmentNum = 0;
      this.onDisconnect_ = onDisconnect;
      this.myPacketOrderer = new PacketReceiver(onMessage);
      this.isClosed_ = false;
      this.connectTimeoutTimer_ = setTimeout(function() {
        _this.log_("Timed out trying to connect.");
        _this.onClosed_();
        _this.connectTimeoutTimer_ = null;
      }, Math.floor(LP_CONNECT_TIMEOUT));
      executeWhenDOMReady(function() {
        if (_this.isClosed_) {
          return;
        }
        _this.scriptTagHolder = new FirebaseIFrameScriptHolder(function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _a7 = __read(args, 5), command = _a7[0], arg1 = _a7[1], arg2 = _a7[2];
          _a7[3];
          _a7[4];
          _this.incrementIncomingBytes_(args);
          if (!_this.scriptTagHolder) {
            return;
          }
          if (_this.connectTimeoutTimer_) {
            clearTimeout(_this.connectTimeoutTimer_);
            _this.connectTimeoutTimer_ = null;
          }
          _this.everConnected_ = true;
          if (command === FIREBASE_LONGPOLL_START_PARAM) {
            _this.id = arg1;
            _this.password = arg2;
          } else if (command === FIREBASE_LONGPOLL_CLOSE_COMMAND) {
            if (arg1) {
              _this.scriptTagHolder.sendNewPolls = false;
              _this.myPacketOrderer.closeAfter(arg1, function() {
                _this.onClosed_();
              });
            } else {
              _this.onClosed_();
            }
          } else {
            throw new Error("Unrecognized command received: " + command);
          }
        }, function() {
          var args = [];
          for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
          }
          var _a7 = __read(args, 2), pN = _a7[0], data = _a7[1];
          _this.incrementIncomingBytes_(args);
          _this.myPacketOrderer.handleResponse(pN, data);
        }, function() {
          _this.onClosed_();
        }, _this.urlFn);
        var urlParams = {};
        urlParams[FIREBASE_LONGPOLL_START_PARAM] = "t";
        urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = Math.floor(Math.random() * 1e8);
        if (_this.scriptTagHolder.uniqueCallbackIdentifier) {
          urlParams[FIREBASE_LONGPOLL_CALLBACK_ID_PARAM] = _this.scriptTagHolder.uniqueCallbackIdentifier;
        }
        urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
        if (_this.transportSessionId) {
          urlParams[TRANSPORT_SESSION_PARAM] = _this.transportSessionId;
        }
        if (_this.lastSessionId) {
          urlParams[LAST_SESSION_PARAM] = _this.lastSessionId;
        }
        if (_this.applicationId) {
          urlParams[APPLICATION_ID_PARAM] = _this.applicationId;
        }
        if (_this.appCheckToken) {
          urlParams[APP_CHECK_TOKEN_PARAM] = _this.appCheckToken;
        }
        if (typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
          urlParams[REFERER_PARAM] = FORGE_REF;
        }
        var connectURL = _this.urlFn(urlParams);
        _this.log_("Connecting via long-poll to " + connectURL);
        _this.scriptTagHolder.addTag(connectURL, function() {
        });
      });
    };
    BrowserPollConnection2.prototype.start = function() {
      this.scriptTagHolder.startLongPoll(this.id, this.password);
      this.addDisconnectPingFrame(this.id, this.password);
    };
    BrowserPollConnection2.forceAllow = function() {
      BrowserPollConnection2.forceAllow_ = true;
    };
    BrowserPollConnection2.forceDisallow = function() {
      BrowserPollConnection2.forceDisallow_ = true;
    };
    BrowserPollConnection2.isAvailable = function() {
      if (isNodeSdk()) {
        return false;
      } else if (BrowserPollConnection2.forceAllow_) {
        return true;
      } else {
        return !BrowserPollConnection2.forceDisallow_ && typeof document !== "undefined" && document.createElement != null && !isChromeExtensionContentScript() && !isWindowsStoreApp();
      }
    };
    BrowserPollConnection2.prototype.markConnectionHealthy = function() {
    };
    BrowserPollConnection2.prototype.shutdown_ = function() {
      this.isClosed_ = true;
      if (this.scriptTagHolder) {
        this.scriptTagHolder.close();
        this.scriptTagHolder = null;
      }
      if (this.myDisconnFrame) {
        document.body.removeChild(this.myDisconnFrame);
        this.myDisconnFrame = null;
      }
      if (this.connectTimeoutTimer_) {
        clearTimeout(this.connectTimeoutTimer_);
        this.connectTimeoutTimer_ = null;
      }
    };
    BrowserPollConnection2.prototype.onClosed_ = function() {
      if (!this.isClosed_) {
        this.log_("Longpoll is closing itself");
        this.shutdown_();
        if (this.onDisconnect_) {
          this.onDisconnect_(this.everConnected_);
          this.onDisconnect_ = null;
        }
      }
    };
    BrowserPollConnection2.prototype.close = function() {
      if (!this.isClosed_) {
        this.log_("Longpoll is being closed.");
        this.shutdown_();
      }
    };
    BrowserPollConnection2.prototype.send = function(data) {
      var dataStr = stringify(data);
      this.bytesSent += dataStr.length;
      this.stats_.incrementCounter("bytes_sent", dataStr.length);
      var base64data = base64Encode(dataStr);
      var dataSegs = splitStringBySize(base64data, MAX_PAYLOAD_SIZE);
      for (var i = 0; i < dataSegs.length; i++) {
        this.scriptTagHolder.enqueueSegment(this.curSegmentNum, dataSegs.length, dataSegs[i]);
        this.curSegmentNum++;
      }
    };
    BrowserPollConnection2.prototype.addDisconnectPingFrame = function(id, pw) {
      if (isNodeSdk()) {
        return;
      }
      this.myDisconnFrame = document.createElement("iframe");
      var urlParams = {};
      urlParams[FIREBASE_LONGPOLL_DISCONN_FRAME_REQUEST_PARAM] = "t";
      urlParams[FIREBASE_LONGPOLL_ID_PARAM] = id;
      urlParams[FIREBASE_LONGPOLL_PW_PARAM] = pw;
      this.myDisconnFrame.src = this.urlFn(urlParams);
      this.myDisconnFrame.style.display = "none";
      document.body.appendChild(this.myDisconnFrame);
    };
    BrowserPollConnection2.prototype.incrementIncomingBytes_ = function(args) {
      var bytesReceived = stringify(args).length;
      this.bytesReceived += bytesReceived;
      this.stats_.incrementCounter("bytes_received", bytesReceived);
    };
    return BrowserPollConnection2;
  }()
);
var FirebaseIFrameScriptHolder = (
  /** @class */
  function() {
    function FirebaseIFrameScriptHolder2(commandCB, onMessageCB, onDisconnect, urlFn) {
      this.onDisconnect = onDisconnect;
      this.urlFn = urlFn;
      this.outstandingRequests = /* @__PURE__ */ new Set();
      this.pendingSegs = [];
      this.currentSerial = Math.floor(Math.random() * 1e8);
      this.sendNewPolls = true;
      if (!isNodeSdk()) {
        this.uniqueCallbackIdentifier = LUIDGenerator();
        window[FIREBASE_LONGPOLL_COMMAND_CB_NAME + this.uniqueCallbackIdentifier] = commandCB;
        window[FIREBASE_LONGPOLL_DATA_CB_NAME + this.uniqueCallbackIdentifier] = onMessageCB;
        this.myIFrame = FirebaseIFrameScriptHolder2.createIFrame_();
        var script = "";
        if (this.myIFrame.src && this.myIFrame.src.substr(0, "javascript:".length) === "javascript:") {
          var currentDomain = document.domain;
          script = '<script>document.domain="' + currentDomain + '";<\/script>';
        }
        var iframeContents = "<html><body>" + script + "</body></html>";
        try {
          this.myIFrame.doc.open();
          this.myIFrame.doc.write(iframeContents);
          this.myIFrame.doc.close();
        } catch (e) {
          log("frame writing exception");
          if (e.stack) {
            log(e.stack);
          }
          log(e);
        }
      } else {
        this.commandCB = commandCB;
        this.onMessageCB = onMessageCB;
      }
    }
    FirebaseIFrameScriptHolder2.createIFrame_ = function() {
      var iframe = document.createElement("iframe");
      iframe.style.display = "none";
      if (document.body) {
        document.body.appendChild(iframe);
        try {
          var a = iframe.contentWindow.document;
          if (!a) {
            log("No IE domain setting required");
          }
        } catch (e) {
          var domain = document.domain;
          iframe.src = "javascript:void((function(){document.open();document.domain='" + domain + "';document.close();})())";
        }
      } else {
        throw "Document body has not initialized. Wait to initialize Firebase until after the document is ready.";
      }
      if (iframe.contentDocument) {
        iframe.doc = iframe.contentDocument;
      } else if (iframe.contentWindow) {
        iframe.doc = iframe.contentWindow.document;
      } else if (iframe.document) {
        iframe.doc = iframe.document;
      }
      return iframe;
    };
    FirebaseIFrameScriptHolder2.prototype.close = function() {
      var _this = this;
      this.alive = false;
      if (this.myIFrame) {
        this.myIFrame.doc.body.innerHTML = "";
        setTimeout(function() {
          if (_this.myIFrame !== null) {
            document.body.removeChild(_this.myIFrame);
            _this.myIFrame = null;
          }
        }, Math.floor(0));
      }
      var onDisconnect = this.onDisconnect;
      if (onDisconnect) {
        this.onDisconnect = null;
        onDisconnect();
      }
    };
    FirebaseIFrameScriptHolder2.prototype.startLongPoll = function(id, pw) {
      this.myID = id;
      this.myPW = pw;
      this.alive = true;
      while (this.newRequest_()) {
      }
    };
    FirebaseIFrameScriptHolder2.prototype.newRequest_ = function() {
      if (this.alive && this.sendNewPolls && this.outstandingRequests.size < (this.pendingSegs.length > 0 ? 2 : 1)) {
        this.currentSerial++;
        var urlParams = {};
        urlParams[FIREBASE_LONGPOLL_ID_PARAM] = this.myID;
        urlParams[FIREBASE_LONGPOLL_PW_PARAM] = this.myPW;
        urlParams[FIREBASE_LONGPOLL_SERIAL_PARAM] = this.currentSerial;
        var theURL = this.urlFn(urlParams);
        var curDataString = "";
        var i = 0;
        while (this.pendingSegs.length > 0) {
          var nextSeg = this.pendingSegs[0];
          if (nextSeg.d.length + SEG_HEADER_SIZE + curDataString.length <= MAX_URL_DATA_SIZE) {
            var theSeg = this.pendingSegs.shift();
            curDataString = curDataString + "&" + FIREBASE_LONGPOLL_SEGMENT_NUM_PARAM + i + "=" + theSeg.seg + "&" + FIREBASE_LONGPOLL_SEGMENTS_IN_PACKET + i + "=" + theSeg.ts + "&" + FIREBASE_LONGPOLL_DATA_PARAM + i + "=" + theSeg.d;
            i++;
          } else {
            break;
          }
        }
        theURL = theURL + curDataString;
        this.addLongPollTag_(theURL, this.currentSerial);
        return true;
      } else {
        return false;
      }
    };
    FirebaseIFrameScriptHolder2.prototype.enqueueSegment = function(segnum, totalsegs, data) {
      this.pendingSegs.push({ seg: segnum, ts: totalsegs, d: data });
      if (this.alive) {
        this.newRequest_();
      }
    };
    FirebaseIFrameScriptHolder2.prototype.addLongPollTag_ = function(url, serial) {
      var _this = this;
      this.outstandingRequests.add(serial);
      var doNewRequest = function() {
        _this.outstandingRequests.delete(serial);
        _this.newRequest_();
      };
      var keepaliveTimeout = setTimeout(doNewRequest, Math.floor(KEEPALIVE_REQUEST_INTERVAL));
      var readyStateCB = function() {
        clearTimeout(keepaliveTimeout);
        doNewRequest();
      };
      this.addTag(url, readyStateCB);
    };
    FirebaseIFrameScriptHolder2.prototype.addTag = function(url, loadCB) {
      var _this = this;
      if (isNodeSdk()) {
        this.doNodeLongPoll(url, loadCB);
      } else {
        setTimeout(function() {
          try {
            if (!_this.sendNewPolls) {
              return;
            }
            var newScript_1 = _this.myIFrame.doc.createElement("script");
            newScript_1.type = "text/javascript";
            newScript_1.async = true;
            newScript_1.src = url;
            newScript_1.onload = newScript_1.onreadystatechange = function() {
              var rstate = newScript_1.readyState;
              if (!rstate || rstate === "loaded" || rstate === "complete") {
                newScript_1.onload = newScript_1.onreadystatechange = null;
                if (newScript_1.parentNode) {
                  newScript_1.parentNode.removeChild(newScript_1);
                }
                loadCB();
              }
            };
            newScript_1.onerror = function() {
              log("Long-poll script failed to load: " + url);
              _this.sendNewPolls = false;
              _this.close();
            };
            _this.myIFrame.doc.body.appendChild(newScript_1);
          } catch (e) {
          }
        }, Math.floor(1));
      }
    };
    return FirebaseIFrameScriptHolder2;
  }()
);
var WEBSOCKET_MAX_FRAME_SIZE = 16384;
var WEBSOCKET_KEEPALIVE_INTERVAL = 45e3;
var WebSocketImpl = null;
if (typeof MozWebSocket !== "undefined") {
  WebSocketImpl = MozWebSocket;
} else if (typeof WebSocket !== "undefined") {
  WebSocketImpl = WebSocket;
}
var WebSocketConnection = (
  /** @class */
  function() {
    function WebSocketConnection2(connId, repoInfo, applicationId, appCheckToken, authToken, transportSessionId, lastSessionId) {
      this.connId = connId;
      this.applicationId = applicationId;
      this.appCheckToken = appCheckToken;
      this.authToken = authToken;
      this.keepaliveTimer = null;
      this.frames = null;
      this.totalFrames = 0;
      this.bytesSent = 0;
      this.bytesReceived = 0;
      this.log_ = logWrapper(this.connId);
      this.stats_ = statsManagerGetCollection(repoInfo);
      this.connURL = WebSocketConnection2.connectionURL_(repoInfo, transportSessionId, lastSessionId, appCheckToken);
      this.nodeAdmin = repoInfo.nodeAdmin;
    }
    WebSocketConnection2.connectionURL_ = function(repoInfo, transportSessionId, lastSessionId, appCheckToken) {
      var urlParams = {};
      urlParams[VERSION_PARAM] = PROTOCOL_VERSION;
      if (!isNodeSdk() && typeof location !== "undefined" && location.hostname && FORGE_DOMAIN_RE.test(location.hostname)) {
        urlParams[REFERER_PARAM] = FORGE_REF;
      }
      if (transportSessionId) {
        urlParams[TRANSPORT_SESSION_PARAM] = transportSessionId;
      }
      if (lastSessionId) {
        urlParams[LAST_SESSION_PARAM] = lastSessionId;
      }
      if (appCheckToken) {
        urlParams[APP_CHECK_TOKEN_PARAM] = appCheckToken;
      }
      return repoInfoConnectionURL(repoInfo, WEBSOCKET, urlParams);
    };
    WebSocketConnection2.prototype.open = function(onMessage, onDisconnect) {
      var _this = this;
      this.onDisconnect = onDisconnect;
      this.onMessage = onMessage;
      this.log_("Websocket connecting to " + this.connURL);
      this.everConnected_ = false;
      PersistentStorage.set("previous_websocket_failure", true);
      try {
        if (isNodeSdk()) {
          var device = this.nodeAdmin ? "AdminNode" : "Node";
          var options = {
            headers: {
              "User-Agent": "Firebase/" + PROTOCOL_VERSION + "/" + SDK_VERSION + "/" + process.platform + "/" + device,
              "X-Firebase-GMPID": this.applicationId || ""
            }
          };
          if (this.authToken) {
            options.headers["Authorization"] = "Bearer " + this.authToken;
          }
          if (this.appCheckToken) {
            options.headers["X-Firebase-AppCheck"] = this.appCheckToken;
          }
          var env = process["env"];
          var proxy = this.connURL.indexOf("wss://") === 0 ? env["HTTPS_PROXY"] || env["https_proxy"] : env["HTTP_PROXY"] || env["http_proxy"];
          if (proxy) {
            options["proxy"] = { origin: proxy };
          }
          this.mySock = new WebSocketImpl(this.connURL, [], options);
        } else {
          var options = {
            headers: {
              "X-Firebase-GMPID": this.applicationId || "",
              "X-Firebase-AppCheck": this.appCheckToken || ""
            }
          };
          this.mySock = new WebSocketImpl(this.connURL, [], options);
        }
      } catch (e) {
        this.log_("Error instantiating WebSocket.");
        var error2 = e.message || e.data;
        if (error2) {
          this.log_(error2);
        }
        this.onClosed_();
        return;
      }
      this.mySock.onopen = function() {
        _this.log_("Websocket connected.");
        _this.everConnected_ = true;
      };
      this.mySock.onclose = function() {
        _this.log_("Websocket connection was disconnected.");
        _this.mySock = null;
        _this.onClosed_();
      };
      this.mySock.onmessage = function(m) {
        _this.handleIncomingFrame(m);
      };
      this.mySock.onerror = function(e) {
        _this.log_("WebSocket error.  Closing connection.");
        var error3 = e.message || e.data;
        if (error3) {
          _this.log_(error3);
        }
        _this.onClosed_();
      };
    };
    WebSocketConnection2.prototype.start = function() {
    };
    WebSocketConnection2.forceDisallow = function() {
      WebSocketConnection2.forceDisallow_ = true;
    };
    WebSocketConnection2.isAvailable = function() {
      var isOldAndroid = false;
      if (typeof navigator !== "undefined" && navigator.userAgent) {
        var oldAndroidRegex = /Android ([0-9]{0,}\.[0-9]{0,})/;
        var oldAndroidMatch = navigator.userAgent.match(oldAndroidRegex);
        if (oldAndroidMatch && oldAndroidMatch.length > 1) {
          if (parseFloat(oldAndroidMatch[1]) < 4.4) {
            isOldAndroid = true;
          }
        }
      }
      return !isOldAndroid && WebSocketImpl !== null && !WebSocketConnection2.forceDisallow_;
    };
    WebSocketConnection2.previouslyFailed = function() {
      return PersistentStorage.isInMemoryStorage || PersistentStorage.get("previous_websocket_failure") === true;
    };
    WebSocketConnection2.prototype.markConnectionHealthy = function() {
      PersistentStorage.remove("previous_websocket_failure");
    };
    WebSocketConnection2.prototype.appendFrame_ = function(data) {
      this.frames.push(data);
      if (this.frames.length === this.totalFrames) {
        var fullMess = this.frames.join("");
        this.frames = null;
        var jsonMess = jsonEval(fullMess);
        this.onMessage(jsonMess);
      }
    };
    WebSocketConnection2.prototype.handleNewFrameCount_ = function(frameCount) {
      this.totalFrames = frameCount;
      this.frames = [];
    };
    WebSocketConnection2.prototype.extractFrameCount_ = function(data) {
      assert(this.frames === null, "We already have a frame buffer");
      if (data.length <= 6) {
        var frameCount = Number(data);
        if (!isNaN(frameCount)) {
          this.handleNewFrameCount_(frameCount);
          return null;
        }
      }
      this.handleNewFrameCount_(1);
      return data;
    };
    WebSocketConnection2.prototype.handleIncomingFrame = function(mess) {
      if (this.mySock === null) {
        return;
      }
      var data = mess["data"];
      this.bytesReceived += data.length;
      this.stats_.incrementCounter("bytes_received", data.length);
      this.resetKeepAlive();
      if (this.frames !== null) {
        this.appendFrame_(data);
      } else {
        var remainingData = this.extractFrameCount_(data);
        if (remainingData !== null) {
          this.appendFrame_(remainingData);
        }
      }
    };
    WebSocketConnection2.prototype.send = function(data) {
      this.resetKeepAlive();
      var dataStr = stringify(data);
      this.bytesSent += dataStr.length;
      this.stats_.incrementCounter("bytes_sent", dataStr.length);
      var dataSegs = splitStringBySize(dataStr, WEBSOCKET_MAX_FRAME_SIZE);
      if (dataSegs.length > 1) {
        this.sendString_(String(dataSegs.length));
      }
      for (var i = 0; i < dataSegs.length; i++) {
        this.sendString_(dataSegs[i]);
      }
    };
    WebSocketConnection2.prototype.shutdown_ = function() {
      this.isClosed_ = true;
      if (this.keepaliveTimer) {
        clearInterval(this.keepaliveTimer);
        this.keepaliveTimer = null;
      }
      if (this.mySock) {
        this.mySock.close();
        this.mySock = null;
      }
    };
    WebSocketConnection2.prototype.onClosed_ = function() {
      if (!this.isClosed_) {
        this.log_("WebSocket is closing itself");
        this.shutdown_();
        if (this.onDisconnect) {
          this.onDisconnect(this.everConnected_);
          this.onDisconnect = null;
        }
      }
    };
    WebSocketConnection2.prototype.close = function() {
      if (!this.isClosed_) {
        this.log_("WebSocket is being closed");
        this.shutdown_();
      }
    };
    WebSocketConnection2.prototype.resetKeepAlive = function() {
      var _this = this;
      clearInterval(this.keepaliveTimer);
      this.keepaliveTimer = setInterval(function() {
        if (_this.mySock) {
          _this.sendString_("0");
        }
        _this.resetKeepAlive();
      }, Math.floor(WEBSOCKET_KEEPALIVE_INTERVAL));
    };
    WebSocketConnection2.prototype.sendString_ = function(str) {
      try {
        this.mySock.send(str);
      } catch (e) {
        this.log_("Exception thrown from WebSocket.send():", e.message || e.data, "Closing connection.");
        setTimeout(this.onClosed_.bind(this), 0);
      }
    };
    WebSocketConnection2.responsesRequiredToBeHealthy = 2;
    WebSocketConnection2.healthyTimeout = 3e4;
    return WebSocketConnection2;
  }()
);
var TransportManager = (
  /** @class */
  function() {
    function TransportManager2(repoInfo) {
      this.initTransports_(repoInfo);
    }
    Object.defineProperty(TransportManager2, "ALL_TRANSPORTS", {
      get: function() {
        return [BrowserPollConnection, WebSocketConnection];
      },
      enumerable: false,
      configurable: true
    });
    TransportManager2.prototype.initTransports_ = function(repoInfo) {
      var e_1, _a7;
      var isWebSocketsAvailable2 = WebSocketConnection && WebSocketConnection["isAvailable"]();
      var isSkipPollConnection = isWebSocketsAvailable2 && !WebSocketConnection.previouslyFailed();
      if (repoInfo.webSocketOnly) {
        if (!isWebSocketsAvailable2) {
          warn("wss:// URL used, but browser isn't known to support websockets.  Trying anyway.");
        }
        isSkipPollConnection = true;
      }
      if (isSkipPollConnection) {
        this.transports_ = [WebSocketConnection];
      } else {
        var transports = this.transports_ = [];
        try {
          for (var _b = __values(TransportManager2.ALL_TRANSPORTS), _c = _b.next(); !_c.done; _c = _b.next()) {
            var transport = _c.value;
            if (transport && transport["isAvailable"]()) {
              transports.push(transport);
            }
          }
        } catch (e_1_1) {
          e_1 = { error: e_1_1 };
        } finally {
          try {
            if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
          } finally {
            if (e_1) throw e_1.error;
          }
        }
      }
    };
    TransportManager2.prototype.initialTransport = function() {
      if (this.transports_.length > 0) {
        return this.transports_[0];
      } else {
        throw new Error("No transports available");
      }
    };
    TransportManager2.prototype.upgradeTransport = function() {
      if (this.transports_.length > 1) {
        return this.transports_[1];
      } else {
        return null;
      }
    };
    return TransportManager2;
  }()
);
var UPGRADE_TIMEOUT = 6e4;
var DELAY_BEFORE_SENDING_EXTRA_REQUESTS = 5e3;
var BYTES_SENT_HEALTHY_OVERRIDE = 10 * 1024;
var BYTES_RECEIVED_HEALTHY_OVERRIDE = 100 * 1024;
var MESSAGE_TYPE = "t";
var MESSAGE_DATA = "d";
var CONTROL_SHUTDOWN = "s";
var CONTROL_RESET = "r";
var CONTROL_ERROR = "e";
var CONTROL_PONG = "o";
var SWITCH_ACK = "a";
var END_TRANSMISSION = "n";
var PING = "p";
var SERVER_HELLO = "h";
var Connection = (
  /** @class */
  function() {
    function Connection2(id, repoInfo_, applicationId_, appCheckToken_, authToken_, onMessage_, onReady_, onDisconnect_, onKill_, lastSessionId) {
      this.id = id;
      this.repoInfo_ = repoInfo_;
      this.applicationId_ = applicationId_;
      this.appCheckToken_ = appCheckToken_;
      this.authToken_ = authToken_;
      this.onMessage_ = onMessage_;
      this.onReady_ = onReady_;
      this.onDisconnect_ = onDisconnect_;
      this.onKill_ = onKill_;
      this.lastSessionId = lastSessionId;
      this.connectionCount = 0;
      this.pendingDataMessages = [];
      this.state_ = 0;
      this.log_ = logWrapper("c:" + this.id + ":");
      this.transportManager_ = new TransportManager(repoInfo_);
      this.log_("Connection created");
      this.start_();
    }
    Connection2.prototype.start_ = function() {
      var _this = this;
      var conn = this.transportManager_.initialTransport();
      this.conn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, null, this.lastSessionId);
      this.primaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
      var onMessageReceived = this.connReceiver_(this.conn_);
      var onConnectionLost = this.disconnReceiver_(this.conn_);
      this.tx_ = this.conn_;
      this.rx_ = this.conn_;
      this.secondaryConn_ = null;
      this.isHealthy_ = false;
      setTimeout(function() {
        _this.conn_ && _this.conn_.open(onMessageReceived, onConnectionLost);
      }, Math.floor(0));
      var healthyTimeoutMS = conn["healthyTimeout"] || 0;
      if (healthyTimeoutMS > 0) {
        this.healthyTimeout_ = setTimeoutNonBlocking(function() {
          _this.healthyTimeout_ = null;
          if (!_this.isHealthy_) {
            if (_this.conn_ && _this.conn_.bytesReceived > BYTES_RECEIVED_HEALTHY_OVERRIDE) {
              _this.log_("Connection exceeded healthy timeout but has received " + _this.conn_.bytesReceived + " bytes.  Marking connection healthy.");
              _this.isHealthy_ = true;
              _this.conn_.markConnectionHealthy();
            } else if (_this.conn_ && _this.conn_.bytesSent > BYTES_SENT_HEALTHY_OVERRIDE) {
              _this.log_("Connection exceeded healthy timeout but has sent " + _this.conn_.bytesSent + " bytes.  Leaving connection alive.");
            } else {
              _this.log_("Closing unhealthy connection after timeout.");
              _this.close();
            }
          }
        }, Math.floor(healthyTimeoutMS));
      }
    };
    Connection2.prototype.nextTransportId_ = function() {
      return "c:" + this.id + ":" + this.connectionCount++;
    };
    Connection2.prototype.disconnReceiver_ = function(conn) {
      var _this = this;
      return function(everConnected) {
        if (conn === _this.conn_) {
          _this.onConnectionLost_(everConnected);
        } else if (conn === _this.secondaryConn_) {
          _this.log_("Secondary connection lost.");
          _this.onSecondaryConnectionLost_();
        } else {
          _this.log_("closing an old connection");
        }
      };
    };
    Connection2.prototype.connReceiver_ = function(conn) {
      var _this = this;
      return function(message) {
        if (_this.state_ !== 2) {
          if (conn === _this.rx_) {
            _this.onPrimaryMessageReceived_(message);
          } else if (conn === _this.secondaryConn_) {
            _this.onSecondaryMessageReceived_(message);
          } else {
            _this.log_("message on old connection");
          }
        }
      };
    };
    Connection2.prototype.sendRequest = function(dataMsg) {
      var msg = { t: "d", d: dataMsg };
      this.sendData_(msg);
    };
    Connection2.prototype.tryCleanupConnection = function() {
      if (this.tx_ === this.secondaryConn_ && this.rx_ === this.secondaryConn_) {
        this.log_("cleaning up and promoting a connection: " + this.secondaryConn_.connId);
        this.conn_ = this.secondaryConn_;
        this.secondaryConn_ = null;
      }
    };
    Connection2.prototype.onSecondaryControl_ = function(controlData) {
      if (MESSAGE_TYPE in controlData) {
        var cmd = controlData[MESSAGE_TYPE];
        if (cmd === SWITCH_ACK) {
          this.upgradeIfSecondaryHealthy_();
        } else if (cmd === CONTROL_RESET) {
          this.log_("Got a reset on secondary, closing it");
          this.secondaryConn_.close();
          if (this.tx_ === this.secondaryConn_ || this.rx_ === this.secondaryConn_) {
            this.close();
          }
        } else if (cmd === CONTROL_PONG) {
          this.log_("got pong on secondary.");
          this.secondaryResponsesRequired_--;
          this.upgradeIfSecondaryHealthy_();
        }
      }
    };
    Connection2.prototype.onSecondaryMessageReceived_ = function(parsedData) {
      var layer = requireKey("t", parsedData);
      var data = requireKey("d", parsedData);
      if (layer === "c") {
        this.onSecondaryControl_(data);
      } else if (layer === "d") {
        this.pendingDataMessages.push(data);
      } else {
        throw new Error("Unknown protocol layer: " + layer);
      }
    };
    Connection2.prototype.upgradeIfSecondaryHealthy_ = function() {
      if (this.secondaryResponsesRequired_ <= 0) {
        this.log_("Secondary connection is healthy.");
        this.isHealthy_ = true;
        this.secondaryConn_.markConnectionHealthy();
        this.proceedWithUpgrade_();
      } else {
        this.log_("sending ping on secondary.");
        this.secondaryConn_.send({ t: "c", d: { t: PING, d: {} } });
      }
    };
    Connection2.prototype.proceedWithUpgrade_ = function() {
      this.secondaryConn_.start();
      this.log_("sending client ack on secondary");
      this.secondaryConn_.send({ t: "c", d: { t: SWITCH_ACK, d: {} } });
      this.log_("Ending transmission on primary");
      this.conn_.send({ t: "c", d: { t: END_TRANSMISSION, d: {} } });
      this.tx_ = this.secondaryConn_;
      this.tryCleanupConnection();
    };
    Connection2.prototype.onPrimaryMessageReceived_ = function(parsedData) {
      var layer = requireKey("t", parsedData);
      var data = requireKey("d", parsedData);
      if (layer === "c") {
        this.onControl_(data);
      } else if (layer === "d") {
        this.onDataMessage_(data);
      }
    };
    Connection2.prototype.onDataMessage_ = function(message) {
      this.onPrimaryResponse_();
      this.onMessage_(message);
    };
    Connection2.prototype.onPrimaryResponse_ = function() {
      if (!this.isHealthy_) {
        this.primaryResponsesRequired_--;
        if (this.primaryResponsesRequired_ <= 0) {
          this.log_("Primary connection is healthy.");
          this.isHealthy_ = true;
          this.conn_.markConnectionHealthy();
        }
      }
    };
    Connection2.prototype.onControl_ = function(controlData) {
      var cmd = requireKey(MESSAGE_TYPE, controlData);
      if (MESSAGE_DATA in controlData) {
        var payload = controlData[MESSAGE_DATA];
        if (cmd === SERVER_HELLO) {
          this.onHandshake_(payload);
        } else if (cmd === END_TRANSMISSION) {
          this.log_("recvd end transmission on primary");
          this.rx_ = this.secondaryConn_;
          for (var i = 0; i < this.pendingDataMessages.length; ++i) {
            this.onDataMessage_(this.pendingDataMessages[i]);
          }
          this.pendingDataMessages = [];
          this.tryCleanupConnection();
        } else if (cmd === CONTROL_SHUTDOWN) {
          this.onConnectionShutdown_(payload);
        } else if (cmd === CONTROL_RESET) {
          this.onReset_(payload);
        } else if (cmd === CONTROL_ERROR) {
          error("Server Error: " + payload);
        } else if (cmd === CONTROL_PONG) {
          this.log_("got pong on primary.");
          this.onPrimaryResponse_();
          this.sendPingOnPrimaryIfNecessary_();
        } else {
          error("Unknown control packet command: " + cmd);
        }
      }
    };
    Connection2.prototype.onHandshake_ = function(handshake) {
      var timestamp = handshake.ts;
      var version10 = handshake.v;
      var host = handshake.h;
      this.sessionId = handshake.s;
      this.repoInfo_.host = host;
      if (this.state_ === 0) {
        this.conn_.start();
        this.onConnectionEstablished_(this.conn_, timestamp);
        if (PROTOCOL_VERSION !== version10) {
          warn("Protocol version mismatch detected");
        }
        this.tryStartUpgrade_();
      }
    };
    Connection2.prototype.tryStartUpgrade_ = function() {
      var conn = this.transportManager_.upgradeTransport();
      if (conn) {
        this.startUpgrade_(conn);
      }
    };
    Connection2.prototype.startUpgrade_ = function(conn) {
      var _this = this;
      this.secondaryConn_ = new conn(this.nextTransportId_(), this.repoInfo_, this.applicationId_, this.appCheckToken_, this.authToken_, this.sessionId);
      this.secondaryResponsesRequired_ = conn["responsesRequiredToBeHealthy"] || 0;
      var onMessage = this.connReceiver_(this.secondaryConn_);
      var onDisconnect = this.disconnReceiver_(this.secondaryConn_);
      this.secondaryConn_.open(onMessage, onDisconnect);
      setTimeoutNonBlocking(function() {
        if (_this.secondaryConn_) {
          _this.log_("Timed out trying to upgrade.");
          _this.secondaryConn_.close();
        }
      }, Math.floor(UPGRADE_TIMEOUT));
    };
    Connection2.prototype.onReset_ = function(host) {
      this.log_("Reset packet received.  New host: " + host);
      this.repoInfo_.host = host;
      if (this.state_ === 1) {
        this.close();
      } else {
        this.closeConnections_();
        this.start_();
      }
    };
    Connection2.prototype.onConnectionEstablished_ = function(conn, timestamp) {
      var _this = this;
      this.log_("Realtime connection established.");
      this.conn_ = conn;
      this.state_ = 1;
      if (this.onReady_) {
        this.onReady_(timestamp, this.sessionId);
        this.onReady_ = null;
      }
      if (this.primaryResponsesRequired_ === 0) {
        this.log_("Primary connection is healthy.");
        this.isHealthy_ = true;
      } else {
        setTimeoutNonBlocking(function() {
          _this.sendPingOnPrimaryIfNecessary_();
        }, Math.floor(DELAY_BEFORE_SENDING_EXTRA_REQUESTS));
      }
    };
    Connection2.prototype.sendPingOnPrimaryIfNecessary_ = function() {
      if (!this.isHealthy_ && this.state_ === 1) {
        this.log_("sending ping on primary.");
        this.sendData_({ t: "c", d: { t: PING, d: {} } });
      }
    };
    Connection2.prototype.onSecondaryConnectionLost_ = function() {
      var conn = this.secondaryConn_;
      this.secondaryConn_ = null;
      if (this.tx_ === conn || this.rx_ === conn) {
        this.close();
      }
    };
    Connection2.prototype.onConnectionLost_ = function(everConnected) {
      this.conn_ = null;
      if (!everConnected && this.state_ === 0) {
        this.log_("Realtime connection failed.");
        if (this.repoInfo_.isCacheableHost()) {
          PersistentStorage.remove("host:" + this.repoInfo_.host);
          this.repoInfo_.internalHost = this.repoInfo_.host;
        }
      } else if (this.state_ === 1) {
        this.log_("Realtime connection lost.");
      }
      this.close();
    };
    Connection2.prototype.onConnectionShutdown_ = function(reason) {
      this.log_("Connection shutdown command received. Shutting down...");
      if (this.onKill_) {
        this.onKill_(reason);
        this.onKill_ = null;
      }
      this.onDisconnect_ = null;
      this.close();
    };
    Connection2.prototype.sendData_ = function(data) {
      if (this.state_ !== 1) {
        throw "Connection is not connected";
      } else {
        this.tx_.send(data);
      }
    };
    Connection2.prototype.close = function() {
      if (this.state_ !== 2) {
        this.log_("Closing realtime connection.");
        this.state_ = 2;
        this.closeConnections_();
        if (this.onDisconnect_) {
          this.onDisconnect_();
          this.onDisconnect_ = null;
        }
      }
    };
    Connection2.prototype.closeConnections_ = function() {
      this.log_("Shutting down all connections");
      if (this.conn_) {
        this.conn_.close();
        this.conn_ = null;
      }
      if (this.secondaryConn_) {
        this.secondaryConn_.close();
        this.secondaryConn_ = null;
      }
      if (this.healthyTimeout_) {
        clearTimeout(this.healthyTimeout_);
        this.healthyTimeout_ = null;
      }
    };
    return Connection2;
  }()
);
var ServerActions = (
  /** @class */
  function() {
    function ServerActions2() {
    }
    ServerActions2.prototype.put = function(pathString, data, onComplete, hash) {
    };
    ServerActions2.prototype.merge = function(pathString, data, onComplete, hash) {
    };
    ServerActions2.prototype.refreshAuthToken = function(token) {
    };
    ServerActions2.prototype.refreshAppCheckToken = function(token) {
    };
    ServerActions2.prototype.onDisconnectPut = function(pathString, data, onComplete) {
    };
    ServerActions2.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
    };
    ServerActions2.prototype.onDisconnectCancel = function(pathString, onComplete) {
    };
    ServerActions2.prototype.reportStats = function(stats2) {
    };
    return ServerActions2;
  }()
);
var EventEmitter = (
  /** @class */
  function() {
    function EventEmitter2(allowedEvents_) {
      this.allowedEvents_ = allowedEvents_;
      this.listeners_ = {};
      assert(Array.isArray(allowedEvents_) && allowedEvents_.length > 0, "Requires a non-empty array");
    }
    EventEmitter2.prototype.trigger = function(eventType) {
      var varArgs = [];
      for (var _i = 1; _i < arguments.length; _i++) {
        varArgs[_i - 1] = arguments[_i];
      }
      if (Array.isArray(this.listeners_[eventType])) {
        var listeners = __spreadArray([], __read(this.listeners_[eventType]));
        for (var i = 0; i < listeners.length; i++) {
          listeners[i].callback.apply(listeners[i].context, varArgs);
        }
      }
    };
    EventEmitter2.prototype.on = function(eventType, callback, context) {
      this.validateEventType_(eventType);
      this.listeners_[eventType] = this.listeners_[eventType] || [];
      this.listeners_[eventType].push({ callback, context });
      var eventData = this.getInitialEvent(eventType);
      if (eventData) {
        callback.apply(context, eventData);
      }
    };
    EventEmitter2.prototype.off = function(eventType, callback, context) {
      this.validateEventType_(eventType);
      var listeners = this.listeners_[eventType] || [];
      for (var i = 0; i < listeners.length; i++) {
        if (listeners[i].callback === callback && (!context || context === listeners[i].context)) {
          listeners.splice(i, 1);
          return;
        }
      }
    };
    EventEmitter2.prototype.validateEventType_ = function(eventType) {
      assert(this.allowedEvents_.find(function(et) {
        return et === eventType;
      }), "Unknown event: " + eventType);
    };
    return EventEmitter2;
  }()
);
var OnlineMonitor = (
  /** @class */
  function(_super) {
    __extends(OnlineMonitor2, _super);
    function OnlineMonitor2() {
      var _this = _super.call(this, ["online"]) || this;
      _this.online_ = true;
      if (typeof window !== "undefined" && typeof window.addEventListener !== "undefined" && !isMobileCordova()) {
        window.addEventListener("online", function() {
          if (!_this.online_) {
            _this.online_ = true;
            _this.trigger("online", true);
          }
        }, false);
        window.addEventListener("offline", function() {
          if (_this.online_) {
            _this.online_ = false;
            _this.trigger("online", false);
          }
        }, false);
      }
      return _this;
    }
    OnlineMonitor2.getInstance = function() {
      return new OnlineMonitor2();
    };
    OnlineMonitor2.prototype.getInitialEvent = function(eventType) {
      assert(eventType === "online", "Unknown event type: " + eventType);
      return [this.online_];
    };
    OnlineMonitor2.prototype.currentlyOnline = function() {
      return this.online_;
    };
    return OnlineMonitor2;
  }(EventEmitter)
);
var MAX_PATH_DEPTH = 32;
var MAX_PATH_LENGTH_BYTES = 768;
var Path = (
  /** @class */
  function() {
    function Path2(pathOrString, pieceNum) {
      if (pieceNum === void 0) {
        this.pieces_ = pathOrString.split("/");
        var copyTo = 0;
        for (var i = 0; i < this.pieces_.length; i++) {
          if (this.pieces_[i].length > 0) {
            this.pieces_[copyTo] = this.pieces_[i];
            copyTo++;
          }
        }
        this.pieces_.length = copyTo;
        this.pieceNum_ = 0;
      } else {
        this.pieces_ = pathOrString;
        this.pieceNum_ = pieceNum;
      }
    }
    Path2.prototype.toString = function() {
      var pathString = "";
      for (var i = this.pieceNum_; i < this.pieces_.length; i++) {
        if (this.pieces_[i] !== "") {
          pathString += "/" + this.pieces_[i];
        }
      }
      return pathString || "/";
    };
    return Path2;
  }()
);
function newEmptyPath() {
  return new Path("");
}
function pathGetFront(path) {
  if (path.pieceNum_ >= path.pieces_.length) {
    return null;
  }
  return path.pieces_[path.pieceNum_];
}
function pathGetLength(path) {
  return path.pieces_.length - path.pieceNum_;
}
function pathPopFront(path) {
  var pieceNum = path.pieceNum_;
  if (pieceNum < path.pieces_.length) {
    pieceNum++;
  }
  return new Path(path.pieces_, pieceNum);
}
function pathGetBack(path) {
  if (path.pieceNum_ < path.pieces_.length) {
    return path.pieces_[path.pieces_.length - 1];
  }
  return null;
}
function pathToUrlEncodedString(path) {
  var pathString = "";
  for (var i = path.pieceNum_; i < path.pieces_.length; i++) {
    if (path.pieces_[i] !== "") {
      pathString += "/" + encodeURIComponent(String(path.pieces_[i]));
    }
  }
  return pathString || "/";
}
function pathSlice(path, begin) {
  if (begin === void 0) {
    begin = 0;
  }
  return path.pieces_.slice(path.pieceNum_ + begin);
}
function pathParent(path) {
  if (path.pieceNum_ >= path.pieces_.length) {
    return null;
  }
  var pieces = [];
  for (var i = path.pieceNum_; i < path.pieces_.length - 1; i++) {
    pieces.push(path.pieces_[i]);
  }
  return new Path(pieces, 0);
}
function pathChild(path, childPathObj) {
  var pieces = [];
  for (var i = path.pieceNum_; i < path.pieces_.length; i++) {
    pieces.push(path.pieces_[i]);
  }
  if (childPathObj instanceof Path) {
    for (var i = childPathObj.pieceNum_; i < childPathObj.pieces_.length; i++) {
      pieces.push(childPathObj.pieces_[i]);
    }
  } else {
    var childPieces = childPathObj.split("/");
    for (var i = 0; i < childPieces.length; i++) {
      if (childPieces[i].length > 0) {
        pieces.push(childPieces[i]);
      }
    }
  }
  return new Path(pieces, 0);
}
function pathIsEmpty(path) {
  return path.pieceNum_ >= path.pieces_.length;
}
function newRelativePath(outerPath, innerPath) {
  var outer = pathGetFront(outerPath), inner = pathGetFront(innerPath);
  if (outer === null) {
    return innerPath;
  } else if (outer === inner) {
    return newRelativePath(pathPopFront(outerPath), pathPopFront(innerPath));
  } else {
    throw new Error("INTERNAL ERROR: innerPath (" + innerPath + ") is not within outerPath (" + outerPath + ")");
  }
}
function pathCompare(left, right) {
  var leftKeys = pathSlice(left, 0);
  var rightKeys = pathSlice(right, 0);
  for (var i = 0; i < leftKeys.length && i < rightKeys.length; i++) {
    var cmp = nameCompare(leftKeys[i], rightKeys[i]);
    if (cmp !== 0) {
      return cmp;
    }
  }
  if (leftKeys.length === rightKeys.length) {
    return 0;
  }
  return leftKeys.length < rightKeys.length ? -1 : 1;
}
function pathEquals(path, other) {
  if (pathGetLength(path) !== pathGetLength(other)) {
    return false;
  }
  for (var i = path.pieceNum_, j = other.pieceNum_; i <= path.pieces_.length; i++, j++) {
    if (path.pieces_[i] !== other.pieces_[j]) {
      return false;
    }
  }
  return true;
}
function pathContains(path, other) {
  var i = path.pieceNum_;
  var j = other.pieceNum_;
  if (pathGetLength(path) > pathGetLength(other)) {
    return false;
  }
  while (i < path.pieces_.length) {
    if (path.pieces_[i] !== other.pieces_[j]) {
      return false;
    }
    ++i;
    ++j;
  }
  return true;
}
var ValidationPath = (
  /** @class */
  /* @__PURE__ */ function() {
    function ValidationPath2(path, errorPrefix_) {
      this.errorPrefix_ = errorPrefix_;
      this.parts_ = pathSlice(path, 0);
      this.byteLength_ = Math.max(1, this.parts_.length);
      for (var i = 0; i < this.parts_.length; i++) {
        this.byteLength_ += stringLength(this.parts_[i]);
      }
      validationPathCheckValid(this);
    }
    return ValidationPath2;
  }()
);
function validationPathPush(validationPath, child3) {
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ += 1;
  }
  validationPath.parts_.push(child3);
  validationPath.byteLength_ += stringLength(child3);
  validationPathCheckValid(validationPath);
}
function validationPathPop(validationPath) {
  var last = validationPath.parts_.pop();
  validationPath.byteLength_ -= stringLength(last);
  if (validationPath.parts_.length > 0) {
    validationPath.byteLength_ -= 1;
  }
}
function validationPathCheckValid(validationPath) {
  if (validationPath.byteLength_ > MAX_PATH_LENGTH_BYTES) {
    throw new Error(validationPath.errorPrefix_ + "has a key path longer than " + MAX_PATH_LENGTH_BYTES + " bytes (" + validationPath.byteLength_ + ").");
  }
  if (validationPath.parts_.length > MAX_PATH_DEPTH) {
    throw new Error(validationPath.errorPrefix_ + "path specified exceeds the maximum depth that can be written (" + MAX_PATH_DEPTH + ") or object contains a cycle " + validationPathToErrorString(validationPath));
  }
}
function validationPathToErrorString(validationPath) {
  if (validationPath.parts_.length === 0) {
    return "";
  }
  return "in property '" + validationPath.parts_.join(".") + "'";
}
var VisibilityMonitor = (
  /** @class */
  function(_super) {
    __extends(VisibilityMonitor2, _super);
    function VisibilityMonitor2() {
      var _this = _super.call(this, ["visible"]) || this;
      var hidden;
      var visibilityChange;
      if (typeof document !== "undefined" && typeof document.addEventListener !== "undefined") {
        if (typeof document["hidden"] !== "undefined") {
          visibilityChange = "visibilitychange";
          hidden = "hidden";
        } else if (typeof document["mozHidden"] !== "undefined") {
          visibilityChange = "mozvisibilitychange";
          hidden = "mozHidden";
        } else if (typeof document["msHidden"] !== "undefined") {
          visibilityChange = "msvisibilitychange";
          hidden = "msHidden";
        } else if (typeof document["webkitHidden"] !== "undefined") {
          visibilityChange = "webkitvisibilitychange";
          hidden = "webkitHidden";
        }
      }
      _this.visible_ = true;
      if (visibilityChange) {
        document.addEventListener(visibilityChange, function() {
          var visible = !document[hidden];
          if (visible !== _this.visible_) {
            _this.visible_ = visible;
            _this.trigger("visible", visible);
          }
        }, false);
      }
      return _this;
    }
    VisibilityMonitor2.getInstance = function() {
      return new VisibilityMonitor2();
    };
    VisibilityMonitor2.prototype.getInitialEvent = function(eventType) {
      assert(eventType === "visible", "Unknown event type: " + eventType);
      return [this.visible_];
    };
    return VisibilityMonitor2;
  }(EventEmitter)
);
var RECONNECT_MIN_DELAY = 1e3;
var RECONNECT_MAX_DELAY_DEFAULT = 60 * 5 * 1e3;
var GET_CONNECT_TIMEOUT = 3 * 1e3;
var RECONNECT_MAX_DELAY_FOR_ADMINS = 30 * 1e3;
var RECONNECT_DELAY_MULTIPLIER = 1.3;
var RECONNECT_DELAY_RESET_TIMEOUT = 3e4;
var SERVER_KILL_INTERRUPT_REASON = "server_kill";
var INVALID_TOKEN_THRESHOLD = 3;
var PersistentConnection = (
  /** @class */
  function(_super) {
    __extends(PersistentConnection2, _super);
    function PersistentConnection2(repoInfo_, applicationId_, onDataUpdate_, onConnectStatus_, onServerInfoUpdate_, authTokenProvider_, appCheckTokenProvider_, authOverride_) {
      var _this = _super.call(this) || this;
      _this.repoInfo_ = repoInfo_;
      _this.applicationId_ = applicationId_;
      _this.onDataUpdate_ = onDataUpdate_;
      _this.onConnectStatus_ = onConnectStatus_;
      _this.onServerInfoUpdate_ = onServerInfoUpdate_;
      _this.authTokenProvider_ = authTokenProvider_;
      _this.appCheckTokenProvider_ = appCheckTokenProvider_;
      _this.authOverride_ = authOverride_;
      _this.id = PersistentConnection2.nextPersistentConnectionId_++;
      _this.log_ = logWrapper("p:" + _this.id + ":");
      _this.interruptReasons_ = {};
      _this.listens = /* @__PURE__ */ new Map();
      _this.outstandingPuts_ = [];
      _this.outstandingGets_ = [];
      _this.outstandingPutCount_ = 0;
      _this.outstandingGetCount_ = 0;
      _this.onDisconnectRequestQueue_ = [];
      _this.connected_ = false;
      _this.reconnectDelay_ = RECONNECT_MIN_DELAY;
      _this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_DEFAULT;
      _this.securityDebugCallback_ = null;
      _this.lastSessionId = null;
      _this.establishConnectionTimer_ = null;
      _this.visible_ = false;
      _this.requestCBHash_ = {};
      _this.requestNumber_ = 0;
      _this.realtime_ = null;
      _this.authToken_ = null;
      _this.appCheckToken_ = null;
      _this.forceTokenRefresh_ = false;
      _this.invalidAuthTokenCount_ = 0;
      _this.invalidAppCheckTokenCount_ = 0;
      _this.firstConnection_ = true;
      _this.lastConnectionAttemptTime_ = null;
      _this.lastConnectionEstablishedTime_ = null;
      if (authOverride_ && !isNodeSdk()) {
        throw new Error("Auth override specified in options, but not supported on non Node.js platforms");
      }
      VisibilityMonitor.getInstance().on("visible", _this.onVisible_, _this);
      if (repoInfo_.host.indexOf("fblocal") === -1) {
        OnlineMonitor.getInstance().on("online", _this.onOnline_, _this);
      }
      return _this;
    }
    PersistentConnection2.prototype.sendRequest = function(action, body, onResponse) {
      var curReqNum = ++this.requestNumber_;
      var msg = { r: curReqNum, a: action, b: body };
      this.log_(stringify(msg));
      assert(this.connected_, "sendRequest call when we're not connected not allowed.");
      this.realtime_.sendRequest(msg);
      if (onResponse) {
        this.requestCBHash_[curReqNum] = onResponse;
      }
    };
    PersistentConnection2.prototype.get = function(query2) {
      var _this = this;
      this.initConnection_();
      var deferred = new Deferred();
      var request = {
        p: query2._path.toString(),
        q: query2._queryObject
      };
      var outstandingGet = {
        action: "g",
        request,
        onComplete: function(message) {
          var payload = message["d"];
          if (message["s"] === "ok") {
            _this.onDataUpdate_(
              request["p"],
              payload,
              /*isMerge*/
              false,
              /*tag*/
              null
            );
            deferred.resolve(payload);
          } else {
            deferred.reject(payload);
          }
        }
      };
      this.outstandingGets_.push(outstandingGet);
      this.outstandingGetCount_++;
      var index = this.outstandingGets_.length - 1;
      if (!this.connected_) {
        setTimeout(function() {
          var get2 = _this.outstandingGets_[index];
          if (get2 === void 0 || outstandingGet !== get2) {
            return;
          }
          delete _this.outstandingGets_[index];
          _this.outstandingGetCount_--;
          if (_this.outstandingGetCount_ === 0) {
            _this.outstandingGets_ = [];
          }
          _this.log_("get " + index + " timed out on connection");
          deferred.reject(new Error("Client is offline."));
        }, GET_CONNECT_TIMEOUT);
      }
      if (this.connected_) {
        this.sendGet_(index);
      }
      return deferred.promise;
    };
    PersistentConnection2.prototype.listen = function(query2, currentHashFn, tag, onComplete) {
      this.initConnection_();
      var queryId = query2._queryIdentifier;
      var pathString = query2._path.toString();
      this.log_("Listen called for " + pathString + " " + queryId);
      if (!this.listens.has(pathString)) {
        this.listens.set(pathString, /* @__PURE__ */ new Map());
      }
      assert(query2._queryParams.isDefault() || !query2._queryParams.loadsAllData(), "listen() called for non-default but complete query");
      assert(!this.listens.get(pathString).has(queryId), "listen() called twice for same path/queryId.");
      var listenSpec = {
        onComplete,
        hashFn: currentHashFn,
        query: query2,
        tag
      };
      this.listens.get(pathString).set(queryId, listenSpec);
      if (this.connected_) {
        this.sendListen_(listenSpec);
      }
    };
    PersistentConnection2.prototype.sendGet_ = function(index) {
      var _this = this;
      var get2 = this.outstandingGets_[index];
      this.sendRequest("g", get2.request, function(message) {
        delete _this.outstandingGets_[index];
        _this.outstandingGetCount_--;
        if (_this.outstandingGetCount_ === 0) {
          _this.outstandingGets_ = [];
        }
        if (get2.onComplete) {
          get2.onComplete(message);
        }
      });
    };
    PersistentConnection2.prototype.sendListen_ = function(listenSpec) {
      var _this = this;
      var query2 = listenSpec.query;
      var pathString = query2._path.toString();
      var queryId = query2._queryIdentifier;
      this.log_("Listen on " + pathString + " for " + queryId);
      var req = {
        /*path*/
        p: pathString
      };
      var action = "q";
      if (listenSpec.tag) {
        req["q"] = query2._queryObject;
        req["t"] = listenSpec.tag;
      }
      req[
        /*hash*/
        "h"
      ] = listenSpec.hashFn();
      this.sendRequest(action, req, function(message) {
        var payload = message[
          /*data*/
          "d"
        ];
        var status = message[
          /*status*/
          "s"
        ];
        PersistentConnection2.warnOnListenWarnings_(payload, query2);
        var currentListenSpec = _this.listens.get(pathString) && _this.listens.get(pathString).get(queryId);
        if (currentListenSpec === listenSpec) {
          _this.log_("listen response", message);
          if (status !== "ok") {
            _this.removeListen_(pathString, queryId);
          }
          if (listenSpec.onComplete) {
            listenSpec.onComplete(status, payload);
          }
        }
      });
    };
    PersistentConnection2.warnOnListenWarnings_ = function(payload, query2) {
      if (payload && typeof payload === "object" && contains(payload, "w")) {
        var warnings = safeGet(payload, "w");
        if (Array.isArray(warnings) && ~warnings.indexOf("no_index")) {
          var indexSpec = '".indexOn": "' + query2._queryParams.getIndex().toString() + '"';
          var indexPath = query2._path.toString();
          warn("Using an unspecified index. Your data will be downloaded and " + ("filtered on the client. Consider adding " + indexSpec + " at ") + (indexPath + " to your security rules for better performance."));
        }
      }
    };
    PersistentConnection2.prototype.refreshAuthToken = function(token) {
      this.authToken_ = token;
      this.log_("Auth token refreshed");
      if (this.authToken_) {
        this.tryAuth();
      } else {
        if (this.connected_) {
          this.sendRequest("unauth", {}, function() {
          });
        }
      }
      this.reduceReconnectDelayIfAdminCredential_(token);
    };
    PersistentConnection2.prototype.reduceReconnectDelayIfAdminCredential_ = function(credential) {
      var isFirebaseSecret = credential && credential.length === 40;
      if (isFirebaseSecret || isAdmin(credential)) {
        this.log_("Admin auth credential detected.  Reducing max reconnect time.");
        this.maxReconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
      }
    };
    PersistentConnection2.prototype.refreshAppCheckToken = function(token) {
      this.appCheckToken_ = token;
      this.log_("App check token refreshed");
      if (this.appCheckToken_) {
        this.tryAppCheck();
      } else {
        if (this.connected_) {
          this.sendRequest("unappeck", {}, function() {
          });
        }
      }
    };
    PersistentConnection2.prototype.tryAuth = function() {
      var _this = this;
      if (this.connected_ && this.authToken_) {
        var token_1 = this.authToken_;
        var authMethod = isValidFormat(token_1) ? "auth" : "gauth";
        var requestData = { cred: token_1 };
        if (this.authOverride_ === null) {
          requestData["noauth"] = true;
        } else if (typeof this.authOverride_ === "object") {
          requestData["authvar"] = this.authOverride_;
        }
        this.sendRequest(authMethod, requestData, function(res) {
          var status = res[
            /*status*/
            "s"
          ];
          var data = res[
            /*data*/
            "d"
          ] || "error";
          if (_this.authToken_ === token_1) {
            if (status === "ok") {
              _this.invalidAuthTokenCount_ = 0;
            } else {
              _this.onAuthRevoked_(status, data);
            }
          }
        });
      }
    };
    PersistentConnection2.prototype.tryAppCheck = function() {
      var _this = this;
      if (this.connected_ && this.appCheckToken_) {
        this.sendRequest("appcheck", { "token": this.appCheckToken_ }, function(res) {
          var status = res[
            /*status*/
            "s"
          ];
          var data = res[
            /*data*/
            "d"
          ] || "error";
          if (status === "ok") {
            _this.invalidAppCheckTokenCount_ = 0;
          } else {
            _this.onAppCheckRevoked_(status, data);
          }
        });
      }
    };
    PersistentConnection2.prototype.unlisten = function(query2, tag) {
      var pathString = query2._path.toString();
      var queryId = query2._queryIdentifier;
      this.log_("Unlisten called for " + pathString + " " + queryId);
      assert(query2._queryParams.isDefault() || !query2._queryParams.loadsAllData(), "unlisten() called for non-default but complete query");
      var listen = this.removeListen_(pathString, queryId);
      if (listen && this.connected_) {
        this.sendUnlisten_(pathString, queryId, query2._queryObject, tag);
      }
    };
    PersistentConnection2.prototype.sendUnlisten_ = function(pathString, queryId, queryObj, tag) {
      this.log_("Unlisten on " + pathString + " for " + queryId);
      var req = {
        /*path*/
        p: pathString
      };
      var action = "n";
      if (tag) {
        req["q"] = queryObj;
        req["t"] = tag;
      }
      this.sendRequest(action, req);
    };
    PersistentConnection2.prototype.onDisconnectPut = function(pathString, data, onComplete) {
      this.initConnection_();
      if (this.connected_) {
        this.sendOnDisconnect_("o", pathString, data, onComplete);
      } else {
        this.onDisconnectRequestQueue_.push({
          pathString,
          action: "o",
          data,
          onComplete
        });
      }
    };
    PersistentConnection2.prototype.onDisconnectMerge = function(pathString, data, onComplete) {
      this.initConnection_();
      if (this.connected_) {
        this.sendOnDisconnect_("om", pathString, data, onComplete);
      } else {
        this.onDisconnectRequestQueue_.push({
          pathString,
          action: "om",
          data,
          onComplete
        });
      }
    };
    PersistentConnection2.prototype.onDisconnectCancel = function(pathString, onComplete) {
      this.initConnection_();
      if (this.connected_) {
        this.sendOnDisconnect_("oc", pathString, null, onComplete);
      } else {
        this.onDisconnectRequestQueue_.push({
          pathString,
          action: "oc",
          data: null,
          onComplete
        });
      }
    };
    PersistentConnection2.prototype.sendOnDisconnect_ = function(action, pathString, data, onComplete) {
      var request = {
        /*path*/
        p: pathString,
        /*data*/
        d: data
      };
      this.log_("onDisconnect " + action, request);
      this.sendRequest(action, request, function(response) {
        if (onComplete) {
          setTimeout(function() {
            onComplete(response[
              /*status*/
              "s"
            ], response[
              /* data */
              "d"
            ]);
          }, Math.floor(0));
        }
      });
    };
    PersistentConnection2.prototype.put = function(pathString, data, onComplete, hash) {
      this.putInternal("p", pathString, data, onComplete, hash);
    };
    PersistentConnection2.prototype.merge = function(pathString, data, onComplete, hash) {
      this.putInternal("m", pathString, data, onComplete, hash);
    };
    PersistentConnection2.prototype.putInternal = function(action, pathString, data, onComplete, hash) {
      this.initConnection_();
      var request = {
        /*path*/
        p: pathString,
        /*data*/
        d: data
      };
      if (hash !== void 0) {
        request[
          /*hash*/
          "h"
        ] = hash;
      }
      this.outstandingPuts_.push({
        action,
        request,
        onComplete
      });
      this.outstandingPutCount_++;
      var index = this.outstandingPuts_.length - 1;
      if (this.connected_) {
        this.sendPut_(index);
      } else {
        this.log_("Buffering put: " + pathString);
      }
    };
    PersistentConnection2.prototype.sendPut_ = function(index) {
      var _this = this;
      var action = this.outstandingPuts_[index].action;
      var request = this.outstandingPuts_[index].request;
      var onComplete = this.outstandingPuts_[index].onComplete;
      this.outstandingPuts_[index].queued = this.connected_;
      this.sendRequest(action, request, function(message) {
        _this.log_(action + " response", message);
        delete _this.outstandingPuts_[index];
        _this.outstandingPutCount_--;
        if (_this.outstandingPutCount_ === 0) {
          _this.outstandingPuts_ = [];
        }
        if (onComplete) {
          onComplete(message[
            /*status*/
            "s"
          ], message[
            /* data */
            "d"
          ]);
        }
      });
    };
    PersistentConnection2.prototype.reportStats = function(stats2) {
      var _this = this;
      if (this.connected_) {
        var request = {
          /*counters*/
          c: stats2
        };
        this.log_("reportStats", request);
        this.sendRequest(
          /*stats*/
          "s",
          request,
          function(result) {
            var status = result[
              /*status*/
              "s"
            ];
            if (status !== "ok") {
              var errorReason = result[
                /* data */
                "d"
              ];
              _this.log_("reportStats", "Error sending stats: " + errorReason);
            }
          }
        );
      }
    };
    PersistentConnection2.prototype.onDataMessage_ = function(message) {
      if ("r" in message) {
        this.log_("from server: " + stringify(message));
        var reqNum = message["r"];
        var onResponse = this.requestCBHash_[reqNum];
        if (onResponse) {
          delete this.requestCBHash_[reqNum];
          onResponse(message[
            /*body*/
            "b"
          ]);
        }
      } else if ("error" in message) {
        throw "A server-side error has occurred: " + message["error"];
      } else if ("a" in message) {
        this.onDataPush_(message["a"], message["b"]);
      }
    };
    PersistentConnection2.prototype.onDataPush_ = function(action, body) {
      this.log_("handleServerMessage", action, body);
      if (action === "d") {
        this.onDataUpdate_(
          body[
            /*path*/
            "p"
          ],
          body[
            /*data*/
            "d"
          ],
          /*isMerge*/
          false,
          body["t"]
        );
      } else if (action === "m") {
        this.onDataUpdate_(
          body[
            /*path*/
            "p"
          ],
          body[
            /*data*/
            "d"
          ],
          /*isMerge=*/
          true,
          body["t"]
        );
      } else if (action === "c") {
        this.onListenRevoked_(body[
          /*path*/
          "p"
        ], body[
          /*query*/
          "q"
        ]);
      } else if (action === "ac") {
        this.onAuthRevoked_(body[
          /*status code*/
          "s"
        ], body[
          /* explanation */
          "d"
        ]);
      } else if (action === "apc") {
        this.onAppCheckRevoked_(body[
          /*status code*/
          "s"
        ], body[
          /* explanation */
          "d"
        ]);
      } else if (action === "sd") {
        this.onSecurityDebugPacket_(body);
      } else {
        error("Unrecognized action received from server: " + stringify(action) + "\nAre you using the latest client?");
      }
    };
    PersistentConnection2.prototype.onReady_ = function(timestamp, sessionId) {
      this.log_("connection ready");
      this.connected_ = true;
      this.lastConnectionEstablishedTime_ = (/* @__PURE__ */ new Date()).getTime();
      this.handleTimestamp_(timestamp);
      this.lastSessionId = sessionId;
      if (this.firstConnection_) {
        this.sendConnectStats_();
      }
      this.restoreState_();
      this.firstConnection_ = false;
      this.onConnectStatus_(true);
    };
    PersistentConnection2.prototype.scheduleConnect_ = function(timeout) {
      var _this = this;
      assert(!this.realtime_, "Scheduling a connect when we're already connected/ing?");
      if (this.establishConnectionTimer_) {
        clearTimeout(this.establishConnectionTimer_);
      }
      this.establishConnectionTimer_ = setTimeout(function() {
        _this.establishConnectionTimer_ = null;
        _this.establishConnection_();
      }, Math.floor(timeout));
    };
    PersistentConnection2.prototype.initConnection_ = function() {
      if (!this.realtime_ && this.firstConnection_) {
        this.scheduleConnect_(0);
      }
    };
    PersistentConnection2.prototype.onVisible_ = function(visible) {
      if (visible && !this.visible_ && this.reconnectDelay_ === this.maxReconnectDelay_) {
        this.log_("Window became visible.  Reducing delay.");
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        if (!this.realtime_) {
          this.scheduleConnect_(0);
        }
      }
      this.visible_ = visible;
    };
    PersistentConnection2.prototype.onOnline_ = function(online) {
      if (online) {
        this.log_("Browser went online.");
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        if (!this.realtime_) {
          this.scheduleConnect_(0);
        }
      } else {
        this.log_("Browser went offline.  Killing connection.");
        if (this.realtime_) {
          this.realtime_.close();
        }
      }
    };
    PersistentConnection2.prototype.onRealtimeDisconnect_ = function() {
      this.log_("data client disconnected");
      this.connected_ = false;
      this.realtime_ = null;
      this.cancelSentTransactions_();
      this.requestCBHash_ = {};
      if (this.shouldReconnect_()) {
        if (!this.visible_) {
          this.log_("Window isn't visible.  Delaying reconnect.");
          this.reconnectDelay_ = this.maxReconnectDelay_;
          this.lastConnectionAttemptTime_ = (/* @__PURE__ */ new Date()).getTime();
        } else if (this.lastConnectionEstablishedTime_) {
          var timeSinceLastConnectSucceeded = (/* @__PURE__ */ new Date()).getTime() - this.lastConnectionEstablishedTime_;
          if (timeSinceLastConnectSucceeded > RECONNECT_DELAY_RESET_TIMEOUT) {
            this.reconnectDelay_ = RECONNECT_MIN_DELAY;
          }
          this.lastConnectionEstablishedTime_ = null;
        }
        var timeSinceLastConnectAttempt = (/* @__PURE__ */ new Date()).getTime() - this.lastConnectionAttemptTime_;
        var reconnectDelay = Math.max(0, this.reconnectDelay_ - timeSinceLastConnectAttempt);
        reconnectDelay = Math.random() * reconnectDelay;
        this.log_("Trying to reconnect in " + reconnectDelay + "ms");
        this.scheduleConnect_(reconnectDelay);
        this.reconnectDelay_ = Math.min(this.maxReconnectDelay_, this.reconnectDelay_ * RECONNECT_DELAY_MULTIPLIER);
      }
      this.onConnectStatus_(false);
    };
    PersistentConnection2.prototype.establishConnection_ = function() {
      return __awaiter(this, void 0, void 0, function() {
        var onDataMessage, onReady, onDisconnect_1, connId, lastSessionId, canceled_1, connection_1, closeFn, sendRequestFn, forceRefresh, _a7, authToken, appCheckToken, error_1;
        var _this = this;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              if (!this.shouldReconnect_()) return [3, 4];
              this.log_("Making a connection attempt");
              this.lastConnectionAttemptTime_ = (/* @__PURE__ */ new Date()).getTime();
              this.lastConnectionEstablishedTime_ = null;
              onDataMessage = this.onDataMessage_.bind(this);
              onReady = this.onReady_.bind(this);
              onDisconnect_1 = this.onRealtimeDisconnect_.bind(this);
              connId = this.id + ":" + PersistentConnection2.nextConnectionId_++;
              lastSessionId = this.lastSessionId;
              canceled_1 = false;
              connection_1 = null;
              closeFn = function() {
                if (connection_1) {
                  connection_1.close();
                } else {
                  canceled_1 = true;
                  onDisconnect_1();
                }
              };
              sendRequestFn = function(msg) {
                assert(connection_1, "sendRequest call when we're not connected not allowed.");
                connection_1.sendRequest(msg);
              };
              this.realtime_ = {
                close: closeFn,
                sendRequest: sendRequestFn
              };
              forceRefresh = this.forceTokenRefresh_;
              this.forceTokenRefresh_ = false;
              _b.label = 1;
            case 1:
              _b.trys.push([1, 3, , 4]);
              return [4, Promise.all([
                this.authTokenProvider_.getToken(forceRefresh),
                this.appCheckTokenProvider_.getToken(forceRefresh)
              ])];
            case 2:
              _a7 = __read.apply(void 0, [_b.sent(), 2]), authToken = _a7[0], appCheckToken = _a7[1];
              if (!canceled_1) {
                log("getToken() completed. Creating connection.");
                this.authToken_ = authToken && authToken.accessToken;
                this.appCheckToken_ = appCheckToken && appCheckToken.token;
                connection_1 = new Connection(
                  connId,
                  this.repoInfo_,
                  this.applicationId_,
                  this.appCheckToken_,
                  this.authToken_,
                  onDataMessage,
                  onReady,
                  onDisconnect_1,
                  /* onKill= */
                  function(reason) {
                    warn(reason + " (" + _this.repoInfo_.toString() + ")");
                    _this.interrupt(SERVER_KILL_INTERRUPT_REASON);
                  },
                  lastSessionId
                );
              } else {
                log("getToken() completed but was canceled");
              }
              return [3, 4];
            case 3:
              error_1 = _b.sent();
              this.log_("Failed to get token: " + error_1);
              if (!canceled_1) {
                if (this.repoInfo_.nodeAdmin) {
                  warn(error_1);
                }
                closeFn();
              }
              return [3, 4];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    PersistentConnection2.prototype.interrupt = function(reason) {
      log("Interrupting connection for reason: " + reason);
      this.interruptReasons_[reason] = true;
      if (this.realtime_) {
        this.realtime_.close();
      } else {
        if (this.establishConnectionTimer_) {
          clearTimeout(this.establishConnectionTimer_);
          this.establishConnectionTimer_ = null;
        }
        if (this.connected_) {
          this.onRealtimeDisconnect_();
        }
      }
    };
    PersistentConnection2.prototype.resume = function(reason) {
      log("Resuming connection for reason: " + reason);
      delete this.interruptReasons_[reason];
      if (isEmpty(this.interruptReasons_)) {
        this.reconnectDelay_ = RECONNECT_MIN_DELAY;
        if (!this.realtime_) {
          this.scheduleConnect_(0);
        }
      }
    };
    PersistentConnection2.prototype.handleTimestamp_ = function(timestamp) {
      var delta = timestamp - (/* @__PURE__ */ new Date()).getTime();
      this.onServerInfoUpdate_({ serverTimeOffset: delta });
    };
    PersistentConnection2.prototype.cancelSentTransactions_ = function() {
      for (var i = 0; i < this.outstandingPuts_.length; i++) {
        var put = this.outstandingPuts_[i];
        if (put && /*hash*/
        "h" in put.request && put.queued) {
          if (put.onComplete) {
            put.onComplete("disconnect");
          }
          delete this.outstandingPuts_[i];
          this.outstandingPutCount_--;
        }
      }
      if (this.outstandingPutCount_ === 0) {
        this.outstandingPuts_ = [];
      }
    };
    PersistentConnection2.prototype.onListenRevoked_ = function(pathString, query2) {
      var queryId;
      if (!query2) {
        queryId = "default";
      } else {
        queryId = query2.map(function(q) {
          return ObjectToUniqueKey(q);
        }).join("$");
      }
      var listen = this.removeListen_(pathString, queryId);
      if (listen && listen.onComplete) {
        listen.onComplete("permission_denied");
      }
    };
    PersistentConnection2.prototype.removeListen_ = function(pathString, queryId) {
      var normalizedPathString = new Path(pathString).toString();
      var listen;
      if (this.listens.has(normalizedPathString)) {
        var map2 = this.listens.get(normalizedPathString);
        listen = map2.get(queryId);
        map2.delete(queryId);
        if (map2.size === 0) {
          this.listens.delete(normalizedPathString);
        }
      } else {
        listen = void 0;
      }
      return listen;
    };
    PersistentConnection2.prototype.onAuthRevoked_ = function(statusCode, explanation) {
      log("Auth token revoked: " + statusCode + "/" + explanation);
      this.authToken_ = null;
      this.forceTokenRefresh_ = true;
      this.realtime_.close();
      if (statusCode === "invalid_token" || statusCode === "permission_denied") {
        this.invalidAuthTokenCount_++;
        if (this.invalidAuthTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
          this.reconnectDelay_ = RECONNECT_MAX_DELAY_FOR_ADMINS;
          this.authTokenProvider_.notifyForInvalidToken();
        }
      }
    };
    PersistentConnection2.prototype.onAppCheckRevoked_ = function(statusCode, explanation) {
      log("App check token revoked: " + statusCode + "/" + explanation);
      this.appCheckToken_ = null;
      this.forceTokenRefresh_ = true;
      if (statusCode === "invalid_token" || statusCode === "permission_denied") {
        this.invalidAppCheckTokenCount_++;
        if (this.invalidAppCheckTokenCount_ >= INVALID_TOKEN_THRESHOLD) {
          this.appCheckTokenProvider_.notifyForInvalidToken();
        }
      }
    };
    PersistentConnection2.prototype.onSecurityDebugPacket_ = function(body) {
      if (this.securityDebugCallback_) {
        this.securityDebugCallback_(body);
      } else {
        if ("msg" in body) {
          console.log("FIREBASE: " + body["msg"].replace("\n", "\nFIREBASE: "));
        }
      }
    };
    PersistentConnection2.prototype.restoreState_ = function() {
      var e_1, _a7, e_2, _b;
      this.tryAuth();
      this.tryAppCheck();
      try {
        for (var _c = __values(this.listens.values()), _d = _c.next(); !_d.done; _d = _c.next()) {
          var queries = _d.value;
          try {
            for (var _e = (e_2 = void 0, __values(queries.values())), _f = _e.next(); !_f.done; _f = _e.next()) {
              var listenSpec = _f.value;
              this.sendListen_(listenSpec);
            }
          } catch (e_2_1) {
            e_2 = { error: e_2_1 };
          } finally {
            try {
              if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
            } finally {
              if (e_2) throw e_2.error;
            }
          }
        }
      } catch (e_1_1) {
        e_1 = { error: e_1_1 };
      } finally {
        try {
          if (_d && !_d.done && (_a7 = _c.return)) _a7.call(_c);
        } finally {
          if (e_1) throw e_1.error;
        }
      }
      for (var i = 0; i < this.outstandingPuts_.length; i++) {
        if (this.outstandingPuts_[i]) {
          this.sendPut_(i);
        }
      }
      while (this.onDisconnectRequestQueue_.length) {
        var request = this.onDisconnectRequestQueue_.shift();
        this.sendOnDisconnect_(request.action, request.pathString, request.data, request.onComplete);
      }
      for (var i = 0; i < this.outstandingGets_.length; i++) {
        if (this.outstandingGets_[i]) {
          this.sendGet_(i);
        }
      }
    };
    PersistentConnection2.prototype.sendConnectStats_ = function() {
      var stats2 = {};
      var clientName = "js";
      if (isNodeSdk()) {
        if (this.repoInfo_.nodeAdmin) {
          clientName = "admin_node";
        } else {
          clientName = "node";
        }
      }
      stats2["sdk." + clientName + "." + SDK_VERSION.replace(/\./g, "-")] = 1;
      if (isMobileCordova()) {
        stats2["framework.cordova"] = 1;
      } else if (isReactNative()) {
        stats2["framework.reactnative"] = 1;
      }
      this.reportStats(stats2);
    };
    PersistentConnection2.prototype.shouldReconnect_ = function() {
      var online = OnlineMonitor.getInstance().currentlyOnline();
      return isEmpty(this.interruptReasons_) && online;
    };
    PersistentConnection2.nextPersistentConnectionId_ = 0;
    PersistentConnection2.nextConnectionId_ = 0;
    return PersistentConnection2;
  }(ServerActions)
);
var NamedNode = (
  /** @class */
  function() {
    function NamedNode2(name10, node) {
      this.name = name10;
      this.node = node;
    }
    NamedNode2.Wrap = function(name10, node) {
      return new NamedNode2(name10, node);
    };
    return NamedNode2;
  }()
);
var Index = (
  /** @class */
  function() {
    function Index3() {
    }
    Index3.prototype.getCompare = function() {
      return this.compare.bind(this);
    };
    Index3.prototype.indexedValueChanged = function(oldNode, newNode) {
      var oldWrapped = new NamedNode(MIN_NAME, oldNode);
      var newWrapped = new NamedNode(MIN_NAME, newNode);
      return this.compare(oldWrapped, newWrapped) !== 0;
    };
    Index3.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    return Index3;
  }()
);
var __EMPTY_NODE;
var KeyIndex = (
  /** @class */
  function(_super) {
    __extends(KeyIndex2, _super);
    function KeyIndex2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    Object.defineProperty(KeyIndex2, "__EMPTY_NODE", {
      get: function() {
        return __EMPTY_NODE;
      },
      set: function(val) {
        __EMPTY_NODE = val;
      },
      enumerable: false,
      configurable: true
    });
    KeyIndex2.prototype.compare = function(a, b) {
      return nameCompare(a.name, b.name);
    };
    KeyIndex2.prototype.isDefinedOn = function(node) {
      throw assertionError("KeyIndex.isDefinedOn not expected to be called.");
    };
    KeyIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
      return false;
    };
    KeyIndex2.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    KeyIndex2.prototype.maxPost = function() {
      return new NamedNode(MAX_NAME, __EMPTY_NODE);
    };
    KeyIndex2.prototype.makePost = function(indexValue, name10) {
      assert(typeof indexValue === "string", "KeyIndex indexValue must always be a string.");
      return new NamedNode(indexValue, __EMPTY_NODE);
    };
    KeyIndex2.prototype.toString = function() {
      return ".key";
    };
    return KeyIndex2;
  }(Index)
);
var KEY_INDEX = new KeyIndex();
var SortedMapIterator = (
  /** @class */
  function() {
    function SortedMapIterator2(node, startKey, comparator, isReverse_, resultGenerator_) {
      if (resultGenerator_ === void 0) {
        resultGenerator_ = null;
      }
      this.isReverse_ = isReverse_;
      this.resultGenerator_ = resultGenerator_;
      this.nodeStack_ = [];
      var cmp = 1;
      while (!node.isEmpty()) {
        node = node;
        cmp = startKey ? comparator(node.key, startKey) : 1;
        if (isReverse_) {
          cmp *= -1;
        }
        if (cmp < 0) {
          if (this.isReverse_) {
            node = node.left;
          } else {
            node = node.right;
          }
        } else if (cmp === 0) {
          this.nodeStack_.push(node);
          break;
        } else {
          this.nodeStack_.push(node);
          if (this.isReverse_) {
            node = node.right;
          } else {
            node = node.left;
          }
        }
      }
    }
    SortedMapIterator2.prototype.getNext = function() {
      if (this.nodeStack_.length === 0) {
        return null;
      }
      var node = this.nodeStack_.pop();
      var result;
      if (this.resultGenerator_) {
        result = this.resultGenerator_(node.key, node.value);
      } else {
        result = { key: node.key, value: node.value };
      }
      if (this.isReverse_) {
        node = node.left;
        while (!node.isEmpty()) {
          this.nodeStack_.push(node);
          node = node.right;
        }
      } else {
        node = node.right;
        while (!node.isEmpty()) {
          this.nodeStack_.push(node);
          node = node.left;
        }
      }
      return result;
    };
    SortedMapIterator2.prototype.hasNext = function() {
      return this.nodeStack_.length > 0;
    };
    SortedMapIterator2.prototype.peek = function() {
      if (this.nodeStack_.length === 0) {
        return null;
      }
      var node = this.nodeStack_[this.nodeStack_.length - 1];
      if (this.resultGenerator_) {
        return this.resultGenerator_(node.key, node.value);
      } else {
        return { key: node.key, value: node.value };
      }
    };
    return SortedMapIterator2;
  }()
);
var LLRBNode = (
  /** @class */
  function() {
    function LLRBNode2(key, value, color, left, right) {
      this.key = key;
      this.value = value;
      this.color = color != null ? color : LLRBNode2.RED;
      this.left = left != null ? left : SortedMap.EMPTY_NODE;
      this.right = right != null ? right : SortedMap.EMPTY_NODE;
    }
    LLRBNode2.prototype.copy = function(key, value, color, left, right) {
      return new LLRBNode2(key != null ? key : this.key, value != null ? value : this.value, color != null ? color : this.color, left != null ? left : this.left, right != null ? right : this.right);
    };
    LLRBNode2.prototype.count = function() {
      return this.left.count() + 1 + this.right.count();
    };
    LLRBNode2.prototype.isEmpty = function() {
      return false;
    };
    LLRBNode2.prototype.inorderTraversal = function(action) {
      return this.left.inorderTraversal(action) || !!action(this.key, this.value) || this.right.inorderTraversal(action);
    };
    LLRBNode2.prototype.reverseTraversal = function(action) {
      return this.right.reverseTraversal(action) || action(this.key, this.value) || this.left.reverseTraversal(action);
    };
    LLRBNode2.prototype.min_ = function() {
      if (this.left.isEmpty()) {
        return this;
      } else {
        return this.left.min_();
      }
    };
    LLRBNode2.prototype.minKey = function() {
      return this.min_().key;
    };
    LLRBNode2.prototype.maxKey = function() {
      if (this.right.isEmpty()) {
        return this.key;
      } else {
        return this.right.maxKey();
      }
    };
    LLRBNode2.prototype.insert = function(key, value, comparator) {
      var n = this;
      var cmp = comparator(key, n.key);
      if (cmp < 0) {
        n = n.copy(null, null, null, n.left.insert(key, value, comparator), null);
      } else if (cmp === 0) {
        n = n.copy(null, value, null, null, null);
      } else {
        n = n.copy(null, null, null, null, n.right.insert(key, value, comparator));
      }
      return n.fixUp_();
    };
    LLRBNode2.prototype.removeMin_ = function() {
      if (this.left.isEmpty()) {
        return SortedMap.EMPTY_NODE;
      }
      var n = this;
      if (!n.left.isRed_() && !n.left.left.isRed_()) {
        n = n.moveRedLeft_();
      }
      n = n.copy(null, null, null, n.left.removeMin_(), null);
      return n.fixUp_();
    };
    LLRBNode2.prototype.remove = function(key, comparator) {
      var n, smallest;
      n = this;
      if (comparator(key, n.key) < 0) {
        if (!n.left.isEmpty() && !n.left.isRed_() && !n.left.left.isRed_()) {
          n = n.moveRedLeft_();
        }
        n = n.copy(null, null, null, n.left.remove(key, comparator), null);
      } else {
        if (n.left.isRed_()) {
          n = n.rotateRight_();
        }
        if (!n.right.isEmpty() && !n.right.isRed_() && !n.right.left.isRed_()) {
          n = n.moveRedRight_();
        }
        if (comparator(key, n.key) === 0) {
          if (n.right.isEmpty()) {
            return SortedMap.EMPTY_NODE;
          } else {
            smallest = n.right.min_();
            n = n.copy(smallest.key, smallest.value, null, null, n.right.removeMin_());
          }
        }
        n = n.copy(null, null, null, null, n.right.remove(key, comparator));
      }
      return n.fixUp_();
    };
    LLRBNode2.prototype.isRed_ = function() {
      return this.color;
    };
    LLRBNode2.prototype.fixUp_ = function() {
      var n = this;
      if (n.right.isRed_() && !n.left.isRed_()) {
        n = n.rotateLeft_();
      }
      if (n.left.isRed_() && n.left.left.isRed_()) {
        n = n.rotateRight_();
      }
      if (n.left.isRed_() && n.right.isRed_()) {
        n = n.colorFlip_();
      }
      return n;
    };
    LLRBNode2.prototype.moveRedLeft_ = function() {
      var n = this.colorFlip_();
      if (n.right.left.isRed_()) {
        n = n.copy(null, null, null, null, n.right.rotateRight_());
        n = n.rotateLeft_();
        n = n.colorFlip_();
      }
      return n;
    };
    LLRBNode2.prototype.moveRedRight_ = function() {
      var n = this.colorFlip_();
      if (n.left.left.isRed_()) {
        n = n.rotateRight_();
        n = n.colorFlip_();
      }
      return n;
    };
    LLRBNode2.prototype.rotateLeft_ = function() {
      var nl = this.copy(null, null, LLRBNode2.RED, null, this.right.left);
      return this.right.copy(null, null, this.color, nl, null);
    };
    LLRBNode2.prototype.rotateRight_ = function() {
      var nr = this.copy(null, null, LLRBNode2.RED, this.left.right, null);
      return this.left.copy(null, null, this.color, null, nr);
    };
    LLRBNode2.prototype.colorFlip_ = function() {
      var left = this.left.copy(null, null, !this.left.color, null, null);
      var right = this.right.copy(null, null, !this.right.color, null, null);
      return this.copy(null, null, !this.color, left, right);
    };
    LLRBNode2.prototype.checkMaxDepth_ = function() {
      var blackDepth = this.check_();
      return Math.pow(2, blackDepth) <= this.count() + 1;
    };
    LLRBNode2.prototype.check_ = function() {
      if (this.isRed_() && this.left.isRed_()) {
        throw new Error("Red node has red child(" + this.key + "," + this.value + ")");
      }
      if (this.right.isRed_()) {
        throw new Error("Right child of (" + this.key + "," + this.value + ") is red");
      }
      var blackDepth = this.left.check_();
      if (blackDepth !== this.right.check_()) {
        throw new Error("Black depths differ");
      } else {
        return blackDepth + (this.isRed_() ? 0 : 1);
      }
    };
    LLRBNode2.RED = true;
    LLRBNode2.BLACK = false;
    return LLRBNode2;
  }()
);
var LLRBEmptyNode = (
  /** @class */
  function() {
    function LLRBEmptyNode2() {
    }
    LLRBEmptyNode2.prototype.copy = function(key, value, color, left, right) {
      return this;
    };
    LLRBEmptyNode2.prototype.insert = function(key, value, comparator) {
      return new LLRBNode(key, value, null);
    };
    LLRBEmptyNode2.prototype.remove = function(key, comparator) {
      return this;
    };
    LLRBEmptyNode2.prototype.count = function() {
      return 0;
    };
    LLRBEmptyNode2.prototype.isEmpty = function() {
      return true;
    };
    LLRBEmptyNode2.prototype.inorderTraversal = function(action) {
      return false;
    };
    LLRBEmptyNode2.prototype.reverseTraversal = function(action) {
      return false;
    };
    LLRBEmptyNode2.prototype.minKey = function() {
      return null;
    };
    LLRBEmptyNode2.prototype.maxKey = function() {
      return null;
    };
    LLRBEmptyNode2.prototype.check_ = function() {
      return 0;
    };
    LLRBEmptyNode2.prototype.isRed_ = function() {
      return false;
    };
    return LLRBEmptyNode2;
  }()
);
var SortedMap = (
  /** @class */
  function() {
    function SortedMap2(comparator_, root_) {
      if (root_ === void 0) {
        root_ = SortedMap2.EMPTY_NODE;
      }
      this.comparator_ = comparator_;
      this.root_ = root_;
    }
    SortedMap2.prototype.insert = function(key, value) {
      return new SortedMap2(this.comparator_, this.root_.insert(key, value, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
    };
    SortedMap2.prototype.remove = function(key) {
      return new SortedMap2(this.comparator_, this.root_.remove(key, this.comparator_).copy(null, null, LLRBNode.BLACK, null, null));
    };
    SortedMap2.prototype.get = function(key) {
      var cmp;
      var node = this.root_;
      while (!node.isEmpty()) {
        cmp = this.comparator_(key, node.key);
        if (cmp === 0) {
          return node.value;
        } else if (cmp < 0) {
          node = node.left;
        } else if (cmp > 0) {
          node = node.right;
        }
      }
      return null;
    };
    SortedMap2.prototype.getPredecessorKey = function(key) {
      var cmp, node = this.root_, rightParent = null;
      while (!node.isEmpty()) {
        cmp = this.comparator_(key, node.key);
        if (cmp === 0) {
          if (!node.left.isEmpty()) {
            node = node.left;
            while (!node.right.isEmpty()) {
              node = node.right;
            }
            return node.key;
          } else if (rightParent) {
            return rightParent.key;
          } else {
            return null;
          }
        } else if (cmp < 0) {
          node = node.left;
        } else if (cmp > 0) {
          rightParent = node;
          node = node.right;
        }
      }
      throw new Error("Attempted to find predecessor key for a nonexistent key.  What gives?");
    };
    SortedMap2.prototype.isEmpty = function() {
      return this.root_.isEmpty();
    };
    SortedMap2.prototype.count = function() {
      return this.root_.count();
    };
    SortedMap2.prototype.minKey = function() {
      return this.root_.minKey();
    };
    SortedMap2.prototype.maxKey = function() {
      return this.root_.maxKey();
    };
    SortedMap2.prototype.inorderTraversal = function(action) {
      return this.root_.inorderTraversal(action);
    };
    SortedMap2.prototype.reverseTraversal = function(action) {
      return this.root_.reverseTraversal(action);
    };
    SortedMap2.prototype.getIterator = function(resultGenerator) {
      return new SortedMapIterator(this.root_, null, this.comparator_, false, resultGenerator);
    };
    SortedMap2.prototype.getIteratorFrom = function(key, resultGenerator) {
      return new SortedMapIterator(this.root_, key, this.comparator_, false, resultGenerator);
    };
    SortedMap2.prototype.getReverseIteratorFrom = function(key, resultGenerator) {
      return new SortedMapIterator(this.root_, key, this.comparator_, true, resultGenerator);
    };
    SortedMap2.prototype.getReverseIterator = function(resultGenerator) {
      return new SortedMapIterator(this.root_, null, this.comparator_, true, resultGenerator);
    };
    SortedMap2.EMPTY_NODE = new LLRBEmptyNode();
    return SortedMap2;
  }()
);
function NAME_ONLY_COMPARATOR(left, right) {
  return nameCompare(left.name, right.name);
}
function NAME_COMPARATOR(left, right) {
  return nameCompare(left, right);
}
var MAX_NODE$2;
function setMaxNode$1(val) {
  MAX_NODE$2 = val;
}
var priorityHashText = function(priority) {
  if (typeof priority === "number") {
    return "number:" + doubleToIEEE754String(priority);
  } else {
    return "string:" + priority;
  }
};
var validatePriorityNode = function(priorityNode) {
  if (priorityNode.isLeafNode()) {
    var val = priorityNode.val();
    assert(typeof val === "string" || typeof val === "number" || typeof val === "object" && contains(val, ".sv"), "Priority must be a string or number.");
  } else {
    assert(priorityNode === MAX_NODE$2 || priorityNode.isEmpty(), "priority of unexpected type.");
  }
  assert(priorityNode === MAX_NODE$2 || priorityNode.getPriority().isEmpty(), "Priority nodes can't have a priority of their own.");
};
var __childrenNodeConstructor;
var LeafNode = (
  /** @class */
  function() {
    function LeafNode2(value_, priorityNode_) {
      if (priorityNode_ === void 0) {
        priorityNode_ = LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
      }
      this.value_ = value_;
      this.priorityNode_ = priorityNode_;
      this.lazyHash_ = null;
      assert(this.value_ !== void 0 && this.value_ !== null, "LeafNode shouldn't be created with null/undefined value.");
      validatePriorityNode(this.priorityNode_);
    }
    Object.defineProperty(LeafNode2, "__childrenNodeConstructor", {
      get: function() {
        return __childrenNodeConstructor;
      },
      set: function(val) {
        __childrenNodeConstructor = val;
      },
      enumerable: false,
      configurable: true
    });
    LeafNode2.prototype.isLeafNode = function() {
      return true;
    };
    LeafNode2.prototype.getPriority = function() {
      return this.priorityNode_;
    };
    LeafNode2.prototype.updatePriority = function(newPriorityNode) {
      return new LeafNode2(this.value_, newPriorityNode);
    };
    LeafNode2.prototype.getImmediateChild = function(childName) {
      if (childName === ".priority") {
        return this.priorityNode_;
      } else {
        return LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
      }
    };
    LeafNode2.prototype.getChild = function(path) {
      if (pathIsEmpty(path)) {
        return this;
      } else if (pathGetFront(path) === ".priority") {
        return this.priorityNode_;
      } else {
        return LeafNode2.__childrenNodeConstructor.EMPTY_NODE;
      }
    };
    LeafNode2.prototype.hasChild = function() {
      return false;
    };
    LeafNode2.prototype.getPredecessorChildName = function(childName, childNode) {
      return null;
    };
    LeafNode2.prototype.updateImmediateChild = function(childName, newChildNode) {
      if (childName === ".priority") {
        return this.updatePriority(newChildNode);
      } else if (newChildNode.isEmpty() && childName !== ".priority") {
        return this;
      } else {
        return LeafNode2.__childrenNodeConstructor.EMPTY_NODE.updateImmediateChild(childName, newChildNode).updatePriority(this.priorityNode_);
      }
    };
    LeafNode2.prototype.updateChild = function(path, newChildNode) {
      var front = pathGetFront(path);
      if (front === null) {
        return newChildNode;
      } else if (newChildNode.isEmpty() && front !== ".priority") {
        return this;
      } else {
        assert(front !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
        return this.updateImmediateChild(front, LeafNode2.__childrenNodeConstructor.EMPTY_NODE.updateChild(pathPopFront(path), newChildNode));
      }
    };
    LeafNode2.prototype.isEmpty = function() {
      return false;
    };
    LeafNode2.prototype.numChildren = function() {
      return 0;
    };
    LeafNode2.prototype.forEachChild = function(index, action) {
      return false;
    };
    LeafNode2.prototype.val = function(exportFormat) {
      if (exportFormat && !this.getPriority().isEmpty()) {
        return {
          ".value": this.getValue(),
          ".priority": this.getPriority().val()
        };
      } else {
        return this.getValue();
      }
    };
    LeafNode2.prototype.hash = function() {
      if (this.lazyHash_ === null) {
        var toHash = "";
        if (!this.priorityNode_.isEmpty()) {
          toHash += "priority:" + priorityHashText(this.priorityNode_.val()) + ":";
        }
        var type = typeof this.value_;
        toHash += type + ":";
        if (type === "number") {
          toHash += doubleToIEEE754String(this.value_);
        } else {
          toHash += this.value_;
        }
        this.lazyHash_ = sha1(toHash);
      }
      return this.lazyHash_;
    };
    LeafNode2.prototype.getValue = function() {
      return this.value_;
    };
    LeafNode2.prototype.compareTo = function(other) {
      if (other === LeafNode2.__childrenNodeConstructor.EMPTY_NODE) {
        return 1;
      } else if (other instanceof LeafNode2.__childrenNodeConstructor) {
        return -1;
      } else {
        assert(other.isLeafNode(), "Unknown node type");
        return this.compareToLeafNode_(other);
      }
    };
    LeafNode2.prototype.compareToLeafNode_ = function(otherLeaf) {
      var otherLeafType = typeof otherLeaf.value_;
      var thisLeafType = typeof this.value_;
      var otherIndex = LeafNode2.VALUE_TYPE_ORDER.indexOf(otherLeafType);
      var thisIndex = LeafNode2.VALUE_TYPE_ORDER.indexOf(thisLeafType);
      assert(otherIndex >= 0, "Unknown leaf type: " + otherLeafType);
      assert(thisIndex >= 0, "Unknown leaf type: " + thisLeafType);
      if (otherIndex === thisIndex) {
        if (thisLeafType === "object") {
          return 0;
        } else {
          if (this.value_ < otherLeaf.value_) {
            return -1;
          } else if (this.value_ === otherLeaf.value_) {
            return 0;
          } else {
            return 1;
          }
        }
      } else {
        return thisIndex - otherIndex;
      }
    };
    LeafNode2.prototype.withIndex = function() {
      return this;
    };
    LeafNode2.prototype.isIndexed = function() {
      return true;
    };
    LeafNode2.prototype.equals = function(other) {
      if (other === this) {
        return true;
      } else if (other.isLeafNode()) {
        var otherLeaf = other;
        return this.value_ === otherLeaf.value_ && this.priorityNode_.equals(otherLeaf.priorityNode_);
      } else {
        return false;
      }
    };
    LeafNode2.VALUE_TYPE_ORDER = ["object", "boolean", "number", "string"];
    return LeafNode2;
  }()
);
var nodeFromJSON$1;
var MAX_NODE$1;
function setNodeFromJSON(val) {
  nodeFromJSON$1 = val;
}
function setMaxNode(val) {
  MAX_NODE$1 = val;
}
var PriorityIndex = (
  /** @class */
  function(_super) {
    __extends(PriorityIndex2, _super);
    function PriorityIndex2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    PriorityIndex2.prototype.compare = function(a, b) {
      var aPriority = a.node.getPriority();
      var bPriority = b.node.getPriority();
      var indexCmp = aPriority.compareTo(bPriority);
      if (indexCmp === 0) {
        return nameCompare(a.name, b.name);
      } else {
        return indexCmp;
      }
    };
    PriorityIndex2.prototype.isDefinedOn = function(node) {
      return !node.getPriority().isEmpty();
    };
    PriorityIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
      return !oldNode.getPriority().equals(newNode.getPriority());
    };
    PriorityIndex2.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    PriorityIndex2.prototype.maxPost = function() {
      return new NamedNode(MAX_NAME, new LeafNode("[PRIORITY-POST]", MAX_NODE$1));
    };
    PriorityIndex2.prototype.makePost = function(indexValue, name10) {
      var priorityNode = nodeFromJSON$1(indexValue);
      return new NamedNode(name10, new LeafNode("[PRIORITY-POST]", priorityNode));
    };
    PriorityIndex2.prototype.toString = function() {
      return ".priority";
    };
    return PriorityIndex2;
  }(Index)
);
var PRIORITY_INDEX = new PriorityIndex();
var LOG_2 = Math.log(2);
var Base12Num = (
  /** @class */
  function() {
    function Base12Num2(length) {
      var logBase2 = function(num) {
        return parseInt(Math.log(num) / LOG_2, 10);
      };
      var bitMask = function(bits) {
        return parseInt(Array(bits + 1).join("1"), 2);
      };
      this.count = logBase2(length + 1);
      this.current_ = this.count - 1;
      var mask = bitMask(this.count);
      this.bits_ = length + 1 & mask;
    }
    Base12Num2.prototype.nextBitIsOne = function() {
      var result = !(this.bits_ & 1 << this.current_);
      this.current_--;
      return result;
    };
    return Base12Num2;
  }()
);
var buildChildSet = function(childList, cmp, keyFn, mapSortFn) {
  childList.sort(cmp);
  var buildBalancedTree = function(low, high) {
    var length = high - low;
    var namedNode;
    var key;
    if (length === 0) {
      return null;
    } else if (length === 1) {
      namedNode = childList[low];
      key = keyFn ? keyFn(namedNode) : namedNode;
      return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, null, null);
    } else {
      var middle = parseInt(length / 2, 10) + low;
      var left = buildBalancedTree(low, middle);
      var right = buildBalancedTree(middle + 1, high);
      namedNode = childList[middle];
      key = keyFn ? keyFn(namedNode) : namedNode;
      return new LLRBNode(key, namedNode.node, LLRBNode.BLACK, left, right);
    }
  };
  var buildFrom12Array = function(base122) {
    var node = null;
    var root2 = null;
    var index = childList.length;
    var buildPennant = function(chunkSize2, color) {
      var low = index - chunkSize2;
      var high = index;
      index -= chunkSize2;
      var childTree = buildBalancedTree(low + 1, high);
      var namedNode = childList[low];
      var key = keyFn ? keyFn(namedNode) : namedNode;
      attachPennant(new LLRBNode(key, namedNode.node, color, null, childTree));
    };
    var attachPennant = function(pennant) {
      if (node) {
        node.left = pennant;
        node = pennant;
      } else {
        root2 = pennant;
        node = pennant;
      }
    };
    for (var i = 0; i < base122.count; ++i) {
      var isOne = base122.nextBitIsOne();
      var chunkSize = Math.pow(2, base122.count - (i + 1));
      if (isOne) {
        buildPennant(chunkSize, LLRBNode.BLACK);
      } else {
        buildPennant(chunkSize, LLRBNode.BLACK);
        buildPennant(chunkSize, LLRBNode.RED);
      }
    }
    return root2;
  };
  var base12 = new Base12Num(childList.length);
  var root = buildFrom12Array(base12);
  return new SortedMap(mapSortFn || cmp, root);
};
var _defaultIndexMap;
var fallbackObject = {};
var IndexMap = (
  /** @class */
  function() {
    function IndexMap2(indexes_, indexSet_) {
      this.indexes_ = indexes_;
      this.indexSet_ = indexSet_;
    }
    Object.defineProperty(IndexMap2, "Default", {
      /**
       * The default IndexMap for nodes without a priority
       */
      get: function() {
        assert(fallbackObject && PRIORITY_INDEX, "ChildrenNode.ts has not been loaded");
        _defaultIndexMap = _defaultIndexMap || new IndexMap2({ ".priority": fallbackObject }, { ".priority": PRIORITY_INDEX });
        return _defaultIndexMap;
      },
      enumerable: false,
      configurable: true
    });
    IndexMap2.prototype.get = function(indexKey) {
      var sortedMap = safeGet(this.indexes_, indexKey);
      if (!sortedMap) {
        throw new Error("No index defined for " + indexKey);
      }
      if (sortedMap instanceof SortedMap) {
        return sortedMap;
      } else {
        return null;
      }
    };
    IndexMap2.prototype.hasIndex = function(indexDefinition) {
      return contains(this.indexSet_, indexDefinition.toString());
    };
    IndexMap2.prototype.addIndex = function(indexDefinition, existingChildren) {
      assert(indexDefinition !== KEY_INDEX, "KeyIndex always exists and isn't meant to be added to the IndexMap.");
      var childList = [];
      var sawIndexedValue = false;
      var iter = existingChildren.getIterator(NamedNode.Wrap);
      var next = iter.getNext();
      while (next) {
        sawIndexedValue = sawIndexedValue || indexDefinition.isDefinedOn(next.node);
        childList.push(next);
        next = iter.getNext();
      }
      var newIndex;
      if (sawIndexedValue) {
        newIndex = buildChildSet(childList, indexDefinition.getCompare());
      } else {
        newIndex = fallbackObject;
      }
      var indexName = indexDefinition.toString();
      var newIndexSet = __assign({}, this.indexSet_);
      newIndexSet[indexName] = indexDefinition;
      var newIndexes = __assign({}, this.indexes_);
      newIndexes[indexName] = newIndex;
      return new IndexMap2(newIndexes, newIndexSet);
    };
    IndexMap2.prototype.addToIndexes = function(namedNode, existingChildren) {
      var _this = this;
      var newIndexes = map(this.indexes_, function(indexedChildren, indexName) {
        var index = safeGet(_this.indexSet_, indexName);
        assert(index, "Missing index implementation for " + indexName);
        if (indexedChildren === fallbackObject) {
          if (index.isDefinedOn(namedNode.node)) {
            var childList = [];
            var iter = existingChildren.getIterator(NamedNode.Wrap);
            var next = iter.getNext();
            while (next) {
              if (next.name !== namedNode.name) {
                childList.push(next);
              }
              next = iter.getNext();
            }
            childList.push(namedNode);
            return buildChildSet(childList, index.getCompare());
          } else {
            return fallbackObject;
          }
        } else {
          var existingSnap = existingChildren.get(namedNode.name);
          var newChildren = indexedChildren;
          if (existingSnap) {
            newChildren = newChildren.remove(new NamedNode(namedNode.name, existingSnap));
          }
          return newChildren.insert(namedNode, namedNode.node);
        }
      });
      return new IndexMap2(newIndexes, this.indexSet_);
    };
    IndexMap2.prototype.removeFromIndexes = function(namedNode, existingChildren) {
      var newIndexes = map(this.indexes_, function(indexedChildren) {
        if (indexedChildren === fallbackObject) {
          return indexedChildren;
        } else {
          var existingSnap = existingChildren.get(namedNode.name);
          if (existingSnap) {
            return indexedChildren.remove(new NamedNode(namedNode.name, existingSnap));
          } else {
            return indexedChildren;
          }
        }
      });
      return new IndexMap2(newIndexes, this.indexSet_);
    };
    return IndexMap2;
  }()
);
var EMPTY_NODE;
var ChildrenNode = (
  /** @class */
  function() {
    function ChildrenNode2(children_, priorityNode_, indexMap_) {
      this.children_ = children_;
      this.priorityNode_ = priorityNode_;
      this.indexMap_ = indexMap_;
      this.lazyHash_ = null;
      if (this.priorityNode_) {
        validatePriorityNode(this.priorityNode_);
      }
      if (this.children_.isEmpty()) {
        assert(!this.priorityNode_ || this.priorityNode_.isEmpty(), "An empty node cannot have a priority");
      }
    }
    Object.defineProperty(ChildrenNode2, "EMPTY_NODE", {
      get: function() {
        return EMPTY_NODE || (EMPTY_NODE = new ChildrenNode2(new SortedMap(NAME_COMPARATOR), null, IndexMap.Default));
      },
      enumerable: false,
      configurable: true
    });
    ChildrenNode2.prototype.isLeafNode = function() {
      return false;
    };
    ChildrenNode2.prototype.getPriority = function() {
      return this.priorityNode_ || EMPTY_NODE;
    };
    ChildrenNode2.prototype.updatePriority = function(newPriorityNode) {
      if (this.children_.isEmpty()) {
        return this;
      } else {
        return new ChildrenNode2(this.children_, newPriorityNode, this.indexMap_);
      }
    };
    ChildrenNode2.prototype.getImmediateChild = function(childName) {
      if (childName === ".priority") {
        return this.getPriority();
      } else {
        var child3 = this.children_.get(childName);
        return child3 === null ? EMPTY_NODE : child3;
      }
    };
    ChildrenNode2.prototype.getChild = function(path) {
      var front = pathGetFront(path);
      if (front === null) {
        return this;
      }
      return this.getImmediateChild(front).getChild(pathPopFront(path));
    };
    ChildrenNode2.prototype.hasChild = function(childName) {
      return this.children_.get(childName) !== null;
    };
    ChildrenNode2.prototype.updateImmediateChild = function(childName, newChildNode) {
      assert(newChildNode, "We should always be passing snapshot nodes");
      if (childName === ".priority") {
        return this.updatePriority(newChildNode);
      } else {
        var namedNode = new NamedNode(childName, newChildNode);
        var newChildren = void 0, newIndexMap = void 0;
        if (newChildNode.isEmpty()) {
          newChildren = this.children_.remove(childName);
          newIndexMap = this.indexMap_.removeFromIndexes(namedNode, this.children_);
        } else {
          newChildren = this.children_.insert(childName, newChildNode);
          newIndexMap = this.indexMap_.addToIndexes(namedNode, this.children_);
        }
        var newPriority = newChildren.isEmpty() ? EMPTY_NODE : this.priorityNode_;
        return new ChildrenNode2(newChildren, newPriority, newIndexMap);
      }
    };
    ChildrenNode2.prototype.updateChild = function(path, newChildNode) {
      var front = pathGetFront(path);
      if (front === null) {
        return newChildNode;
      } else {
        assert(pathGetFront(path) !== ".priority" || pathGetLength(path) === 1, ".priority must be the last token in a path");
        var newImmediateChild = this.getImmediateChild(front).updateChild(pathPopFront(path), newChildNode);
        return this.updateImmediateChild(front, newImmediateChild);
      }
    };
    ChildrenNode2.prototype.isEmpty = function() {
      return this.children_.isEmpty();
    };
    ChildrenNode2.prototype.numChildren = function() {
      return this.children_.count();
    };
    ChildrenNode2.prototype.val = function(exportFormat) {
      if (this.isEmpty()) {
        return null;
      }
      var obj = {};
      var numKeys = 0, maxKey = 0, allIntegerKeys = true;
      this.forEachChild(PRIORITY_INDEX, function(key2, childNode) {
        obj[key2] = childNode.val(exportFormat);
        numKeys++;
        if (allIntegerKeys && ChildrenNode2.INTEGER_REGEXP_.test(key2)) {
          maxKey = Math.max(maxKey, Number(key2));
        } else {
          allIntegerKeys = false;
        }
      });
      if (!exportFormat && allIntegerKeys && maxKey < 2 * numKeys) {
        var array = [];
        for (var key in obj) {
          array[key] = obj[key];
        }
        return array;
      } else {
        if (exportFormat && !this.getPriority().isEmpty()) {
          obj[".priority"] = this.getPriority().val();
        }
        return obj;
      }
    };
    ChildrenNode2.prototype.hash = function() {
      if (this.lazyHash_ === null) {
        var toHash_1 = "";
        if (!this.getPriority().isEmpty()) {
          toHash_1 += "priority:" + priorityHashText(this.getPriority().val()) + ":";
        }
        this.forEachChild(PRIORITY_INDEX, function(key, childNode) {
          var childHash = childNode.hash();
          if (childHash !== "") {
            toHash_1 += ":" + key + ":" + childHash;
          }
        });
        this.lazyHash_ = toHash_1 === "" ? "" : sha1(toHash_1);
      }
      return this.lazyHash_;
    };
    ChildrenNode2.prototype.getPredecessorChildName = function(childName, childNode, index) {
      var idx = this.resolveIndex_(index);
      if (idx) {
        var predecessor2 = idx.getPredecessorKey(new NamedNode(childName, childNode));
        return predecessor2 ? predecessor2.name : null;
      } else {
        return this.children_.getPredecessorKey(childName);
      }
    };
    ChildrenNode2.prototype.getFirstChildName = function(indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        var minKey = idx.minKey();
        return minKey && minKey.name;
      } else {
        return this.children_.minKey();
      }
    };
    ChildrenNode2.prototype.getFirstChild = function(indexDefinition) {
      var minKey = this.getFirstChildName(indexDefinition);
      if (minKey) {
        return new NamedNode(minKey, this.children_.get(minKey));
      } else {
        return null;
      }
    };
    ChildrenNode2.prototype.getLastChildName = function(indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        var maxKey = idx.maxKey();
        return maxKey && maxKey.name;
      } else {
        return this.children_.maxKey();
      }
    };
    ChildrenNode2.prototype.getLastChild = function(indexDefinition) {
      var maxKey = this.getLastChildName(indexDefinition);
      if (maxKey) {
        return new NamedNode(maxKey, this.children_.get(maxKey));
      } else {
        return null;
      }
    };
    ChildrenNode2.prototype.forEachChild = function(index, action) {
      var idx = this.resolveIndex_(index);
      if (idx) {
        return idx.inorderTraversal(function(wrappedNode) {
          return action(wrappedNode.name, wrappedNode.node);
        });
      } else {
        return this.children_.inorderTraversal(action);
      }
    };
    ChildrenNode2.prototype.getIterator = function(indexDefinition) {
      return this.getIteratorFrom(indexDefinition.minPost(), indexDefinition);
    };
    ChildrenNode2.prototype.getIteratorFrom = function(startPost, indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        return idx.getIteratorFrom(startPost, function(key) {
          return key;
        });
      } else {
        var iterator = this.children_.getIteratorFrom(startPost.name, NamedNode.Wrap);
        var next = iterator.peek();
        while (next != null && indexDefinition.compare(next, startPost) < 0) {
          iterator.getNext();
          next = iterator.peek();
        }
        return iterator;
      }
    };
    ChildrenNode2.prototype.getReverseIterator = function(indexDefinition) {
      return this.getReverseIteratorFrom(indexDefinition.maxPost(), indexDefinition);
    };
    ChildrenNode2.prototype.getReverseIteratorFrom = function(endPost, indexDefinition) {
      var idx = this.resolveIndex_(indexDefinition);
      if (idx) {
        return idx.getReverseIteratorFrom(endPost, function(key) {
          return key;
        });
      } else {
        var iterator = this.children_.getReverseIteratorFrom(endPost.name, NamedNode.Wrap);
        var next = iterator.peek();
        while (next != null && indexDefinition.compare(next, endPost) > 0) {
          iterator.getNext();
          next = iterator.peek();
        }
        return iterator;
      }
    };
    ChildrenNode2.prototype.compareTo = function(other) {
      if (this.isEmpty()) {
        if (other.isEmpty()) {
          return 0;
        } else {
          return -1;
        }
      } else if (other.isLeafNode() || other.isEmpty()) {
        return 1;
      } else if (other === MAX_NODE) {
        return -1;
      } else {
        return 0;
      }
    };
    ChildrenNode2.prototype.withIndex = function(indexDefinition) {
      if (indexDefinition === KEY_INDEX || this.indexMap_.hasIndex(indexDefinition)) {
        return this;
      } else {
        var newIndexMap = this.indexMap_.addIndex(indexDefinition, this.children_);
        return new ChildrenNode2(this.children_, this.priorityNode_, newIndexMap);
      }
    };
    ChildrenNode2.prototype.isIndexed = function(index) {
      return index === KEY_INDEX || this.indexMap_.hasIndex(index);
    };
    ChildrenNode2.prototype.equals = function(other) {
      if (other === this) {
        return true;
      } else if (other.isLeafNode()) {
        return false;
      } else {
        var otherChildrenNode = other;
        if (!this.getPriority().equals(otherChildrenNode.getPriority())) {
          return false;
        } else if (this.children_.count() === otherChildrenNode.children_.count()) {
          var thisIter = this.getIterator(PRIORITY_INDEX);
          var otherIter = otherChildrenNode.getIterator(PRIORITY_INDEX);
          var thisCurrent = thisIter.getNext();
          var otherCurrent = otherIter.getNext();
          while (thisCurrent && otherCurrent) {
            if (thisCurrent.name !== otherCurrent.name || !thisCurrent.node.equals(otherCurrent.node)) {
              return false;
            }
            thisCurrent = thisIter.getNext();
            otherCurrent = otherIter.getNext();
          }
          return thisCurrent === null && otherCurrent === null;
        } else {
          return false;
        }
      }
    };
    ChildrenNode2.prototype.resolveIndex_ = function(indexDefinition) {
      if (indexDefinition === KEY_INDEX) {
        return null;
      } else {
        return this.indexMap_.get(indexDefinition.toString());
      }
    };
    ChildrenNode2.INTEGER_REGEXP_ = /^(0|[1-9]\d*)$/;
    return ChildrenNode2;
  }()
);
var MaxNode = (
  /** @class */
  function(_super) {
    __extends(MaxNode2, _super);
    function MaxNode2() {
      return _super.call(this, new SortedMap(NAME_COMPARATOR), ChildrenNode.EMPTY_NODE, IndexMap.Default) || this;
    }
    MaxNode2.prototype.compareTo = function(other) {
      if (other === this) {
        return 0;
      } else {
        return 1;
      }
    };
    MaxNode2.prototype.equals = function(other) {
      return other === this;
    };
    MaxNode2.prototype.getPriority = function() {
      return this;
    };
    MaxNode2.prototype.getImmediateChild = function(childName) {
      return ChildrenNode.EMPTY_NODE;
    };
    MaxNode2.prototype.isEmpty = function() {
      return false;
    };
    return MaxNode2;
  }(ChildrenNode)
);
var MAX_NODE = new MaxNode();
Object.defineProperties(NamedNode, {
  MIN: {
    value: new NamedNode(MIN_NAME, ChildrenNode.EMPTY_NODE)
  },
  MAX: {
    value: new NamedNode(MAX_NAME, MAX_NODE)
  }
});
KeyIndex.__EMPTY_NODE = ChildrenNode.EMPTY_NODE;
LeafNode.__childrenNodeConstructor = ChildrenNode;
setMaxNode$1(MAX_NODE);
setMaxNode(MAX_NODE);
var USE_HINZE = true;
function nodeFromJSON(json, priority) {
  if (priority === void 0) {
    priority = null;
  }
  if (json === null) {
    return ChildrenNode.EMPTY_NODE;
  }
  if (typeof json === "object" && ".priority" in json) {
    priority = json[".priority"];
  }
  assert(priority === null || typeof priority === "string" || typeof priority === "number" || typeof priority === "object" && ".sv" in priority, "Invalid priority type found: " + typeof priority);
  if (typeof json === "object" && ".value" in json && json[".value"] !== null) {
    json = json[".value"];
  }
  if (typeof json !== "object" || ".sv" in json) {
    var jsonLeaf = json;
    return new LeafNode(jsonLeaf, nodeFromJSON(priority));
  }
  if (!(json instanceof Array) && USE_HINZE) {
    var children_1 = [];
    var childrenHavePriority_1 = false;
    var hinzeJsonObj = json;
    each(hinzeJsonObj, function(key, child3) {
      if (key.substring(0, 1) !== ".") {
        var childNode = nodeFromJSON(child3);
        if (!childNode.isEmpty()) {
          childrenHavePriority_1 = childrenHavePriority_1 || !childNode.getPriority().isEmpty();
          children_1.push(new NamedNode(key, childNode));
        }
      }
    });
    if (children_1.length === 0) {
      return ChildrenNode.EMPTY_NODE;
    }
    var childSet = buildChildSet(children_1, NAME_ONLY_COMPARATOR, function(namedNode) {
      return namedNode.name;
    }, NAME_COMPARATOR);
    if (childrenHavePriority_1) {
      var sortedChildSet = buildChildSet(children_1, PRIORITY_INDEX.getCompare());
      return new ChildrenNode(childSet, nodeFromJSON(priority), new IndexMap({ ".priority": sortedChildSet }, { ".priority": PRIORITY_INDEX }));
    } else {
      return new ChildrenNode(childSet, nodeFromJSON(priority), IndexMap.Default);
    }
  } else {
    var node_1 = ChildrenNode.EMPTY_NODE;
    each(json, function(key, childData) {
      if (contains(json, key)) {
        if (key.substring(0, 1) !== ".") {
          var childNode = nodeFromJSON(childData);
          if (childNode.isLeafNode() || !childNode.isEmpty()) {
            node_1 = node_1.updateImmediateChild(key, childNode);
          }
        }
      }
    });
    return node_1.updatePriority(nodeFromJSON(priority));
  }
}
setNodeFromJSON(nodeFromJSON);
var PathIndex = (
  /** @class */
  function(_super) {
    __extends(PathIndex2, _super);
    function PathIndex2(indexPath_) {
      var _this = _super.call(this) || this;
      _this.indexPath_ = indexPath_;
      assert(!pathIsEmpty(indexPath_) && pathGetFront(indexPath_) !== ".priority", "Can't create PathIndex with empty path or .priority key");
      return _this;
    }
    PathIndex2.prototype.extractChild = function(snap) {
      return snap.getChild(this.indexPath_);
    };
    PathIndex2.prototype.isDefinedOn = function(node) {
      return !node.getChild(this.indexPath_).isEmpty();
    };
    PathIndex2.prototype.compare = function(a, b) {
      var aChild = this.extractChild(a.node);
      var bChild = this.extractChild(b.node);
      var indexCmp = aChild.compareTo(bChild);
      if (indexCmp === 0) {
        return nameCompare(a.name, b.name);
      } else {
        return indexCmp;
      }
    };
    PathIndex2.prototype.makePost = function(indexValue, name10) {
      var valueNode = nodeFromJSON(indexValue);
      var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, valueNode);
      return new NamedNode(name10, node);
    };
    PathIndex2.prototype.maxPost = function() {
      var node = ChildrenNode.EMPTY_NODE.updateChild(this.indexPath_, MAX_NODE);
      return new NamedNode(MAX_NAME, node);
    };
    PathIndex2.prototype.toString = function() {
      return pathSlice(this.indexPath_, 0).join("/");
    };
    return PathIndex2;
  }(Index)
);
var ValueIndex = (
  /** @class */
  function(_super) {
    __extends(ValueIndex2, _super);
    function ValueIndex2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    ValueIndex2.prototype.compare = function(a, b) {
      var indexCmp = a.node.compareTo(b.node);
      if (indexCmp === 0) {
        return nameCompare(a.name, b.name);
      } else {
        return indexCmp;
      }
    };
    ValueIndex2.prototype.isDefinedOn = function(node) {
      return true;
    };
    ValueIndex2.prototype.indexedValueChanged = function(oldNode, newNode) {
      return !oldNode.equals(newNode);
    };
    ValueIndex2.prototype.minPost = function() {
      return NamedNode.MIN;
    };
    ValueIndex2.prototype.maxPost = function() {
      return NamedNode.MAX;
    };
    ValueIndex2.prototype.makePost = function(indexValue, name10) {
      var valueNode = nodeFromJSON(indexValue);
      return new NamedNode(name10, valueNode);
    };
    ValueIndex2.prototype.toString = function() {
      return ".value";
    };
    return ValueIndex2;
  }(Index)
);
var VALUE_INDEX = new ValueIndex();
var PUSH_CHARS = "-0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz";
var MIN_PUSH_CHAR = "-";
var MAX_PUSH_CHAR = "z";
var MAX_KEY_LEN = 786;
var nextPushId = /* @__PURE__ */ function() {
  var lastPushTime = 0;
  var lastRandChars = [];
  return function(now) {
    var duplicateTime = now === lastPushTime;
    lastPushTime = now;
    var i;
    var timeStampChars = new Array(8);
    for (i = 7; i >= 0; i--) {
      timeStampChars[i] = PUSH_CHARS.charAt(now % 64);
      now = Math.floor(now / 64);
    }
    assert(now === 0, "Cannot push at time == 0");
    var id = timeStampChars.join("");
    if (!duplicateTime) {
      for (i = 0; i < 12; i++) {
        lastRandChars[i] = Math.floor(Math.random() * 64);
      }
    } else {
      for (i = 11; i >= 0 && lastRandChars[i] === 63; i--) {
        lastRandChars[i] = 0;
      }
      lastRandChars[i]++;
    }
    for (i = 0; i < 12; i++) {
      id += PUSH_CHARS.charAt(lastRandChars[i]);
    }
    assert(id.length === 20, "nextPushId: Length should be 20.");
    return id;
  };
}();
var successor = function(key) {
  if (key === "" + INTEGER_32_MAX) {
    return MIN_PUSH_CHAR;
  }
  var keyAsInt = tryParseInt(key);
  if (keyAsInt != null) {
    return "" + (keyAsInt + 1);
  }
  var next = new Array(key.length);
  for (var i_1 = 0; i_1 < next.length; i_1++) {
    next[i_1] = key.charAt(i_1);
  }
  if (next.length < MAX_KEY_LEN) {
    next.push(MIN_PUSH_CHAR);
    return next.join("");
  }
  var i = next.length - 1;
  while (i >= 0 && next[i] === MAX_PUSH_CHAR) {
    i--;
  }
  if (i === -1) {
    return MAX_NAME;
  }
  var source = next[i];
  var sourcePlusOne = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(source) + 1);
  next[i] = sourcePlusOne;
  return next.slice(0, i + 1).join("");
};
var predecessor = function(key) {
  if (key === "" + INTEGER_32_MIN) {
    return MIN_NAME;
  }
  var keyAsInt = tryParseInt(key);
  if (keyAsInt != null) {
    return "" + (keyAsInt - 1);
  }
  var next = new Array(key.length);
  for (var i = 0; i < next.length; i++) {
    next[i] = key.charAt(i);
  }
  if (next[next.length - 1] === MIN_PUSH_CHAR) {
    if (next.length === 1) {
      return "" + INTEGER_32_MAX;
    }
    delete next[next.length - 1];
    return next.join("");
  }
  next[next.length - 1] = PUSH_CHARS.charAt(PUSH_CHARS.indexOf(next[next.length - 1]) - 1);
  return next.join("") + MAX_PUSH_CHAR.repeat(MAX_KEY_LEN - next.length);
};
function changeValue(snapshotNode) {
  return { type: "value", snapshotNode };
}
function changeChildAdded(childName, snapshotNode) {
  return { type: "child_added", snapshotNode, childName };
}
function changeChildRemoved(childName, snapshotNode) {
  return { type: "child_removed", snapshotNode, childName };
}
function changeChildChanged(childName, snapshotNode, oldSnap) {
  return {
    type: "child_changed",
    snapshotNode,
    childName,
    oldSnap
  };
}
function changeChildMoved(childName, snapshotNode) {
  return { type: "child_moved", snapshotNode, childName };
}
var IndexedFilter = (
  /** @class */
  function() {
    function IndexedFilter2(index_) {
      this.index_ = index_;
    }
    IndexedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
      assert(snap.isIndexed(this.index_), "A node must be indexed if only a child is updated");
      var oldChild = snap.getImmediateChild(key);
      if (oldChild.getChild(affectedPath).equals(newChild.getChild(affectedPath))) {
        if (oldChild.isEmpty() === newChild.isEmpty()) {
          return snap;
        }
      }
      if (optChangeAccumulator != null) {
        if (newChild.isEmpty()) {
          if (snap.hasChild(key)) {
            optChangeAccumulator.trackChildChange(changeChildRemoved(key, oldChild));
          } else {
            assert(snap.isLeafNode(), "A child remove without an old child only makes sense on a leaf node");
          }
        } else if (oldChild.isEmpty()) {
          optChangeAccumulator.trackChildChange(changeChildAdded(key, newChild));
        } else {
          optChangeAccumulator.trackChildChange(changeChildChanged(key, newChild, oldChild));
        }
      }
      if (snap.isLeafNode() && newChild.isEmpty()) {
        return snap;
      } else {
        return snap.updateImmediateChild(key, newChild).withIndex(this.index_);
      }
    };
    IndexedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
      if (optChangeAccumulator != null) {
        if (!oldSnap.isLeafNode()) {
          oldSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            if (!newSnap.hasChild(key)) {
              optChangeAccumulator.trackChildChange(changeChildRemoved(key, childNode));
            }
          });
        }
        if (!newSnap.isLeafNode()) {
          newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
            if (oldSnap.hasChild(key)) {
              var oldChild = oldSnap.getImmediateChild(key);
              if (!oldChild.equals(childNode)) {
                optChangeAccumulator.trackChildChange(changeChildChanged(key, childNode, oldChild));
              }
            } else {
              optChangeAccumulator.trackChildChange(changeChildAdded(key, childNode));
            }
          });
        }
      }
      return newSnap.withIndex(this.index_);
    };
    IndexedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
      if (oldSnap.isEmpty()) {
        return ChildrenNode.EMPTY_NODE;
      } else {
        return oldSnap.updatePriority(newPriority);
      }
    };
    IndexedFilter2.prototype.filtersNodes = function() {
      return false;
    };
    IndexedFilter2.prototype.getIndexedFilter = function() {
      return this;
    };
    IndexedFilter2.prototype.getIndex = function() {
      return this.index_;
    };
    return IndexedFilter2;
  }()
);
var RangedFilter = (
  /** @class */
  function() {
    function RangedFilter2(params) {
      this.indexedFilter_ = new IndexedFilter(params.getIndex());
      this.index_ = params.getIndex();
      this.startPost_ = RangedFilter2.getStartPost_(params);
      this.endPost_ = RangedFilter2.getEndPost_(params);
    }
    RangedFilter2.prototype.getStartPost = function() {
      return this.startPost_;
    };
    RangedFilter2.prototype.getEndPost = function() {
      return this.endPost_;
    };
    RangedFilter2.prototype.matches = function(node) {
      return this.index_.compare(this.getStartPost(), node) <= 0 && this.index_.compare(node, this.getEndPost()) <= 0;
    };
    RangedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
      if (!this.matches(new NamedNode(key, newChild))) {
        newChild = ChildrenNode.EMPTY_NODE;
      }
      return this.indexedFilter_.updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
    };
    RangedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
      if (newSnap.isLeafNode()) {
        newSnap = ChildrenNode.EMPTY_NODE;
      }
      var filtered = newSnap.withIndex(this.index_);
      filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
      var self2 = this;
      newSnap.forEachChild(PRIORITY_INDEX, function(key, childNode) {
        if (!self2.matches(new NamedNode(key, childNode))) {
          filtered = filtered.updateImmediateChild(key, ChildrenNode.EMPTY_NODE);
        }
      });
      return this.indexedFilter_.updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    RangedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
      return oldSnap;
    };
    RangedFilter2.prototype.filtersNodes = function() {
      return true;
    };
    RangedFilter2.prototype.getIndexedFilter = function() {
      return this.indexedFilter_;
    };
    RangedFilter2.prototype.getIndex = function() {
      return this.index_;
    };
    RangedFilter2.getStartPost_ = function(params) {
      if (params.hasStart()) {
        var startName = params.getIndexStartName();
        return params.getIndex().makePost(params.getIndexStartValue(), startName);
      } else {
        return params.getIndex().minPost();
      }
    };
    RangedFilter2.getEndPost_ = function(params) {
      if (params.hasEnd()) {
        var endName = params.getIndexEndName();
        return params.getIndex().makePost(params.getIndexEndValue(), endName);
      } else {
        return params.getIndex().maxPost();
      }
    };
    return RangedFilter2;
  }()
);
var LimitedFilter = (
  /** @class */
  function() {
    function LimitedFilter2(params) {
      this.rangedFilter_ = new RangedFilter(params);
      this.index_ = params.getIndex();
      this.limit_ = params.getLimit();
      this.reverse_ = !params.isViewFromLeft();
    }
    LimitedFilter2.prototype.updateChild = function(snap, key, newChild, affectedPath, source, optChangeAccumulator) {
      if (!this.rangedFilter_.matches(new NamedNode(key, newChild))) {
        newChild = ChildrenNode.EMPTY_NODE;
      }
      if (snap.getImmediateChild(key).equals(newChild)) {
        return snap;
      } else if (snap.numChildren() < this.limit_) {
        return this.rangedFilter_.getIndexedFilter().updateChild(snap, key, newChild, affectedPath, source, optChangeAccumulator);
      } else {
        return this.fullLimitUpdateChild_(snap, key, newChild, source, optChangeAccumulator);
      }
    };
    LimitedFilter2.prototype.updateFullNode = function(oldSnap, newSnap, optChangeAccumulator) {
      var filtered;
      if (newSnap.isLeafNode() || newSnap.isEmpty()) {
        filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
      } else {
        if (this.limit_ * 2 < newSnap.numChildren() && newSnap.isIndexed(this.index_)) {
          filtered = ChildrenNode.EMPTY_NODE.withIndex(this.index_);
          var iterator = void 0;
          if (this.reverse_) {
            iterator = newSnap.getReverseIteratorFrom(this.rangedFilter_.getEndPost(), this.index_);
          } else {
            iterator = newSnap.getIteratorFrom(this.rangedFilter_.getStartPost(), this.index_);
          }
          var count = 0;
          while (iterator.hasNext() && count < this.limit_) {
            var next = iterator.getNext();
            var inRange = void 0;
            if (this.reverse_) {
              inRange = this.index_.compare(this.rangedFilter_.getStartPost(), next) <= 0;
            } else {
              inRange = this.index_.compare(next, this.rangedFilter_.getEndPost()) <= 0;
            }
            if (inRange) {
              filtered = filtered.updateImmediateChild(next.name, next.node);
              count++;
            } else {
              break;
            }
          }
        } else {
          filtered = newSnap.withIndex(this.index_);
          filtered = filtered.updatePriority(ChildrenNode.EMPTY_NODE);
          var startPost = void 0;
          var endPost = void 0;
          var cmp = void 0;
          var iterator = void 0;
          if (this.reverse_) {
            iterator = filtered.getReverseIterator(this.index_);
            startPost = this.rangedFilter_.getEndPost();
            endPost = this.rangedFilter_.getStartPost();
            var indexCompare_1 = this.index_.getCompare();
            cmp = function(a, b) {
              return indexCompare_1(b, a);
            };
          } else {
            iterator = filtered.getIterator(this.index_);
            startPost = this.rangedFilter_.getStartPost();
            endPost = this.rangedFilter_.getEndPost();
            cmp = this.index_.getCompare();
          }
          var count = 0;
          var foundStartPost = false;
          while (iterator.hasNext()) {
            var next = iterator.getNext();
            if (!foundStartPost && cmp(startPost, next) <= 0) {
              foundStartPost = true;
            }
            var inRange = foundStartPost && count < this.limit_ && cmp(next, endPost) <= 0;
            if (inRange) {
              count++;
            } else {
              filtered = filtered.updateImmediateChild(next.name, ChildrenNode.EMPTY_NODE);
            }
          }
        }
      }
      return this.rangedFilter_.getIndexedFilter().updateFullNode(oldSnap, filtered, optChangeAccumulator);
    };
    LimitedFilter2.prototype.updatePriority = function(oldSnap, newPriority) {
      return oldSnap;
    };
    LimitedFilter2.prototype.filtersNodes = function() {
      return true;
    };
    LimitedFilter2.prototype.getIndexedFilter = function() {
      return this.rangedFilter_.getIndexedFilter();
    };
    LimitedFilter2.prototype.getIndex = function() {
      return this.index_;
    };
    LimitedFilter2.prototype.fullLimitUpdateChild_ = function(snap, childKey, childSnap, source, changeAccumulator) {
      var cmp;
      if (this.reverse_) {
        var indexCmp_1 = this.index_.getCompare();
        cmp = function(a, b) {
          return indexCmp_1(b, a);
        };
      } else {
        cmp = this.index_.getCompare();
      }
      var oldEventCache = snap;
      assert(oldEventCache.numChildren() === this.limit_, "");
      var newChildNamedNode = new NamedNode(childKey, childSnap);
      var windowBoundary = this.reverse_ ? oldEventCache.getFirstChild(this.index_) : oldEventCache.getLastChild(this.index_);
      var inRange = this.rangedFilter_.matches(newChildNamedNode);
      if (oldEventCache.hasChild(childKey)) {
        var oldChildSnap = oldEventCache.getImmediateChild(childKey);
        var nextChild = source.getChildAfterChild(this.index_, windowBoundary, this.reverse_);
        while (nextChild != null && (nextChild.name === childKey || oldEventCache.hasChild(nextChild.name))) {
          nextChild = source.getChildAfterChild(this.index_, nextChild, this.reverse_);
        }
        var compareNext = nextChild == null ? 1 : cmp(nextChild, newChildNamedNode);
        var remainsInWindow = inRange && !childSnap.isEmpty() && compareNext >= 0;
        if (remainsInWindow) {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildChanged(childKey, childSnap, oldChildSnap));
          }
          return oldEventCache.updateImmediateChild(childKey, childSnap);
        } else {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildRemoved(childKey, oldChildSnap));
          }
          var newEventCache = oldEventCache.updateImmediateChild(childKey, ChildrenNode.EMPTY_NODE);
          var nextChildInRange = nextChild != null && this.rangedFilter_.matches(nextChild);
          if (nextChildInRange) {
            if (changeAccumulator != null) {
              changeAccumulator.trackChildChange(changeChildAdded(nextChild.name, nextChild.node));
            }
            return newEventCache.updateImmediateChild(nextChild.name, nextChild.node);
          } else {
            return newEventCache;
          }
        }
      } else if (childSnap.isEmpty()) {
        return snap;
      } else if (inRange) {
        if (cmp(windowBoundary, newChildNamedNode) >= 0) {
          if (changeAccumulator != null) {
            changeAccumulator.trackChildChange(changeChildRemoved(windowBoundary.name, windowBoundary.node));
            changeAccumulator.trackChildChange(changeChildAdded(childKey, childSnap));
          }
          return oldEventCache.updateImmediateChild(childKey, childSnap).updateImmediateChild(windowBoundary.name, ChildrenNode.EMPTY_NODE);
        } else {
          return snap;
        }
      } else {
        return snap;
      }
    };
    return LimitedFilter2;
  }()
);
var QueryParams = (
  /** @class */
  function() {
    function QueryParams2() {
      this.limitSet_ = false;
      this.startSet_ = false;
      this.startNameSet_ = false;
      this.startAfterSet_ = false;
      this.endSet_ = false;
      this.endNameSet_ = false;
      this.endBeforeSet_ = false;
      this.limit_ = 0;
      this.viewFrom_ = "";
      this.indexStartValue_ = null;
      this.indexStartName_ = "";
      this.indexEndValue_ = null;
      this.indexEndName_ = "";
      this.index_ = PRIORITY_INDEX;
    }
    QueryParams2.prototype.hasStart = function() {
      return this.startSet_;
    };
    QueryParams2.prototype.hasStartAfter = function() {
      return this.startAfterSet_;
    };
    QueryParams2.prototype.hasEndBefore = function() {
      return this.endBeforeSet_;
    };
    QueryParams2.prototype.isViewFromLeft = function() {
      if (this.viewFrom_ === "") {
        return this.startSet_;
      } else {
        return this.viewFrom_ === "l";
      }
    };
    QueryParams2.prototype.getIndexStartValue = function() {
      assert(this.startSet_, "Only valid if start has been set");
      return this.indexStartValue_;
    };
    QueryParams2.prototype.getIndexStartName = function() {
      assert(this.startSet_, "Only valid if start has been set");
      if (this.startNameSet_) {
        return this.indexStartName_;
      } else {
        return MIN_NAME;
      }
    };
    QueryParams2.prototype.hasEnd = function() {
      return this.endSet_;
    };
    QueryParams2.prototype.getIndexEndValue = function() {
      assert(this.endSet_, "Only valid if end has been set");
      return this.indexEndValue_;
    };
    QueryParams2.prototype.getIndexEndName = function() {
      assert(this.endSet_, "Only valid if end has been set");
      if (this.endNameSet_) {
        return this.indexEndName_;
      } else {
        return MAX_NAME;
      }
    };
    QueryParams2.prototype.hasLimit = function() {
      return this.limitSet_;
    };
    QueryParams2.prototype.hasAnchoredLimit = function() {
      return this.limitSet_ && this.viewFrom_ !== "";
    };
    QueryParams2.prototype.getLimit = function() {
      assert(this.limitSet_, "Only valid if limit has been set");
      return this.limit_;
    };
    QueryParams2.prototype.getIndex = function() {
      return this.index_;
    };
    QueryParams2.prototype.loadsAllData = function() {
      return !(this.startSet_ || this.endSet_ || this.limitSet_);
    };
    QueryParams2.prototype.isDefault = function() {
      return this.loadsAllData() && this.index_ === PRIORITY_INDEX;
    };
    QueryParams2.prototype.copy = function() {
      var copy = new QueryParams2();
      copy.limitSet_ = this.limitSet_;
      copy.limit_ = this.limit_;
      copy.startSet_ = this.startSet_;
      copy.indexStartValue_ = this.indexStartValue_;
      copy.startNameSet_ = this.startNameSet_;
      copy.indexStartName_ = this.indexStartName_;
      copy.endSet_ = this.endSet_;
      copy.indexEndValue_ = this.indexEndValue_;
      copy.endNameSet_ = this.endNameSet_;
      copy.indexEndName_ = this.indexEndName_;
      copy.index_ = this.index_;
      copy.viewFrom_ = this.viewFrom_;
      return copy;
    };
    return QueryParams2;
  }()
);
function queryParamsGetNodeFilter(queryParams) {
  if (queryParams.loadsAllData()) {
    return new IndexedFilter(queryParams.getIndex());
  } else if (queryParams.hasLimit()) {
    return new LimitedFilter(queryParams);
  } else {
    return new RangedFilter(queryParams);
  }
}
function queryParamsLimitToFirst(queryParams, newLimit) {
  var newParams = queryParams.copy();
  newParams.limitSet_ = true;
  newParams.limit_ = newLimit;
  newParams.viewFrom_ = "l";
  return newParams;
}
function queryParamsLimitToLast(queryParams, newLimit) {
  var newParams = queryParams.copy();
  newParams.limitSet_ = true;
  newParams.limit_ = newLimit;
  newParams.viewFrom_ = "r";
  return newParams;
}
function queryParamsStartAt(queryParams, indexValue, key) {
  var newParams = queryParams.copy();
  newParams.startSet_ = true;
  if (indexValue === void 0) {
    indexValue = null;
  }
  newParams.indexStartValue_ = indexValue;
  if (key != null) {
    newParams.startNameSet_ = true;
    newParams.indexStartName_ = key;
  } else {
    newParams.startNameSet_ = false;
    newParams.indexStartName_ = "";
  }
  return newParams;
}
function queryParamsStartAfter(queryParams, indexValue, key) {
  var params;
  if (queryParams.index_ === KEY_INDEX) {
    if (typeof indexValue === "string") {
      indexValue = successor(indexValue);
    }
    params = queryParamsStartAt(queryParams, indexValue, key);
  } else {
    var childKey = void 0;
    if (key == null) {
      childKey = MAX_NAME;
    } else {
      childKey = successor(key);
    }
    params = queryParamsStartAt(queryParams, indexValue, childKey);
  }
  params.startAfterSet_ = true;
  return params;
}
function queryParamsEndAt(queryParams, indexValue, key) {
  var newParams = queryParams.copy();
  newParams.endSet_ = true;
  if (indexValue === void 0) {
    indexValue = null;
  }
  newParams.indexEndValue_ = indexValue;
  if (key !== void 0) {
    newParams.endNameSet_ = true;
    newParams.indexEndName_ = key;
  } else {
    newParams.endNameSet_ = false;
    newParams.indexEndName_ = "";
  }
  return newParams;
}
function queryParamsEndBefore(queryParams, indexValue, key) {
  var childKey;
  var params;
  if (queryParams.index_ === KEY_INDEX) {
    if (typeof indexValue === "string") {
      indexValue = predecessor(indexValue);
    }
    params = queryParamsEndAt(queryParams, indexValue, key);
  } else {
    if (key == null) {
      childKey = MIN_NAME;
    } else {
      childKey = predecessor(key);
    }
    params = queryParamsEndAt(queryParams, indexValue, childKey);
  }
  params.endBeforeSet_ = true;
  return params;
}
function queryParamsOrderBy(queryParams, index) {
  var newParams = queryParams.copy();
  newParams.index_ = index;
  return newParams;
}
function queryParamsToRestQueryStringParameters(queryParams) {
  var qs = {};
  if (queryParams.isDefault()) {
    return qs;
  }
  var orderBy;
  if (queryParams.index_ === PRIORITY_INDEX) {
    orderBy = "$priority";
  } else if (queryParams.index_ === VALUE_INDEX) {
    orderBy = "$value";
  } else if (queryParams.index_ === KEY_INDEX) {
    orderBy = "$key";
  } else {
    assert(queryParams.index_ instanceof PathIndex, "Unrecognized index type!");
    orderBy = queryParams.index_.toString();
  }
  qs[
    "orderBy"
    /* ORDER_BY */
  ] = stringify(orderBy);
  if (queryParams.startSet_) {
    qs[
      "startAt"
      /* START_AT */
    ] = stringify(queryParams.indexStartValue_);
    if (queryParams.startNameSet_) {
      qs[
        "startAt"
        /* START_AT */
      ] += "," + stringify(queryParams.indexStartName_);
    }
  }
  if (queryParams.endSet_) {
    qs[
      "endAt"
      /* END_AT */
    ] = stringify(queryParams.indexEndValue_);
    if (queryParams.endNameSet_) {
      qs[
        "endAt"
        /* END_AT */
      ] += "," + stringify(queryParams.indexEndName_);
    }
  }
  if (queryParams.limitSet_) {
    if (queryParams.isViewFromLeft()) {
      qs[
        "limitToFirst"
        /* LIMIT_TO_FIRST */
      ] = queryParams.limit_;
    } else {
      qs[
        "limitToLast"
        /* LIMIT_TO_LAST */
      ] = queryParams.limit_;
    }
  }
  return qs;
}
function queryParamsGetQueryObject(queryParams) {
  var obj = {};
  if (queryParams.startSet_) {
    obj[
      "sp"
      /* INDEX_START_VALUE */
    ] = queryParams.indexStartValue_;
    if (queryParams.startNameSet_) {
      obj[
        "sn"
        /* INDEX_START_NAME */
      ] = queryParams.indexStartName_;
    }
  }
  if (queryParams.endSet_) {
    obj[
      "ep"
      /* INDEX_END_VALUE */
    ] = queryParams.indexEndValue_;
    if (queryParams.endNameSet_) {
      obj[
        "en"
        /* INDEX_END_NAME */
      ] = queryParams.indexEndName_;
    }
  }
  if (queryParams.limitSet_) {
    obj[
      "l"
      /* LIMIT */
    ] = queryParams.limit_;
    var viewFrom = queryParams.viewFrom_;
    if (viewFrom === "") {
      if (queryParams.isViewFromLeft()) {
        viewFrom = "l";
      } else {
        viewFrom = "r";
      }
    }
    obj[
      "vf"
      /* VIEW_FROM */
    ] = viewFrom;
  }
  if (queryParams.index_ !== PRIORITY_INDEX) {
    obj[
      "i"
      /* INDEX */
    ] = queryParams.index_.toString();
  }
  return obj;
}
var ReadonlyRestClient = (
  /** @class */
  function(_super) {
    __extends(ReadonlyRestClient2, _super);
    function ReadonlyRestClient2(repoInfo_, onDataUpdate_, authTokenProvider_, appCheckTokenProvider_) {
      var _this = _super.call(this) || this;
      _this.repoInfo_ = repoInfo_;
      _this.onDataUpdate_ = onDataUpdate_;
      _this.authTokenProvider_ = authTokenProvider_;
      _this.appCheckTokenProvider_ = appCheckTokenProvider_;
      _this.log_ = logWrapper("p:rest:");
      _this.listens_ = {};
      return _this;
    }
    ReadonlyRestClient2.prototype.reportStats = function(stats2) {
      throw new Error("Method not implemented.");
    };
    ReadonlyRestClient2.getListenId_ = function(query2, tag) {
      if (tag !== void 0) {
        return "tag$" + tag;
      } else {
        assert(query2._queryParams.isDefault(), "should have a tag if it's not a default query.");
        return query2._path.toString();
      }
    };
    ReadonlyRestClient2.prototype.listen = function(query2, currentHashFn, tag, onComplete) {
      var _this = this;
      var pathString = query2._path.toString();
      this.log_("Listen called for " + pathString + " " + query2._queryIdentifier);
      var listenId = ReadonlyRestClient2.getListenId_(query2, tag);
      var thisListen = {};
      this.listens_[listenId] = thisListen;
      var queryStringParameters = queryParamsToRestQueryStringParameters(query2._queryParams);
      this.restRequest_(pathString + ".json", queryStringParameters, function(error2, result) {
        var data = result;
        if (error2 === 404) {
          data = null;
          error2 = null;
        }
        if (error2 === null) {
          _this.onDataUpdate_(
            pathString,
            data,
            /*isMerge=*/
            false,
            tag
          );
        }
        if (safeGet(_this.listens_, listenId) === thisListen) {
          var status_1;
          if (!error2) {
            status_1 = "ok";
          } else if (error2 === 401) {
            status_1 = "permission_denied";
          } else {
            status_1 = "rest_error:" + error2;
          }
          onComplete(status_1, null);
        }
      });
    };
    ReadonlyRestClient2.prototype.unlisten = function(query2, tag) {
      var listenId = ReadonlyRestClient2.getListenId_(query2, tag);
      delete this.listens_[listenId];
    };
    ReadonlyRestClient2.prototype.get = function(query2) {
      var _this = this;
      var queryStringParameters = queryParamsToRestQueryStringParameters(query2._queryParams);
      var pathString = query2._path.toString();
      var deferred = new Deferred();
      this.restRequest_(pathString + ".json", queryStringParameters, function(error2, result) {
        var data = result;
        if (error2 === 404) {
          data = null;
          error2 = null;
        }
        if (error2 === null) {
          _this.onDataUpdate_(
            pathString,
            data,
            /*isMerge=*/
            false,
            /*tag=*/
            null
          );
          deferred.resolve(data);
        } else {
          deferred.reject(new Error(data));
        }
      });
      return deferred.promise;
    };
    ReadonlyRestClient2.prototype.refreshAuthToken = function(token) {
    };
    ReadonlyRestClient2.prototype.restRequest_ = function(pathString, queryStringParameters, callback) {
      var _this = this;
      if (queryStringParameters === void 0) {
        queryStringParameters = {};
      }
      queryStringParameters["format"] = "export";
      return Promise.all([
        this.authTokenProvider_.getToken(
          /*forceRefresh=*/
          false
        ),
        this.appCheckTokenProvider_.getToken(
          /*forceRefresh=*/
          false
        )
      ]).then(function(_a7) {
        var _b = __read(_a7, 2), authToken = _b[0], appCheckToken = _b[1];
        if (authToken && authToken.accessToken) {
          queryStringParameters["auth"] = authToken.accessToken;
        }
        if (appCheckToken && appCheckToken.token) {
          queryStringParameters["ac"] = appCheckToken.token;
        }
        var url = (_this.repoInfo_.secure ? "https://" : "http://") + _this.repoInfo_.host + pathString + "?ns=" + _this.repoInfo_.namespace + querystring(queryStringParameters);
        _this.log_("Sending REST request for " + url);
        var xhr = new XMLHttpRequest();
        xhr.onreadystatechange = function() {
          if (callback && xhr.readyState === 4) {
            _this.log_("REST Response for " + url + " received. status:", xhr.status, "response:", xhr.responseText);
            var res = null;
            if (xhr.status >= 200 && xhr.status < 300) {
              try {
                res = jsonEval(xhr.responseText);
              } catch (e) {
                warn("Failed to parse JSON response for " + url + ": " + xhr.responseText);
              }
              callback(null, res);
            } else {
              if (xhr.status !== 401 && xhr.status !== 404) {
                warn("Got unsuccessful REST response for " + url + " Status: " + xhr.status);
              }
              callback(xhr.status);
            }
            callback = null;
          }
        };
        xhr.open(
          "GET",
          url,
          /*asynchronous=*/
          true
        );
        xhr.send();
      });
    };
    return ReadonlyRestClient2;
  }(ServerActions)
);
var SnapshotHolder = (
  /** @class */
  function() {
    function SnapshotHolder2() {
      this.rootNode_ = ChildrenNode.EMPTY_NODE;
    }
    SnapshotHolder2.prototype.getNode = function(path) {
      return this.rootNode_.getChild(path);
    };
    SnapshotHolder2.prototype.updateSnapshot = function(path, newSnapshotNode) {
      this.rootNode_ = this.rootNode_.updateChild(path, newSnapshotNode);
    };
    return SnapshotHolder2;
  }()
);
function newSparseSnapshotTree() {
  return {
    value: null,
    children: /* @__PURE__ */ new Map()
  };
}
function sparseSnapshotTreeRemember(sparseSnapshotTree, path, data) {
  if (pathIsEmpty(path)) {
    sparseSnapshotTree.value = data;
    sparseSnapshotTree.children.clear();
  } else if (sparseSnapshotTree.value !== null) {
    sparseSnapshotTree.value = sparseSnapshotTree.value.updateChild(path, data);
  } else {
    var childKey = pathGetFront(path);
    if (!sparseSnapshotTree.children.has(childKey)) {
      sparseSnapshotTree.children.set(childKey, newSparseSnapshotTree());
    }
    var child3 = sparseSnapshotTree.children.get(childKey);
    path = pathPopFront(path);
    sparseSnapshotTreeRemember(child3, path, data);
  }
}
function sparseSnapshotTreeForget(sparseSnapshotTree, path) {
  if (pathIsEmpty(path)) {
    sparseSnapshotTree.value = null;
    sparseSnapshotTree.children.clear();
    return true;
  } else {
    if (sparseSnapshotTree.value !== null) {
      if (sparseSnapshotTree.value.isLeafNode()) {
        return false;
      } else {
        var value = sparseSnapshotTree.value;
        sparseSnapshotTree.value = null;
        value.forEachChild(PRIORITY_INDEX, function(key, tree) {
          sparseSnapshotTreeRemember(sparseSnapshotTree, new Path(key), tree);
        });
        return sparseSnapshotTreeForget(sparseSnapshotTree, path);
      }
    } else if (sparseSnapshotTree.children.size > 0) {
      var childKey = pathGetFront(path);
      path = pathPopFront(path);
      if (sparseSnapshotTree.children.has(childKey)) {
        var safeToRemove = sparseSnapshotTreeForget(sparseSnapshotTree.children.get(childKey), path);
        if (safeToRemove) {
          sparseSnapshotTree.children.delete(childKey);
        }
      }
      return sparseSnapshotTree.children.size === 0;
    } else {
      return true;
    }
  }
}
function sparseSnapshotTreeForEachTree(sparseSnapshotTree, prefixPath, func) {
  if (sparseSnapshotTree.value !== null) {
    func(prefixPath, sparseSnapshotTree.value);
  } else {
    sparseSnapshotTreeForEachChild(sparseSnapshotTree, function(key, tree) {
      var path = new Path(prefixPath.toString() + "/" + key);
      sparseSnapshotTreeForEachTree(tree, path, func);
    });
  }
}
function sparseSnapshotTreeForEachChild(sparseSnapshotTree, func) {
  sparseSnapshotTree.children.forEach(function(tree, key) {
    func(key, tree);
  });
}
var StatsListener = (
  /** @class */
  function() {
    function StatsListener2(collection_) {
      this.collection_ = collection_;
      this.last_ = null;
    }
    StatsListener2.prototype.get = function() {
      var newStats = this.collection_.get();
      var delta = __assign({}, newStats);
      if (this.last_) {
        each(this.last_, function(stat, value) {
          delta[stat] = delta[stat] - value;
        });
      }
      this.last_ = newStats;
      return delta;
    };
    return StatsListener2;
  }()
);
var FIRST_STATS_MIN_TIME = 10 * 1e3;
var FIRST_STATS_MAX_TIME = 30 * 1e3;
var REPORT_STATS_INTERVAL = 5 * 60 * 1e3;
var StatsReporter = (
  /** @class */
  function() {
    function StatsReporter2(collection, server_) {
      this.server_ = server_;
      this.statsToReport_ = {};
      this.statsListener_ = new StatsListener(collection);
      var timeout = FIRST_STATS_MIN_TIME + (FIRST_STATS_MAX_TIME - FIRST_STATS_MIN_TIME) * Math.random();
      setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(timeout));
    }
    StatsReporter2.prototype.reportStats_ = function() {
      var _this = this;
      var stats2 = this.statsListener_.get();
      var reportedStats = {};
      var haveStatsToReport = false;
      each(stats2, function(stat, value) {
        if (value > 0 && contains(_this.statsToReport_, stat)) {
          reportedStats[stat] = value;
          haveStatsToReport = true;
        }
      });
      if (haveStatsToReport) {
        this.server_.reportStats(reportedStats);
      }
      setTimeoutNonBlocking(this.reportStats_.bind(this), Math.floor(Math.random() * 2 * REPORT_STATS_INTERVAL));
    };
    return StatsReporter2;
  }()
);
function statsReporterIncludeStat(reporter, stat) {
  reporter.statsToReport_[stat] = true;
}
var OperationType;
(function(OperationType2) {
  OperationType2[OperationType2["OVERWRITE"] = 0] = "OVERWRITE";
  OperationType2[OperationType2["MERGE"] = 1] = "MERGE";
  OperationType2[OperationType2["ACK_USER_WRITE"] = 2] = "ACK_USER_WRITE";
  OperationType2[OperationType2["LISTEN_COMPLETE"] = 3] = "LISTEN_COMPLETE";
})(OperationType || (OperationType = {}));
function newOperationSourceUser() {
  return {
    fromUser: true,
    fromServer: false,
    queryId: null,
    tagged: false
  };
}
function newOperationSourceServer() {
  return {
    fromUser: false,
    fromServer: true,
    queryId: null,
    tagged: false
  };
}
function newOperationSourceServerTaggedQuery(queryId) {
  return {
    fromUser: false,
    fromServer: true,
    queryId,
    tagged: true
  };
}
var AckUserWrite = (
  /** @class */
  function() {
    function AckUserWrite2(path, affectedTree, revert) {
      this.path = path;
      this.affectedTree = affectedTree;
      this.revert = revert;
      this.type = OperationType.ACK_USER_WRITE;
      this.source = newOperationSourceUser();
    }
    AckUserWrite2.prototype.operationForChild = function(childName) {
      if (!pathIsEmpty(this.path)) {
        assert(pathGetFront(this.path) === childName, "operationForChild called for unrelated child.");
        return new AckUserWrite2(pathPopFront(this.path), this.affectedTree, this.revert);
      } else if (this.affectedTree.value != null) {
        assert(this.affectedTree.children.isEmpty(), "affectedTree should not have overlapping affected paths.");
        return this;
      } else {
        var childTree = this.affectedTree.subtree(new Path(childName));
        return new AckUserWrite2(newEmptyPath(), childTree, this.revert);
      }
    };
    return AckUserWrite2;
  }()
);
var ListenComplete = (
  /** @class */
  function() {
    function ListenComplete2(source, path) {
      this.source = source;
      this.path = path;
      this.type = OperationType.LISTEN_COMPLETE;
    }
    ListenComplete2.prototype.operationForChild = function(childName) {
      if (pathIsEmpty(this.path)) {
        return new ListenComplete2(this.source, newEmptyPath());
      } else {
        return new ListenComplete2(this.source, pathPopFront(this.path));
      }
    };
    return ListenComplete2;
  }()
);
var Overwrite = (
  /** @class */
  function() {
    function Overwrite2(source, path, snap) {
      this.source = source;
      this.path = path;
      this.snap = snap;
      this.type = OperationType.OVERWRITE;
    }
    Overwrite2.prototype.operationForChild = function(childName) {
      if (pathIsEmpty(this.path)) {
        return new Overwrite2(this.source, newEmptyPath(), this.snap.getImmediateChild(childName));
      } else {
        return new Overwrite2(this.source, pathPopFront(this.path), this.snap);
      }
    };
    return Overwrite2;
  }()
);
var Merge = (
  /** @class */
  function() {
    function Merge2(source, path, children) {
      this.source = source;
      this.path = path;
      this.children = children;
      this.type = OperationType.MERGE;
    }
    Merge2.prototype.operationForChild = function(childName) {
      if (pathIsEmpty(this.path)) {
        var childTree = this.children.subtree(new Path(childName));
        if (childTree.isEmpty()) {
          return null;
        } else if (childTree.value) {
          return new Overwrite(this.source, newEmptyPath(), childTree.value);
        } else {
          return new Merge2(this.source, newEmptyPath(), childTree);
        }
      } else {
        assert(pathGetFront(this.path) === childName, "Can't get a merge for a child not on the path of the operation");
        return new Merge2(this.source, pathPopFront(this.path), this.children);
      }
    };
    Merge2.prototype.toString = function() {
      return "Operation(" + this.path + ": " + this.source.toString() + " merge: " + this.children.toString() + ")";
    };
    return Merge2;
  }()
);
var CacheNode = (
  /** @class */
  function() {
    function CacheNode2(node_, fullyInitialized_, filtered_) {
      this.node_ = node_;
      this.fullyInitialized_ = fullyInitialized_;
      this.filtered_ = filtered_;
    }
    CacheNode2.prototype.isFullyInitialized = function() {
      return this.fullyInitialized_;
    };
    CacheNode2.prototype.isFiltered = function() {
      return this.filtered_;
    };
    CacheNode2.prototype.isCompleteForPath = function(path) {
      if (pathIsEmpty(path)) {
        return this.isFullyInitialized() && !this.filtered_;
      }
      var childKey = pathGetFront(path);
      return this.isCompleteForChild(childKey);
    };
    CacheNode2.prototype.isCompleteForChild = function(key) {
      return this.isFullyInitialized() && !this.filtered_ || this.node_.hasChild(key);
    };
    CacheNode2.prototype.getNode = function() {
      return this.node_;
    };
    return CacheNode2;
  }()
);
var EventGenerator = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventGenerator2(query_) {
      this.query_ = query_;
      this.index_ = this.query_._queryParams.getIndex();
    }
    return EventGenerator2;
  }()
);
function eventGeneratorGenerateEventsForChanges(eventGenerator, changes, eventCache, eventRegistrations) {
  var events = [];
  var moves = [];
  changes.forEach(function(change) {
    if (change.type === "child_changed" && eventGenerator.index_.indexedValueChanged(change.oldSnap, change.snapshotNode)) {
      moves.push(changeChildMoved(change.childName, change.snapshotNode));
    }
  });
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_removed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_added", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_moved", moves, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "child_changed", changes, eventRegistrations, eventCache);
  eventGeneratorGenerateEventsForType(eventGenerator, events, "value", changes, eventRegistrations, eventCache);
  return events;
}
function eventGeneratorGenerateEventsForType(eventGenerator, events, eventType, changes, registrations, eventCache) {
  var filteredChanges = changes.filter(function(change) {
    return change.type === eventType;
  });
  filteredChanges.sort(function(a, b) {
    return eventGeneratorCompareChanges(eventGenerator, a, b);
  });
  filteredChanges.forEach(function(change) {
    var materializedChange = eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache);
    registrations.forEach(function(registration) {
      if (registration.respondsTo(change.type)) {
        events.push(registration.createEvent(materializedChange, eventGenerator.query_));
      }
    });
  });
}
function eventGeneratorMaterializeSingleChange(eventGenerator, change, eventCache) {
  if (change.type === "value" || change.type === "child_removed") {
    return change;
  } else {
    change.prevName = eventCache.getPredecessorChildName(change.childName, change.snapshotNode, eventGenerator.index_);
    return change;
  }
}
function eventGeneratorCompareChanges(eventGenerator, a, b) {
  if (a.childName == null || b.childName == null) {
    throw assertionError("Should only compare child_ events.");
  }
  var aWrapped = new NamedNode(a.childName, a.snapshotNode);
  var bWrapped = new NamedNode(b.childName, b.snapshotNode);
  return eventGenerator.index_.compare(aWrapped, bWrapped);
}
function newViewCache(eventCache, serverCache) {
  return { eventCache, serverCache };
}
function viewCacheUpdateEventSnap(viewCache, eventSnap, complete, filtered) {
  return newViewCache(new CacheNode(eventSnap, complete, filtered), viewCache.serverCache);
}
function viewCacheUpdateServerSnap(viewCache, serverSnap, complete, filtered) {
  return newViewCache(viewCache.eventCache, new CacheNode(serverSnap, complete, filtered));
}
function viewCacheGetCompleteEventSnap(viewCache) {
  return viewCache.eventCache.isFullyInitialized() ? viewCache.eventCache.getNode() : null;
}
function viewCacheGetCompleteServerSnap(viewCache) {
  return viewCache.serverCache.isFullyInitialized() ? viewCache.serverCache.getNode() : null;
}
var emptyChildrenSingleton;
var EmptyChildren = function() {
  if (!emptyChildrenSingleton) {
    emptyChildrenSingleton = new SortedMap(stringCompare);
  }
  return emptyChildrenSingleton;
};
var ImmutableTree = (
  /** @class */
  function() {
    function ImmutableTree2(value, children) {
      if (children === void 0) {
        children = EmptyChildren();
      }
      this.value = value;
      this.children = children;
    }
    ImmutableTree2.fromObject = function(obj) {
      var tree = new ImmutableTree2(null);
      each(obj, function(childPath, childSnap) {
        tree = tree.set(new Path(childPath), childSnap);
      });
      return tree;
    };
    ImmutableTree2.prototype.isEmpty = function() {
      return this.value === null && this.children.isEmpty();
    };
    ImmutableTree2.prototype.findRootMostMatchingPathAndValue = function(relativePath, predicate) {
      if (this.value != null && predicate(this.value)) {
        return { path: newEmptyPath(), value: this.value };
      } else {
        if (pathIsEmpty(relativePath)) {
          return null;
        } else {
          var front = pathGetFront(relativePath);
          var child3 = this.children.get(front);
          if (child3 !== null) {
            var childExistingPathAndValue = child3.findRootMostMatchingPathAndValue(pathPopFront(relativePath), predicate);
            if (childExistingPathAndValue != null) {
              var fullPath = pathChild(new Path(front), childExistingPathAndValue.path);
              return { path: fullPath, value: childExistingPathAndValue.value };
            } else {
              return null;
            }
          } else {
            return null;
          }
        }
      }
    };
    ImmutableTree2.prototype.findRootMostValueAndPath = function(relativePath) {
      return this.findRootMostMatchingPathAndValue(relativePath, function() {
        return true;
      });
    };
    ImmutableTree2.prototype.subtree = function(relativePath) {
      if (pathIsEmpty(relativePath)) {
        return this;
      } else {
        var front = pathGetFront(relativePath);
        var childTree = this.children.get(front);
        if (childTree !== null) {
          return childTree.subtree(pathPopFront(relativePath));
        } else {
          return new ImmutableTree2(null);
        }
      }
    };
    ImmutableTree2.prototype.set = function(relativePath, toSet) {
      if (pathIsEmpty(relativePath)) {
        return new ImmutableTree2(toSet, this.children);
      } else {
        var front = pathGetFront(relativePath);
        var child3 = this.children.get(front) || new ImmutableTree2(null);
        var newChild = child3.set(pathPopFront(relativePath), toSet);
        var newChildren = this.children.insert(front, newChild);
        return new ImmutableTree2(this.value, newChildren);
      }
    };
    ImmutableTree2.prototype.remove = function(relativePath) {
      if (pathIsEmpty(relativePath)) {
        if (this.children.isEmpty()) {
          return new ImmutableTree2(null);
        } else {
          return new ImmutableTree2(null, this.children);
        }
      } else {
        var front = pathGetFront(relativePath);
        var child3 = this.children.get(front);
        if (child3) {
          var newChild = child3.remove(pathPopFront(relativePath));
          var newChildren = void 0;
          if (newChild.isEmpty()) {
            newChildren = this.children.remove(front);
          } else {
            newChildren = this.children.insert(front, newChild);
          }
          if (this.value === null && newChildren.isEmpty()) {
            return new ImmutableTree2(null);
          } else {
            return new ImmutableTree2(this.value, newChildren);
          }
        } else {
          return this;
        }
      }
    };
    ImmutableTree2.prototype.get = function(relativePath) {
      if (pathIsEmpty(relativePath)) {
        return this.value;
      } else {
        var front = pathGetFront(relativePath);
        var child3 = this.children.get(front);
        if (child3) {
          return child3.get(pathPopFront(relativePath));
        } else {
          return null;
        }
      }
    };
    ImmutableTree2.prototype.setTree = function(relativePath, newTree) {
      if (pathIsEmpty(relativePath)) {
        return newTree;
      } else {
        var front = pathGetFront(relativePath);
        var child3 = this.children.get(front) || new ImmutableTree2(null);
        var newChild = child3.setTree(pathPopFront(relativePath), newTree);
        var newChildren = void 0;
        if (newChild.isEmpty()) {
          newChildren = this.children.remove(front);
        } else {
          newChildren = this.children.insert(front, newChild);
        }
        return new ImmutableTree2(this.value, newChildren);
      }
    };
    ImmutableTree2.prototype.fold = function(fn) {
      return this.fold_(newEmptyPath(), fn);
    };
    ImmutableTree2.prototype.fold_ = function(pathSoFar, fn) {
      var accum = {};
      this.children.inorderTraversal(function(childKey, childTree) {
        accum[childKey] = childTree.fold_(pathChild(pathSoFar, childKey), fn);
      });
      return fn(pathSoFar, this.value, accum);
    };
    ImmutableTree2.prototype.findOnPath = function(path, f) {
      return this.findOnPath_(path, newEmptyPath(), f);
    };
    ImmutableTree2.prototype.findOnPath_ = function(pathToFollow, pathSoFar, f) {
      var result = this.value ? f(pathSoFar, this.value) : false;
      if (result) {
        return result;
      } else {
        if (pathIsEmpty(pathToFollow)) {
          return null;
        } else {
          var front = pathGetFront(pathToFollow);
          var nextChild = this.children.get(front);
          if (nextChild) {
            return nextChild.findOnPath_(pathPopFront(pathToFollow), pathChild(pathSoFar, front), f);
          } else {
            return null;
          }
        }
      }
    };
    ImmutableTree2.prototype.foreachOnPath = function(path, f) {
      return this.foreachOnPath_(path, newEmptyPath(), f);
    };
    ImmutableTree2.prototype.foreachOnPath_ = function(pathToFollow, currentRelativePath, f) {
      if (pathIsEmpty(pathToFollow)) {
        return this;
      } else {
        if (this.value) {
          f(currentRelativePath, this.value);
        }
        var front = pathGetFront(pathToFollow);
        var nextChild = this.children.get(front);
        if (nextChild) {
          return nextChild.foreachOnPath_(pathPopFront(pathToFollow), pathChild(currentRelativePath, front), f);
        } else {
          return new ImmutableTree2(null);
        }
      }
    };
    ImmutableTree2.prototype.foreach = function(f) {
      this.foreach_(newEmptyPath(), f);
    };
    ImmutableTree2.prototype.foreach_ = function(currentRelativePath, f) {
      this.children.inorderTraversal(function(childName, childTree) {
        childTree.foreach_(pathChild(currentRelativePath, childName), f);
      });
      if (this.value) {
        f(currentRelativePath, this.value);
      }
    };
    ImmutableTree2.prototype.foreachChild = function(f) {
      this.children.inorderTraversal(function(childName, childTree) {
        if (childTree.value) {
          f(childName, childTree.value);
        }
      });
    };
    return ImmutableTree2;
  }()
);
var CompoundWrite = (
  /** @class */
  function() {
    function CompoundWrite2(writeTree_) {
      this.writeTree_ = writeTree_;
    }
    CompoundWrite2.empty = function() {
      return new CompoundWrite2(new ImmutableTree(null));
    };
    return CompoundWrite2;
  }()
);
function compoundWriteAddWrite(compoundWrite, path, node) {
  if (pathIsEmpty(path)) {
    return new CompoundWrite(new ImmutableTree(node));
  } else {
    var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
    if (rootmost != null) {
      var rootMostPath = rootmost.path;
      var value = rootmost.value;
      var relativePath = newRelativePath(rootMostPath, path);
      value = value.updateChild(relativePath, node);
      return new CompoundWrite(compoundWrite.writeTree_.set(rootMostPath, value));
    } else {
      var subtree = new ImmutableTree(node);
      var newWriteTree2 = compoundWrite.writeTree_.setTree(path, subtree);
      return new CompoundWrite(newWriteTree2);
    }
  }
}
function compoundWriteAddWrites(compoundWrite, path, updates) {
  var newWrite = compoundWrite;
  each(updates, function(childKey, node) {
    newWrite = compoundWriteAddWrite(newWrite, pathChild(path, childKey), node);
  });
  return newWrite;
}
function compoundWriteRemoveWrite(compoundWrite, path) {
  if (pathIsEmpty(path)) {
    return CompoundWrite.empty();
  } else {
    var newWriteTree2 = compoundWrite.writeTree_.setTree(path, new ImmutableTree(null));
    return new CompoundWrite(newWriteTree2);
  }
}
function compoundWriteHasCompleteWrite(compoundWrite, path) {
  return compoundWriteGetCompleteNode(compoundWrite, path) != null;
}
function compoundWriteGetCompleteNode(compoundWrite, path) {
  var rootmost = compoundWrite.writeTree_.findRootMostValueAndPath(path);
  if (rootmost != null) {
    return compoundWrite.writeTree_.get(rootmost.path).getChild(newRelativePath(rootmost.path, path));
  } else {
    return null;
  }
}
function compoundWriteGetCompleteChildren(compoundWrite) {
  var children = [];
  var node = compoundWrite.writeTree_.value;
  if (node != null) {
    if (!node.isLeafNode()) {
      node.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
        children.push(new NamedNode(childName, childNode));
      });
    }
  } else {
    compoundWrite.writeTree_.children.inorderTraversal(function(childName, childTree) {
      if (childTree.value != null) {
        children.push(new NamedNode(childName, childTree.value));
      }
    });
  }
  return children;
}
function compoundWriteChildCompoundWrite(compoundWrite, path) {
  if (pathIsEmpty(path)) {
    return compoundWrite;
  } else {
    var shadowingNode = compoundWriteGetCompleteNode(compoundWrite, path);
    if (shadowingNode != null) {
      return new CompoundWrite(new ImmutableTree(shadowingNode));
    } else {
      return new CompoundWrite(compoundWrite.writeTree_.subtree(path));
    }
  }
}
function compoundWriteIsEmpty(compoundWrite) {
  return compoundWrite.writeTree_.isEmpty();
}
function compoundWriteApply(compoundWrite, node) {
  return applySubtreeWrite(newEmptyPath(), compoundWrite.writeTree_, node);
}
function applySubtreeWrite(relativePath, writeTree, node) {
  if (writeTree.value != null) {
    return node.updateChild(relativePath, writeTree.value);
  } else {
    var priorityWrite_1 = null;
    writeTree.children.inorderTraversal(function(childKey, childTree) {
      if (childKey === ".priority") {
        assert(childTree.value !== null, "Priority writes must always be leaf nodes");
        priorityWrite_1 = childTree.value;
      } else {
        node = applySubtreeWrite(pathChild(relativePath, childKey), childTree, node);
      }
    });
    if (!node.getChild(relativePath).isEmpty() && priorityWrite_1 !== null) {
      node = node.updateChild(pathChild(relativePath, ".priority"), priorityWrite_1);
    }
    return node;
  }
}
function writeTreeChildWrites(writeTree, path) {
  return newWriteTreeRef(path, writeTree);
}
function writeTreeAddOverwrite(writeTree, path, snap, writeId, visible) {
  assert(writeId > writeTree.lastWriteId, "Stacking an older write on top of newer ones");
  if (visible === void 0) {
    visible = true;
  }
  writeTree.allWrites.push({
    path,
    snap,
    writeId,
    visible
  });
  if (visible) {
    writeTree.visibleWrites = compoundWriteAddWrite(writeTree.visibleWrites, path, snap);
  }
  writeTree.lastWriteId = writeId;
}
function writeTreeAddMerge(writeTree, path, changedChildren, writeId) {
  assert(writeId > writeTree.lastWriteId, "Stacking an older merge on top of newer ones");
  writeTree.allWrites.push({
    path,
    children: changedChildren,
    writeId,
    visible: true
  });
  writeTree.visibleWrites = compoundWriteAddWrites(writeTree.visibleWrites, path, changedChildren);
  writeTree.lastWriteId = writeId;
}
function writeTreeGetWrite(writeTree, writeId) {
  for (var i = 0; i < writeTree.allWrites.length; i++) {
    var record = writeTree.allWrites[i];
    if (record.writeId === writeId) {
      return record;
    }
  }
  return null;
}
function writeTreeRemoveWrite(writeTree, writeId) {
  var idx = writeTree.allWrites.findIndex(function(s) {
    return s.writeId === writeId;
  });
  assert(idx >= 0, "removeWrite called with nonexistent writeId.");
  var writeToRemove = writeTree.allWrites[idx];
  writeTree.allWrites.splice(idx, 1);
  var removedWriteWasVisible = writeToRemove.visible;
  var removedWriteOverlapsWithOtherWrites = false;
  var i = writeTree.allWrites.length - 1;
  while (removedWriteWasVisible && i >= 0) {
    var currentWrite = writeTree.allWrites[i];
    if (currentWrite.visible) {
      if (i >= idx && writeTreeRecordContainsPath_(currentWrite, writeToRemove.path)) {
        removedWriteWasVisible = false;
      } else if (pathContains(writeToRemove.path, currentWrite.path)) {
        removedWriteOverlapsWithOtherWrites = true;
      }
    }
    i--;
  }
  if (!removedWriteWasVisible) {
    return false;
  } else if (removedWriteOverlapsWithOtherWrites) {
    writeTreeResetTree_(writeTree);
    return true;
  } else {
    if (writeToRemove.snap) {
      writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, writeToRemove.path);
    } else {
      var children = writeToRemove.children;
      each(children, function(childName) {
        writeTree.visibleWrites = compoundWriteRemoveWrite(writeTree.visibleWrites, pathChild(writeToRemove.path, childName));
      });
    }
    return true;
  }
}
function writeTreeRecordContainsPath_(writeRecord, path) {
  if (writeRecord.snap) {
    return pathContains(writeRecord.path, path);
  } else {
    for (var childName in writeRecord.children) {
      if (writeRecord.children.hasOwnProperty(childName) && pathContains(pathChild(writeRecord.path, childName), path)) {
        return true;
      }
    }
    return false;
  }
}
function writeTreeResetTree_(writeTree) {
  writeTree.visibleWrites = writeTreeLayerTree_(writeTree.allWrites, writeTreeDefaultFilter_, newEmptyPath());
  if (writeTree.allWrites.length > 0) {
    writeTree.lastWriteId = writeTree.allWrites[writeTree.allWrites.length - 1].writeId;
  } else {
    writeTree.lastWriteId = -1;
  }
}
function writeTreeDefaultFilter_(write2) {
  return write2.visible;
}
function writeTreeLayerTree_(writes, filter, treeRoot) {
  var compoundWrite = CompoundWrite.empty();
  for (var i = 0; i < writes.length; ++i) {
    var write2 = writes[i];
    if (filter(write2)) {
      var writePath = write2.path;
      var relativePath = void 0;
      if (write2.snap) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrite(compoundWrite, relativePath, write2.snap);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), write2.snap.getChild(relativePath));
        } else ;
      } else if (write2.children) {
        if (pathContains(treeRoot, writePath)) {
          relativePath = newRelativePath(treeRoot, writePath);
          compoundWrite = compoundWriteAddWrites(compoundWrite, relativePath, write2.children);
        } else if (pathContains(writePath, treeRoot)) {
          relativePath = newRelativePath(writePath, treeRoot);
          if (pathIsEmpty(relativePath)) {
            compoundWrite = compoundWriteAddWrites(compoundWrite, newEmptyPath(), write2.children);
          } else {
            var child3 = safeGet(write2.children, pathGetFront(relativePath));
            if (child3) {
              var deepNode = child3.getChild(pathPopFront(relativePath));
              compoundWrite = compoundWriteAddWrite(compoundWrite, newEmptyPath(), deepNode);
            }
          }
        } else ;
      } else {
        throw assertionError("WriteRecord should have .snap or .children");
      }
    }
  }
  return compoundWrite;
}
function writeTreeCalcCompleteEventCache(writeTree, treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  if (!writeIdsToExclude && !includeHiddenWrites) {
    var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
    if (shadowingNode != null) {
      return shadowingNode;
    } else {
      var subMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
      if (compoundWriteIsEmpty(subMerge)) {
        return completeServerCache;
      } else if (completeServerCache == null && !compoundWriteHasCompleteWrite(subMerge, newEmptyPath())) {
        return null;
      } else {
        var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(subMerge, layeredCache);
      }
    }
  } else {
    var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    if (!includeHiddenWrites && compoundWriteIsEmpty(merge)) {
      return completeServerCache;
    } else {
      if (!includeHiddenWrites && completeServerCache == null && !compoundWriteHasCompleteWrite(merge, newEmptyPath())) {
        return null;
      } else {
        var filter = function(write2) {
          return (write2.visible || includeHiddenWrites) && (!writeIdsToExclude || !~writeIdsToExclude.indexOf(write2.writeId)) && (pathContains(write2.path, treePath) || pathContains(treePath, write2.path));
        };
        var mergeAtPath = writeTreeLayerTree_(writeTree.allWrites, filter, treePath);
        var layeredCache = completeServerCache || ChildrenNode.EMPTY_NODE;
        return compoundWriteApply(mergeAtPath, layeredCache);
      }
    }
  }
}
function writeTreeCalcCompleteEventChildren(writeTree, treePath, completeServerChildren) {
  var completeChildren = ChildrenNode.EMPTY_NODE;
  var topLevelSet = compoundWriteGetCompleteNode(writeTree.visibleWrites, treePath);
  if (topLevelSet) {
    if (!topLevelSet.isLeafNode()) {
      topLevelSet.forEachChild(PRIORITY_INDEX, function(childName, childSnap) {
        completeChildren = completeChildren.updateImmediateChild(childName, childSnap);
      });
    }
    return completeChildren;
  } else if (completeServerChildren) {
    var merge_1 = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    completeServerChildren.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
      var node = compoundWriteApply(compoundWriteChildCompoundWrite(merge_1, new Path(childName)), childNode);
      completeChildren = completeChildren.updateImmediateChild(childName, node);
    });
    compoundWriteGetCompleteChildren(merge_1).forEach(function(namedNode) {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  } else {
    var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
    compoundWriteGetCompleteChildren(merge).forEach(function(namedNode) {
      completeChildren = completeChildren.updateImmediateChild(namedNode.name, namedNode.node);
    });
    return completeChildren;
  }
}
function writeTreeCalcEventCacheAfterServerOverwrite(writeTree, treePath, childPath, existingEventSnap, existingServerSnap) {
  assert(existingEventSnap || existingServerSnap, "Either existingEventSnap or existingServerSnap must exist");
  var path = pathChild(treePath, childPath);
  if (compoundWriteHasCompleteWrite(writeTree.visibleWrites, path)) {
    return null;
  } else {
    var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
    if (compoundWriteIsEmpty(childMerge)) {
      return existingServerSnap.getChild(childPath);
    } else {
      return compoundWriteApply(childMerge, existingServerSnap.getChild(childPath));
    }
  }
}
function writeTreeCalcCompleteChild(writeTree, treePath, childKey, existingServerSnap) {
  var path = pathChild(treePath, childKey);
  var shadowingNode = compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
  if (shadowingNode != null) {
    return shadowingNode;
  } else {
    if (existingServerSnap.isCompleteForChild(childKey)) {
      var childMerge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, path);
      return compoundWriteApply(childMerge, existingServerSnap.getNode().getImmediateChild(childKey));
    } else {
      return null;
    }
  }
}
function writeTreeShadowingWrite(writeTree, path) {
  return compoundWriteGetCompleteNode(writeTree.visibleWrites, path);
}
function writeTreeCalcIndexedSlice(writeTree, treePath, completeServerData, startPost, count, reverse, index) {
  var toIterate;
  var merge = compoundWriteChildCompoundWrite(writeTree.visibleWrites, treePath);
  var shadowingNode = compoundWriteGetCompleteNode(merge, newEmptyPath());
  if (shadowingNode != null) {
    toIterate = shadowingNode;
  } else if (completeServerData != null) {
    toIterate = compoundWriteApply(merge, completeServerData);
  } else {
    return [];
  }
  toIterate = toIterate.withIndex(index);
  if (!toIterate.isEmpty() && !toIterate.isLeafNode()) {
    var nodes = [];
    var cmp = index.getCompare();
    var iter = reverse ? toIterate.getReverseIteratorFrom(startPost, index) : toIterate.getIteratorFrom(startPost, index);
    var next = iter.getNext();
    while (next && nodes.length < count) {
      if (cmp(next, startPost) !== 0) {
        nodes.push(next);
      }
      next = iter.getNext();
    }
    return nodes;
  } else {
    return [];
  }
}
function newWriteTree() {
  return {
    visibleWrites: CompoundWrite.empty(),
    allWrites: [],
    lastWriteId: -1
  };
}
function writeTreeRefCalcCompleteEventCache(writeTreeRef, completeServerCache, writeIdsToExclude, includeHiddenWrites) {
  return writeTreeCalcCompleteEventCache(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerCache, writeIdsToExclude, includeHiddenWrites);
}
function writeTreeRefCalcCompleteEventChildren(writeTreeRef, completeServerChildren) {
  return writeTreeCalcCompleteEventChildren(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerChildren);
}
function writeTreeRefCalcEventCacheAfterServerOverwrite(writeTreeRef, path, existingEventSnap, existingServerSnap) {
  return writeTreeCalcEventCacheAfterServerOverwrite(writeTreeRef.writeTree, writeTreeRef.treePath, path, existingEventSnap, existingServerSnap);
}
function writeTreeRefShadowingWrite(writeTreeRef, path) {
  return writeTreeShadowingWrite(writeTreeRef.writeTree, pathChild(writeTreeRef.treePath, path));
}
function writeTreeRefCalcIndexedSlice(writeTreeRef, completeServerData, startPost, count, reverse, index) {
  return writeTreeCalcIndexedSlice(writeTreeRef.writeTree, writeTreeRef.treePath, completeServerData, startPost, count, reverse, index);
}
function writeTreeRefCalcCompleteChild(writeTreeRef, childKey, existingServerCache) {
  return writeTreeCalcCompleteChild(writeTreeRef.writeTree, writeTreeRef.treePath, childKey, existingServerCache);
}
function writeTreeRefChild(writeTreeRef, childName) {
  return newWriteTreeRef(pathChild(writeTreeRef.treePath, childName), writeTreeRef.writeTree);
}
function newWriteTreeRef(path, writeTree) {
  return {
    treePath: path,
    writeTree
  };
}
var ChildChangeAccumulator = (
  /** @class */
  function() {
    function ChildChangeAccumulator2() {
      this.changeMap = /* @__PURE__ */ new Map();
    }
    ChildChangeAccumulator2.prototype.trackChildChange = function(change) {
      var type = change.type;
      var childKey = change.childName;
      assert(type === "child_added" || type === "child_changed" || type === "child_removed", "Only child changes supported for tracking");
      assert(childKey !== ".priority", "Only non-priority child changes can be tracked.");
      var oldChange = this.changeMap.get(childKey);
      if (oldChange) {
        var oldType = oldChange.type;
        if (type === "child_added" && oldType === "child_removed") {
          this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.snapshotNode));
        } else if (type === "child_removed" && oldType === "child_added") {
          this.changeMap.delete(childKey);
        } else if (type === "child_removed" && oldType === "child_changed") {
          this.changeMap.set(childKey, changeChildRemoved(childKey, oldChange.oldSnap));
        } else if (type === "child_changed" && oldType === "child_added") {
          this.changeMap.set(childKey, changeChildAdded(childKey, change.snapshotNode));
        } else if (type === "child_changed" && oldType === "child_changed") {
          this.changeMap.set(childKey, changeChildChanged(childKey, change.snapshotNode, oldChange.oldSnap));
        } else {
          throw assertionError("Illegal combination of changes: " + change + " occurred after " + oldChange);
        }
      } else {
        this.changeMap.set(childKey, change);
      }
    };
    ChildChangeAccumulator2.prototype.getChanges = function() {
      return Array.from(this.changeMap.values());
    };
    return ChildChangeAccumulator2;
  }()
);
var NoCompleteChildSource_ = (
  /** @class */
  function() {
    function NoCompleteChildSource_2() {
    }
    NoCompleteChildSource_2.prototype.getCompleteChild = function(childKey) {
      return null;
    };
    NoCompleteChildSource_2.prototype.getChildAfterChild = function(index, child3, reverse) {
      return null;
    };
    return NoCompleteChildSource_2;
  }()
);
var NO_COMPLETE_CHILD_SOURCE = new NoCompleteChildSource_();
var WriteTreeCompleteChildSource = (
  /** @class */
  function() {
    function WriteTreeCompleteChildSource2(writes_, viewCache_, optCompleteServerCache_) {
      if (optCompleteServerCache_ === void 0) {
        optCompleteServerCache_ = null;
      }
      this.writes_ = writes_;
      this.viewCache_ = viewCache_;
      this.optCompleteServerCache_ = optCompleteServerCache_;
    }
    WriteTreeCompleteChildSource2.prototype.getCompleteChild = function(childKey) {
      var node = this.viewCache_.eventCache;
      if (node.isCompleteForChild(childKey)) {
        return node.getNode().getImmediateChild(childKey);
      } else {
        var serverNode = this.optCompleteServerCache_ != null ? new CacheNode(this.optCompleteServerCache_, true, false) : this.viewCache_.serverCache;
        return writeTreeRefCalcCompleteChild(this.writes_, childKey, serverNode);
      }
    };
    WriteTreeCompleteChildSource2.prototype.getChildAfterChild = function(index, child3, reverse) {
      var completeServerData = this.optCompleteServerCache_ != null ? this.optCompleteServerCache_ : viewCacheGetCompleteServerSnap(this.viewCache_);
      var nodes = writeTreeRefCalcIndexedSlice(this.writes_, completeServerData, child3, 1, reverse, index);
      if (nodes.length === 0) {
        return null;
      } else {
        return nodes[0];
      }
    };
    return WriteTreeCompleteChildSource2;
  }()
);
function newViewProcessor(filter) {
  return { filter };
}
function viewProcessorAssertIndexed(viewProcessor, viewCache) {
  assert(viewCache.eventCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Event snap not indexed");
  assert(viewCache.serverCache.getNode().isIndexed(viewProcessor.filter.getIndex()), "Server snap not indexed");
}
function viewProcessorApplyOperation(viewProcessor, oldViewCache, operation, writesCache, completeCache) {
  var accumulator = new ChildChangeAccumulator();
  var newViewCache2, filterServerNode;
  if (operation.type === OperationType.OVERWRITE) {
    var overwrite = operation;
    if (overwrite.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, accumulator);
    } else {
      assert(overwrite.source.fromServer, "Unknown source.");
      filterServerNode = overwrite.source.tagged || oldViewCache.serverCache.isFiltered() && !pathIsEmpty(overwrite.path);
      newViewCache2 = viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, overwrite.path, overwrite.snap, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.MERGE) {
    var merge = operation;
    if (merge.source.fromUser) {
      newViewCache2 = viewProcessorApplyUserMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, accumulator);
    } else {
      assert(merge.source.fromServer, "Unknown source.");
      filterServerNode = merge.source.tagged || oldViewCache.serverCache.isFiltered();
      newViewCache2 = viewProcessorApplyServerMerge(viewProcessor, oldViewCache, merge.path, merge.children, writesCache, completeCache, filterServerNode, accumulator);
    }
  } else if (operation.type === OperationType.ACK_USER_WRITE) {
    var ackUserWrite = operation;
    if (!ackUserWrite.revert) {
      newViewCache2 = viewProcessorAckUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, ackUserWrite.affectedTree, writesCache, completeCache, accumulator);
    } else {
      newViewCache2 = viewProcessorRevertUserWrite(viewProcessor, oldViewCache, ackUserWrite.path, writesCache, completeCache, accumulator);
    }
  } else if (operation.type === OperationType.LISTEN_COMPLETE) {
    newViewCache2 = viewProcessorListenComplete(viewProcessor, oldViewCache, operation.path, writesCache, accumulator);
  } else {
    throw assertionError("Unknown operation type: " + operation.type);
  }
  var changes = accumulator.getChanges();
  viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, changes);
  return { viewCache: newViewCache2, changes };
}
function viewProcessorMaybeAddValueEvent(oldViewCache, newViewCache2, accumulator) {
  var eventSnap = newViewCache2.eventCache;
  if (eventSnap.isFullyInitialized()) {
    var isLeafOrEmpty = eventSnap.getNode().isLeafNode() || eventSnap.getNode().isEmpty();
    var oldCompleteSnap = viewCacheGetCompleteEventSnap(oldViewCache);
    if (accumulator.length > 0 || !oldViewCache.eventCache.isFullyInitialized() || isLeafOrEmpty && !eventSnap.getNode().equals(oldCompleteSnap) || !eventSnap.getNode().getPriority().equals(oldCompleteSnap.getPriority())) {
      accumulator.push(changeValue(viewCacheGetCompleteEventSnap(newViewCache2)));
    }
  }
}
function viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, viewCache, changePath, writesCache, source, accumulator) {
  var oldEventSnap = viewCache.eventCache;
  if (writeTreeRefShadowingWrite(writesCache, changePath) != null) {
    return viewCache;
  } else {
    var newEventCache = void 0, serverNode = void 0;
    if (pathIsEmpty(changePath)) {
      assert(viewCache.serverCache.isFullyInitialized(), "If change path is empty, we must have complete server data");
      if (viewCache.serverCache.isFiltered()) {
        var serverCache = viewCacheGetCompleteServerSnap(viewCache);
        var completeChildren = serverCache instanceof ChildrenNode ? serverCache : ChildrenNode.EMPTY_NODE;
        var completeEventChildren = writeTreeRefCalcCompleteEventChildren(writesCache, completeChildren);
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeEventChildren, accumulator);
      } else {
        var completeNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        newEventCache = viewProcessor.filter.updateFullNode(viewCache.eventCache.getNode(), completeNode, accumulator);
      }
    } else {
      var childKey = pathGetFront(changePath);
      if (childKey === ".priority") {
        assert(pathGetLength(changePath) === 1, "Can't have a priority with additional path components");
        var oldEventNode = oldEventSnap.getNode();
        serverNode = viewCache.serverCache.getNode();
        var updatedPriority = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventNode, serverNode);
        if (updatedPriority != null) {
          newEventCache = viewProcessor.filter.updatePriority(oldEventNode, updatedPriority);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      } else {
        var childChangePath = pathPopFront(changePath);
        var newEventChild = void 0;
        if (oldEventSnap.isCompleteForChild(childKey)) {
          serverNode = viewCache.serverCache.getNode();
          var eventChildUpdate = writeTreeRefCalcEventCacheAfterServerOverwrite(writesCache, changePath, oldEventSnap.getNode(), serverNode);
          if (eventChildUpdate != null) {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey).updateChild(childChangePath, eventChildUpdate);
          } else {
            newEventChild = oldEventSnap.getNode().getImmediateChild(childKey);
          }
        } else {
          newEventChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
        }
        if (newEventChild != null) {
          newEventCache = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newEventChild, childChangePath, source, accumulator);
        } else {
          newEventCache = oldEventSnap.getNode();
        }
      }
    }
    return viewCacheUpdateEventSnap(viewCache, newEventCache, oldEventSnap.isFullyInitialized() || pathIsEmpty(changePath), viewProcessor.filter.filtersNodes());
  }
}
function viewProcessorApplyServerOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, filterServerNode, accumulator) {
  var oldServerSnap = oldViewCache.serverCache;
  var newServerCache;
  var serverFilter = filterServerNode ? viewProcessor.filter : viewProcessor.filter.getIndexedFilter();
  if (pathIsEmpty(changePath)) {
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), changedSnap, null);
  } else if (serverFilter.filtersNodes() && !oldServerSnap.isFiltered()) {
    var newServerNode = oldServerSnap.getNode().updateChild(changePath, changedSnap);
    newServerCache = serverFilter.updateFullNode(oldServerSnap.getNode(), newServerNode, null);
  } else {
    var childKey = pathGetFront(changePath);
    if (!oldServerSnap.isCompleteForPath(changePath) && pathGetLength(changePath) > 1) {
      return oldViewCache;
    }
    var childChangePath = pathPopFront(changePath);
    var childNode = oldServerSnap.getNode().getImmediateChild(childKey);
    var newChildNode = childNode.updateChild(childChangePath, changedSnap);
    if (childKey === ".priority") {
      newServerCache = serverFilter.updatePriority(oldServerSnap.getNode(), newChildNode);
    } else {
      newServerCache = serverFilter.updateChild(oldServerSnap.getNode(), childKey, newChildNode, childChangePath, NO_COMPLETE_CHILD_SOURCE, null);
    }
  }
  var newViewCache2 = viewCacheUpdateServerSnap(oldViewCache, newServerCache, oldServerSnap.isFullyInitialized() || pathIsEmpty(changePath), serverFilter.filtersNodes());
  var source = new WriteTreeCompleteChildSource(writesCache, newViewCache2, completeCache);
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, changePath, writesCache, source, accumulator);
}
function viewProcessorApplyUserOverwrite(viewProcessor, oldViewCache, changePath, changedSnap, writesCache, completeCache, accumulator) {
  var oldEventSnap = oldViewCache.eventCache;
  var newViewCache2, newEventCache;
  var source = new WriteTreeCompleteChildSource(writesCache, oldViewCache, completeCache);
  if (pathIsEmpty(changePath)) {
    newEventCache = viewProcessor.filter.updateFullNode(oldViewCache.eventCache.getNode(), changedSnap, accumulator);
    newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, true, viewProcessor.filter.filtersNodes());
  } else {
    var childKey = pathGetFront(changePath);
    if (childKey === ".priority") {
      newEventCache = viewProcessor.filter.updatePriority(oldViewCache.eventCache.getNode(), changedSnap);
      newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventCache, oldEventSnap.isFullyInitialized(), oldEventSnap.isFiltered());
    } else {
      var childChangePath = pathPopFront(changePath);
      var oldChild = oldEventSnap.getNode().getImmediateChild(childKey);
      var newChild = void 0;
      if (pathIsEmpty(childChangePath)) {
        newChild = changedSnap;
      } else {
        var childNode = source.getCompleteChild(childKey);
        if (childNode != null) {
          if (pathGetBack(childChangePath) === ".priority" && childNode.getChild(pathParent(childChangePath)).isEmpty()) {
            newChild = childNode;
          } else {
            newChild = childNode.updateChild(childChangePath, changedSnap);
          }
        } else {
          newChild = ChildrenNode.EMPTY_NODE;
        }
      }
      if (!oldChild.equals(newChild)) {
        var newEventSnap = viewProcessor.filter.updateChild(oldEventSnap.getNode(), childKey, newChild, childChangePath, source, accumulator);
        newViewCache2 = viewCacheUpdateEventSnap(oldViewCache, newEventSnap, oldEventSnap.isFullyInitialized(), viewProcessor.filter.filtersNodes());
      } else {
        newViewCache2 = oldViewCache;
      }
    }
  }
  return newViewCache2;
}
function viewProcessorCacheHasChild(viewCache, childKey) {
  return viewCache.eventCache.isCompleteForChild(childKey);
}
function viewProcessorApplyUserMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, accumulator) {
  var curViewCache = viewCache;
  changedChildren.foreach(function(relativePath, childNode) {
    var writePath = pathChild(path, relativePath);
    if (viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  changedChildren.foreach(function(relativePath, childNode) {
    var writePath = pathChild(path, relativePath);
    if (!viewProcessorCacheHasChild(viewCache, pathGetFront(writePath))) {
      curViewCache = viewProcessorApplyUserOverwrite(viewProcessor, curViewCache, writePath, childNode, writesCache, serverCache, accumulator);
    }
  });
  return curViewCache;
}
function viewProcessorApplyMerge(viewProcessor, node, merge) {
  merge.foreach(function(relativePath, childNode) {
    node = node.updateChild(relativePath, childNode);
  });
  return node;
}
function viewProcessorApplyServerMerge(viewProcessor, viewCache, path, changedChildren, writesCache, serverCache, filterServerNode, accumulator) {
  if (viewCache.serverCache.getNode().isEmpty() && !viewCache.serverCache.isFullyInitialized()) {
    return viewCache;
  }
  var curViewCache = viewCache;
  var viewMergeTree;
  if (pathIsEmpty(path)) {
    viewMergeTree = changedChildren;
  } else {
    viewMergeTree = new ImmutableTree(null).setTree(path, changedChildren);
  }
  var serverNode = viewCache.serverCache.getNode();
  viewMergeTree.children.inorderTraversal(function(childKey, childTree) {
    if (serverNode.hasChild(childKey)) {
      var serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  viewMergeTree.children.inorderTraversal(function(childKey, childMergeTree) {
    var isUnknownDeepMerge = !viewCache.serverCache.isCompleteForChild(childKey) && childMergeTree.value === void 0;
    if (!serverNode.hasChild(childKey) && !isUnknownDeepMerge) {
      var serverChild = viewCache.serverCache.getNode().getImmediateChild(childKey);
      var newChild = viewProcessorApplyMerge(viewProcessor, serverChild, childMergeTree);
      curViewCache = viewProcessorApplyServerOverwrite(viewProcessor, curViewCache, new Path(childKey), newChild, writesCache, serverCache, filterServerNode, accumulator);
    }
  });
  return curViewCache;
}
function viewProcessorAckUserWrite(viewProcessor, viewCache, ackPath, affectedTree, writesCache, completeCache, accumulator) {
  if (writeTreeRefShadowingWrite(writesCache, ackPath) != null) {
    return viewCache;
  }
  var filterServerNode = viewCache.serverCache.isFiltered();
  var serverCache = viewCache.serverCache;
  if (affectedTree.value != null) {
    if (pathIsEmpty(ackPath) && serverCache.isFullyInitialized() || serverCache.isCompleteForPath(ackPath)) {
      return viewProcessorApplyServerOverwrite(viewProcessor, viewCache, ackPath, serverCache.getNode().getChild(ackPath), writesCache, completeCache, filterServerNode, accumulator);
    } else if (pathIsEmpty(ackPath)) {
      var changedChildren_1 = new ImmutableTree(null);
      serverCache.getNode().forEachChild(KEY_INDEX, function(name10, node) {
        changedChildren_1 = changedChildren_1.set(new Path(name10), node);
      });
      return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_1, writesCache, completeCache, filterServerNode, accumulator);
    } else {
      return viewCache;
    }
  } else {
    var changedChildren_2 = new ImmutableTree(null);
    affectedTree.foreach(function(mergePath, value) {
      var serverCachePath = pathChild(ackPath, mergePath);
      if (serverCache.isCompleteForPath(serverCachePath)) {
        changedChildren_2 = changedChildren_2.set(mergePath, serverCache.getNode().getChild(serverCachePath));
      }
    });
    return viewProcessorApplyServerMerge(viewProcessor, viewCache, ackPath, changedChildren_2, writesCache, completeCache, filterServerNode, accumulator);
  }
}
function viewProcessorListenComplete(viewProcessor, viewCache, path, writesCache, accumulator) {
  var oldServerNode = viewCache.serverCache;
  var newViewCache2 = viewCacheUpdateServerSnap(viewCache, oldServerNode.getNode(), oldServerNode.isFullyInitialized() || pathIsEmpty(path), oldServerNode.isFiltered());
  return viewProcessorGenerateEventCacheAfterServerEvent(viewProcessor, newViewCache2, path, writesCache, NO_COMPLETE_CHILD_SOURCE, accumulator);
}
function viewProcessorRevertUserWrite(viewProcessor, viewCache, path, writesCache, completeServerCache, accumulator) {
  var complete;
  if (writeTreeRefShadowingWrite(writesCache, path) != null) {
    return viewCache;
  } else {
    var source = new WriteTreeCompleteChildSource(writesCache, viewCache, completeServerCache);
    var oldEventCache = viewCache.eventCache.getNode();
    var newEventCache = void 0;
    if (pathIsEmpty(path) || pathGetFront(path) === ".priority") {
      var newNode = void 0;
      if (viewCache.serverCache.isFullyInitialized()) {
        newNode = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
      } else {
        var serverChildren = viewCache.serverCache.getNode();
        assert(serverChildren instanceof ChildrenNode, "serverChildren would be complete if leaf node");
        newNode = writeTreeRefCalcCompleteEventChildren(writesCache, serverChildren);
      }
      newNode = newNode;
      newEventCache = viewProcessor.filter.updateFullNode(oldEventCache, newNode, accumulator);
    } else {
      var childKey = pathGetFront(path);
      var newChild = writeTreeRefCalcCompleteChild(writesCache, childKey, viewCache.serverCache);
      if (newChild == null && viewCache.serverCache.isCompleteForChild(childKey)) {
        newChild = oldEventCache.getImmediateChild(childKey);
      }
      if (newChild != null) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, newChild, pathPopFront(path), source, accumulator);
      } else if (viewCache.eventCache.getNode().hasChild(childKey)) {
        newEventCache = viewProcessor.filter.updateChild(oldEventCache, childKey, ChildrenNode.EMPTY_NODE, pathPopFront(path), source, accumulator);
      } else {
        newEventCache = oldEventCache;
      }
      if (newEventCache.isEmpty() && viewCache.serverCache.isFullyInitialized()) {
        complete = writeTreeRefCalcCompleteEventCache(writesCache, viewCacheGetCompleteServerSnap(viewCache));
        if (complete.isLeafNode()) {
          newEventCache = viewProcessor.filter.updateFullNode(newEventCache, complete, accumulator);
        }
      }
    }
    complete = viewCache.serverCache.isFullyInitialized() || writeTreeRefShadowingWrite(writesCache, newEmptyPath()) != null;
    return viewCacheUpdateEventSnap(viewCache, newEventCache, complete, viewProcessor.filter.filtersNodes());
  }
}
var View = (
  /** @class */
  function() {
    function View2(query_, initialViewCache) {
      this.query_ = query_;
      this.eventRegistrations_ = [];
      var params = this.query_._queryParams;
      var indexFilter = new IndexedFilter(params.getIndex());
      var filter = queryParamsGetNodeFilter(params);
      this.processor_ = newViewProcessor(filter);
      var initialServerCache = initialViewCache.serverCache;
      var initialEventCache = initialViewCache.eventCache;
      var serverSnap = indexFilter.updateFullNode(ChildrenNode.EMPTY_NODE, initialServerCache.getNode(), null);
      var eventSnap = filter.updateFullNode(ChildrenNode.EMPTY_NODE, initialEventCache.getNode(), null);
      var newServerCache = new CacheNode(serverSnap, initialServerCache.isFullyInitialized(), indexFilter.filtersNodes());
      var newEventCache = new CacheNode(eventSnap, initialEventCache.isFullyInitialized(), filter.filtersNodes());
      this.viewCache_ = newViewCache(newEventCache, newServerCache);
      this.eventGenerator_ = new EventGenerator(this.query_);
    }
    Object.defineProperty(View2.prototype, "query", {
      get: function() {
        return this.query_;
      },
      enumerable: false,
      configurable: true
    });
    return View2;
  }()
);
function viewGetServerCache(view) {
  return view.viewCache_.serverCache.getNode();
}
function viewGetCompleteNode(view) {
  return viewCacheGetCompleteEventSnap(view.viewCache_);
}
function viewGetCompleteServerCache(view, path) {
  var cache = viewCacheGetCompleteServerSnap(view.viewCache_);
  if (cache) {
    if (view.query._queryParams.loadsAllData() || !pathIsEmpty(path) && !cache.getImmediateChild(pathGetFront(path)).isEmpty()) {
      return cache.getChild(path);
    }
  }
  return null;
}
function viewIsEmpty(view) {
  return view.eventRegistrations_.length === 0;
}
function viewAddEventRegistration(view, eventRegistration) {
  view.eventRegistrations_.push(eventRegistration);
}
function viewRemoveEventRegistration(view, eventRegistration, cancelError) {
  var cancelEvents = [];
  if (cancelError) {
    assert(eventRegistration == null, "A cancel should cancel all event registrations.");
    var path_1 = view.query._path;
    view.eventRegistrations_.forEach(function(registration) {
      var maybeEvent = registration.createCancelEvent(cancelError, path_1);
      if (maybeEvent) {
        cancelEvents.push(maybeEvent);
      }
    });
  }
  if (eventRegistration) {
    var remaining = [];
    for (var i = 0; i < view.eventRegistrations_.length; ++i) {
      var existing = view.eventRegistrations_[i];
      if (!existing.matches(eventRegistration)) {
        remaining.push(existing);
      } else if (eventRegistration.hasAnyCallback()) {
        remaining = remaining.concat(view.eventRegistrations_.slice(i + 1));
        break;
      }
    }
    view.eventRegistrations_ = remaining;
  } else {
    view.eventRegistrations_ = [];
  }
  return cancelEvents;
}
function viewApplyOperation(view, operation, writesCache, completeServerCache) {
  if (operation.type === OperationType.MERGE && operation.source.queryId !== null) {
    assert(viewCacheGetCompleteServerSnap(view.viewCache_), "We should always have a full cache before handling merges");
    assert(viewCacheGetCompleteEventSnap(view.viewCache_), "Missing event cache, even though we have a server cache");
  }
  var oldViewCache = view.viewCache_;
  var result = viewProcessorApplyOperation(view.processor_, oldViewCache, operation, writesCache, completeServerCache);
  viewProcessorAssertIndexed(view.processor_, result.viewCache);
  assert(result.viewCache.serverCache.isFullyInitialized() || !oldViewCache.serverCache.isFullyInitialized(), "Once a server snap is complete, it should never go back");
  view.viewCache_ = result.viewCache;
  return viewGenerateEventsForChanges_(view, result.changes, result.viewCache.eventCache.getNode(), null);
}
function viewGetInitialEvents(view, registration) {
  var eventSnap = view.viewCache_.eventCache;
  var initialChanges = [];
  if (!eventSnap.getNode().isLeafNode()) {
    var eventNode = eventSnap.getNode();
    eventNode.forEachChild(PRIORITY_INDEX, function(key, childNode) {
      initialChanges.push(changeChildAdded(key, childNode));
    });
  }
  if (eventSnap.isFullyInitialized()) {
    initialChanges.push(changeValue(eventSnap.getNode()));
  }
  return viewGenerateEventsForChanges_(view, initialChanges, eventSnap.getNode(), registration);
}
function viewGenerateEventsForChanges_(view, changes, eventCache, eventRegistration) {
  var registrations = eventRegistration ? [eventRegistration] : view.eventRegistrations_;
  return eventGeneratorGenerateEventsForChanges(view.eventGenerator_, changes, eventCache, registrations);
}
var referenceConstructor$1;
var SyncPoint = (
  /** @class */
  /* @__PURE__ */ function() {
    function SyncPoint2() {
      this.views = /* @__PURE__ */ new Map();
    }
    return SyncPoint2;
  }()
);
function syncPointSetReferenceConstructor(val) {
  assert(!referenceConstructor$1, "__referenceConstructor has already been defined");
  referenceConstructor$1 = val;
}
function syncPointGetReferenceConstructor() {
  assert(referenceConstructor$1, "Reference.ts has not been loaded");
  return referenceConstructor$1;
}
function syncPointIsEmpty(syncPoint) {
  return syncPoint.views.size === 0;
}
function syncPointApplyOperation(syncPoint, operation, writesCache, optCompleteServerCache) {
  var e_1, _a7;
  var queryId = operation.source.queryId;
  if (queryId !== null) {
    var view = syncPoint.views.get(queryId);
    assert(view != null, "SyncTree gave us an op for an invalid query.");
    return viewApplyOperation(view, operation, writesCache, optCompleteServerCache);
  } else {
    var events = [];
    try {
      for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var view = _c.value;
        events = events.concat(viewApplyOperation(view, operation, writesCache, optCompleteServerCache));
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
    return events;
  }
}
function syncPointGetView(syncPoint, query2, writesCache, serverCache, serverCacheComplete) {
  var queryId = query2._queryIdentifier;
  var view = syncPoint.views.get(queryId);
  if (!view) {
    var eventCache = writeTreeRefCalcCompleteEventCache(writesCache, serverCacheComplete ? serverCache : null);
    var eventCacheComplete = false;
    if (eventCache) {
      eventCacheComplete = true;
    } else if (serverCache instanceof ChildrenNode) {
      eventCache = writeTreeRefCalcCompleteEventChildren(writesCache, serverCache);
      eventCacheComplete = false;
    } else {
      eventCache = ChildrenNode.EMPTY_NODE;
      eventCacheComplete = false;
    }
    var viewCache = newViewCache(new CacheNode(eventCache, eventCacheComplete, false), new CacheNode(serverCache, serverCacheComplete, false));
    return new View(query2, viewCache);
  }
  return view;
}
function syncPointAddEventRegistration(syncPoint, query2, eventRegistration, writesCache, serverCache, serverCacheComplete) {
  var view = syncPointGetView(syncPoint, query2, writesCache, serverCache, serverCacheComplete);
  if (!syncPoint.views.has(query2._queryIdentifier)) {
    syncPoint.views.set(query2._queryIdentifier, view);
  }
  viewAddEventRegistration(view, eventRegistration);
  return viewGetInitialEvents(view, eventRegistration);
}
function syncPointRemoveEventRegistration(syncPoint, query2, eventRegistration, cancelError) {
  var e_2, _a7;
  var queryId = query2._queryIdentifier;
  var removed = [];
  var cancelEvents = [];
  var hadCompleteView = syncPointHasCompleteView(syncPoint);
  if (queryId === "default") {
    try {
      for (var _b = __values(syncPoint.views.entries()), _c = _b.next(); !_c.done; _c = _b.next()) {
        var _d = __read(_c.value, 2), viewQueryId = _d[0], view = _d[1];
        cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
        if (viewIsEmpty(view)) {
          syncPoint.views.delete(viewQueryId);
          if (!view.query._queryParams.loadsAllData()) {
            removed.push(view.query);
          }
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
  } else {
    var view = syncPoint.views.get(queryId);
    if (view) {
      cancelEvents = cancelEvents.concat(viewRemoveEventRegistration(view, eventRegistration, cancelError));
      if (viewIsEmpty(view)) {
        syncPoint.views.delete(queryId);
        if (!view.query._queryParams.loadsAllData()) {
          removed.push(view.query);
        }
      }
    }
  }
  if (hadCompleteView && !syncPointHasCompleteView(syncPoint)) {
    removed.push(new (syncPointGetReferenceConstructor())(query2._repo, query2._path));
  }
  return { removed, events: cancelEvents };
}
function syncPointGetQueryViews(syncPoint) {
  var e_3, _a7;
  var result = [];
  try {
    for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var view = _c.value;
      if (!view.query._queryParams.loadsAllData()) {
        result.push(view);
      }
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
    } finally {
      if (e_3) throw e_3.error;
    }
  }
  return result;
}
function syncPointGetCompleteServerCache(syncPoint, path) {
  var e_4, _a7;
  var serverCache = null;
  try {
    for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var view = _c.value;
      serverCache = serverCache || viewGetCompleteServerCache(view, path);
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
    } finally {
      if (e_4) throw e_4.error;
    }
  }
  return serverCache;
}
function syncPointViewForQuery(syncPoint, query2) {
  var params = query2._queryParams;
  if (params.loadsAllData()) {
    return syncPointGetCompleteView(syncPoint);
  } else {
    var queryId = query2._queryIdentifier;
    return syncPoint.views.get(queryId);
  }
}
function syncPointViewExistsForQuery(syncPoint, query2) {
  return syncPointViewForQuery(syncPoint, query2) != null;
}
function syncPointHasCompleteView(syncPoint) {
  return syncPointGetCompleteView(syncPoint) != null;
}
function syncPointGetCompleteView(syncPoint) {
  var e_5, _a7;
  try {
    for (var _b = __values(syncPoint.views.values()), _c = _b.next(); !_c.done; _c = _b.next()) {
      var view = _c.value;
      if (view.query._queryParams.loadsAllData()) {
        return view;
      }
    }
  } catch (e_5_1) {
    e_5 = { error: e_5_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
    } finally {
      if (e_5) throw e_5.error;
    }
  }
  return null;
}
var referenceConstructor;
function syncTreeSetReferenceConstructor(val) {
  assert(!referenceConstructor, "__referenceConstructor has already been defined");
  referenceConstructor = val;
}
function syncTreeGetReferenceConstructor() {
  assert(referenceConstructor, "Reference.ts has not been loaded");
  return referenceConstructor;
}
var syncTreeNextQueryTag_ = 1;
var SyncTree = (
  /** @class */
  /* @__PURE__ */ function() {
    function SyncTree2(listenProvider_) {
      this.listenProvider_ = listenProvider_;
      this.syncPointTree_ = new ImmutableTree(null);
      this.pendingWriteTree_ = newWriteTree();
      this.tagToQueryMap = /* @__PURE__ */ new Map();
      this.queryToTagMap = /* @__PURE__ */ new Map();
    }
    return SyncTree2;
  }()
);
function syncTreeApplyUserOverwrite(syncTree, path, newData, writeId, visible) {
  writeTreeAddOverwrite(syncTree.pendingWriteTree_, path, newData, writeId, visible);
  if (!visible) {
    return [];
  } else {
    return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceUser(), path, newData));
  }
}
function syncTreeApplyUserMerge(syncTree, path, changedChildren, writeId) {
  writeTreeAddMerge(syncTree.pendingWriteTree_, path, changedChildren, writeId);
  var changeTree = ImmutableTree.fromObject(changedChildren);
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceUser(), path, changeTree));
}
function syncTreeAckUserWrite(syncTree, writeId, revert) {
  if (revert === void 0) {
    revert = false;
  }
  var write2 = writeTreeGetWrite(syncTree.pendingWriteTree_, writeId);
  var needToReevaluate = writeTreeRemoveWrite(syncTree.pendingWriteTree_, writeId);
  if (!needToReevaluate) {
    return [];
  } else {
    var affectedTree_1 = new ImmutableTree(null);
    if (write2.snap != null) {
      affectedTree_1 = affectedTree_1.set(newEmptyPath(), true);
    } else {
      each(write2.children, function(pathString) {
        affectedTree_1 = affectedTree_1.set(new Path(pathString), true);
      });
    }
    return syncTreeApplyOperationToSyncPoints_(syncTree, new AckUserWrite(write2.path, affectedTree_1, revert));
  }
}
function syncTreeApplyServerOverwrite(syncTree, path, newData) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Overwrite(newOperationSourceServer(), path, newData));
}
function syncTreeApplyServerMerge(syncTree, path, changedChildren) {
  var changeTree = ImmutableTree.fromObject(changedChildren);
  return syncTreeApplyOperationToSyncPoints_(syncTree, new Merge(newOperationSourceServer(), path, changeTree));
}
function syncTreeApplyListenComplete(syncTree, path) {
  return syncTreeApplyOperationToSyncPoints_(syncTree, new ListenComplete(newOperationSourceServer(), path));
}
function syncTreeApplyTaggedListenComplete(syncTree, path, tag) {
  var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    var r = syncTreeParseQueryKey_(queryKey);
    var queryPath = r.path, queryId = r.queryId;
    var relativePath = newRelativePath(queryPath, path);
    var op = new ListenComplete(newOperationSourceServerTaggedQuery(queryId), relativePath);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeRemoveEventRegistration(syncTree, query2, eventRegistration, cancelError) {
  var path = query2._path;
  var maybeSyncPoint = syncTree.syncPointTree_.get(path);
  var cancelEvents = [];
  if (maybeSyncPoint && (query2._queryIdentifier === "default" || syncPointViewExistsForQuery(maybeSyncPoint, query2))) {
    var removedAndEvents = syncPointRemoveEventRegistration(maybeSyncPoint, query2, eventRegistration, cancelError);
    if (syncPointIsEmpty(maybeSyncPoint)) {
      syncTree.syncPointTree_ = syncTree.syncPointTree_.remove(path);
    }
    var removed = removedAndEvents.removed;
    cancelEvents = removedAndEvents.events;
    var removingDefault = -1 !== removed.findIndex(function(query3) {
      return query3._queryParams.loadsAllData();
    });
    var covered = syncTree.syncPointTree_.findOnPath(path, function(relativePath, parentSyncPoint) {
      return syncPointHasCompleteView(parentSyncPoint);
    });
    if (removingDefault && !covered) {
      var subtree = syncTree.syncPointTree_.subtree(path);
      if (!subtree.isEmpty()) {
        var newViews = syncTreeCollectDistinctViewsForSubTree_(subtree);
        for (var i = 0; i < newViews.length; ++i) {
          var view = newViews[i], newQuery = view.query;
          var listener = syncTreeCreateListenerForView_(syncTree, view);
          syncTree.listenProvider_.startListening(syncTreeQueryForListening_(newQuery), syncTreeTagForQuery_(syncTree, newQuery), listener.hashFn, listener.onComplete);
        }
      }
    }
    if (!covered && removed.length > 0 && !cancelError) {
      if (removingDefault) {
        var defaultTag = null;
        syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(query2), defaultTag);
      } else {
        removed.forEach(function(queryToRemove) {
          var tagToRemove = syncTree.queryToTagMap.get(syncTreeMakeQueryKey_(queryToRemove));
          syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToRemove), tagToRemove);
        });
      }
    }
    syncTreeRemoveTags_(syncTree, removed);
  }
  return cancelEvents;
}
function syncTreeApplyTaggedQueryOverwrite(syncTree, path, snap, tag) {
  var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey != null) {
    var r = syncTreeParseQueryKey_(queryKey);
    var queryPath = r.path, queryId = r.queryId;
    var relativePath = newRelativePath(queryPath, path);
    var op = new Overwrite(newOperationSourceServerTaggedQuery(queryId), relativePath, snap);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeApplyTaggedQueryMerge(syncTree, path, changedChildren, tag) {
  var queryKey = syncTreeQueryKeyForTag_(syncTree, tag);
  if (queryKey) {
    var r = syncTreeParseQueryKey_(queryKey);
    var queryPath = r.path, queryId = r.queryId;
    var relativePath = newRelativePath(queryPath, path);
    var changeTree = ImmutableTree.fromObject(changedChildren);
    var op = new Merge(newOperationSourceServerTaggedQuery(queryId), relativePath, changeTree);
    return syncTreeApplyTaggedOperation_(syncTree, queryPath, op);
  } else {
    return [];
  }
}
function syncTreeAddEventRegistration(syncTree, query2, eventRegistration) {
  var path = query2._path;
  var serverCache = null;
  var foundAncestorDefaultView = false;
  syncTree.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
    var relativePath = newRelativePath(pathToSyncPoint, path);
    serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
    foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(sp);
  });
  var syncPoint = syncTree.syncPointTree_.get(path);
  if (!syncPoint) {
    syncPoint = new SyncPoint();
    syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
  } else {
    foundAncestorDefaultView = foundAncestorDefaultView || syncPointHasCompleteView(syncPoint);
    serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  var serverCacheComplete;
  if (serverCache != null) {
    serverCacheComplete = true;
  } else {
    serverCacheComplete = false;
    serverCache = ChildrenNode.EMPTY_NODE;
    var subtree = syncTree.syncPointTree_.subtree(path);
    subtree.foreachChild(function(childName, childSyncPoint) {
      var completeCache = syncPointGetCompleteServerCache(childSyncPoint, newEmptyPath());
      if (completeCache) {
        serverCache = serverCache.updateImmediateChild(childName, completeCache);
      }
    });
  }
  var viewAlreadyExists = syncPointViewExistsForQuery(syncPoint, query2);
  if (!viewAlreadyExists && !query2._queryParams.loadsAllData()) {
    var queryKey = syncTreeMakeQueryKey_(query2);
    assert(!syncTree.queryToTagMap.has(queryKey), "View does not exist, but we have a tag");
    var tag = syncTreeGetNextQueryTag_();
    syncTree.queryToTagMap.set(queryKey, tag);
    syncTree.tagToQueryMap.set(tag, queryKey);
  }
  var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, path);
  var events = syncPointAddEventRegistration(syncPoint, query2, eventRegistration, writesCache, serverCache, serverCacheComplete);
  if (!viewAlreadyExists && !foundAncestorDefaultView) {
    var view = syncPointViewForQuery(syncPoint, query2);
    events = events.concat(syncTreeSetupListener_(syncTree, query2, view));
  }
  return events;
}
function syncTreeCalcCompleteEventCache(syncTree, path, writeIdsToExclude) {
  var includeHiddenSets = true;
  var writeTree = syncTree.pendingWriteTree_;
  var serverCache = syncTree.syncPointTree_.findOnPath(path, function(pathSoFar, syncPoint) {
    var relativePath = newRelativePath(pathSoFar, path);
    var serverCache2 = syncPointGetCompleteServerCache(syncPoint, relativePath);
    if (serverCache2) {
      return serverCache2;
    }
  });
  return writeTreeCalcCompleteEventCache(writeTree, path, serverCache, writeIdsToExclude, includeHiddenSets);
}
function syncTreeGetServerValue(syncTree, query2) {
  var path = query2._path;
  var serverCache = null;
  syncTree.syncPointTree_.foreachOnPath(path, function(pathToSyncPoint, sp) {
    var relativePath = newRelativePath(pathToSyncPoint, path);
    serverCache = serverCache || syncPointGetCompleteServerCache(sp, relativePath);
  });
  var syncPoint = syncTree.syncPointTree_.get(path);
  if (!syncPoint) {
    syncPoint = new SyncPoint();
    syncTree.syncPointTree_ = syncTree.syncPointTree_.set(path, syncPoint);
  } else {
    serverCache = serverCache || syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  var serverCacheComplete = serverCache != null;
  var serverCacheNode = serverCacheComplete ? new CacheNode(serverCache, true, false) : null;
  var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, query2._path);
  var view = syncPointGetView(syncPoint, query2, writesCache, serverCacheComplete ? serverCacheNode.getNode() : ChildrenNode.EMPTY_NODE, serverCacheComplete);
  return viewGetCompleteNode(view);
}
function syncTreeApplyOperationToSyncPoints_(syncTree, operation) {
  return syncTreeApplyOperationHelper_(
    operation,
    syncTree.syncPointTree_,
    /*serverCache=*/
    null,
    writeTreeChildWrites(syncTree.pendingWriteTree_, newEmptyPath())
  );
}
function syncTreeApplyOperationHelper_(operation, syncPointTree, serverCache, writesCache) {
  if (pathIsEmpty(operation.path)) {
    return syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache);
  } else {
    var syncPoint = syncPointTree.get(newEmptyPath());
    if (serverCache == null && syncPoint != null) {
      serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
    }
    var events = [];
    var childName = pathGetFront(operation.path);
    var childOperation = operation.operationForChild(childName);
    var childTree = syncPointTree.children.get(childName);
    if (childTree && childOperation) {
      var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
      var childWritesCache = writeTreeRefChild(writesCache, childName);
      events = events.concat(syncTreeApplyOperationHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
    if (syncPoint) {
      events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
    }
    return events;
  }
}
function syncTreeApplyOperationDescendantsHelper_(operation, syncPointTree, serverCache, writesCache) {
  var syncPoint = syncPointTree.get(newEmptyPath());
  if (serverCache == null && syncPoint != null) {
    serverCache = syncPointGetCompleteServerCache(syncPoint, newEmptyPath());
  }
  var events = [];
  syncPointTree.children.inorderTraversal(function(childName, childTree) {
    var childServerCache = serverCache ? serverCache.getImmediateChild(childName) : null;
    var childWritesCache = writeTreeRefChild(writesCache, childName);
    var childOperation = operation.operationForChild(childName);
    if (childOperation) {
      events = events.concat(syncTreeApplyOperationDescendantsHelper_(childOperation, childTree, childServerCache, childWritesCache));
    }
  });
  if (syncPoint) {
    events = events.concat(syncPointApplyOperation(syncPoint, operation, writesCache, serverCache));
  }
  return events;
}
function syncTreeCreateListenerForView_(syncTree, view) {
  var query2 = view.query;
  var tag = syncTreeTagForQuery_(syncTree, query2);
  return {
    hashFn: function() {
      var cache = viewGetServerCache(view) || ChildrenNode.EMPTY_NODE;
      return cache.hash();
    },
    onComplete: function(status) {
      if (status === "ok") {
        if (tag) {
          return syncTreeApplyTaggedListenComplete(syncTree, query2._path, tag);
        } else {
          return syncTreeApplyListenComplete(syncTree, query2._path);
        }
      } else {
        var error2 = errorForServerCode(status, query2);
        return syncTreeRemoveEventRegistration(
          syncTree,
          query2,
          /*eventRegistration*/
          null,
          error2
        );
      }
    }
  };
}
function syncTreeTagForQuery_(syncTree, query2) {
  var queryKey = syncTreeMakeQueryKey_(query2);
  return syncTree.queryToTagMap.get(queryKey);
}
function syncTreeMakeQueryKey_(query2) {
  return query2._path.toString() + "$" + query2._queryIdentifier;
}
function syncTreeQueryKeyForTag_(syncTree, tag) {
  return syncTree.tagToQueryMap.get(tag);
}
function syncTreeParseQueryKey_(queryKey) {
  var splitIndex = queryKey.indexOf("$");
  assert(splitIndex !== -1 && splitIndex < queryKey.length - 1, "Bad queryKey.");
  return {
    queryId: queryKey.substr(splitIndex + 1),
    path: new Path(queryKey.substr(0, splitIndex))
  };
}
function syncTreeApplyTaggedOperation_(syncTree, queryPath, operation) {
  var syncPoint = syncTree.syncPointTree_.get(queryPath);
  assert(syncPoint, "Missing sync point for query tag that we're tracking");
  var writesCache = writeTreeChildWrites(syncTree.pendingWriteTree_, queryPath);
  return syncPointApplyOperation(syncPoint, operation, writesCache, null);
}
function syncTreeCollectDistinctViewsForSubTree_(subtree) {
  return subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
    if (maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
      var completeView = syncPointGetCompleteView(maybeChildSyncPoint);
      return [completeView];
    } else {
      var views_1 = [];
      if (maybeChildSyncPoint) {
        views_1 = syncPointGetQueryViews(maybeChildSyncPoint);
      }
      each(childMap, function(_key, childViews) {
        views_1 = views_1.concat(childViews);
      });
      return views_1;
    }
  });
}
function syncTreeQueryForListening_(query2) {
  if (query2._queryParams.loadsAllData() && !query2._queryParams.isDefault()) {
    return new (syncTreeGetReferenceConstructor())(query2._repo, query2._path);
  } else {
    return query2;
  }
}
function syncTreeRemoveTags_(syncTree, queries) {
  for (var j = 0; j < queries.length; ++j) {
    var removedQuery = queries[j];
    if (!removedQuery._queryParams.loadsAllData()) {
      var removedQueryKey = syncTreeMakeQueryKey_(removedQuery);
      var removedQueryTag = syncTree.queryToTagMap.get(removedQueryKey);
      syncTree.queryToTagMap.delete(removedQueryKey);
      syncTree.tagToQueryMap.delete(removedQueryTag);
    }
  }
}
function syncTreeGetNextQueryTag_() {
  return syncTreeNextQueryTag_++;
}
function syncTreeSetupListener_(syncTree, query2, view) {
  var path = query2._path;
  var tag = syncTreeTagForQuery_(syncTree, query2);
  var listener = syncTreeCreateListenerForView_(syncTree, view);
  var events = syncTree.listenProvider_.startListening(syncTreeQueryForListening_(query2), tag, listener.hashFn, listener.onComplete);
  var subtree = syncTree.syncPointTree_.subtree(path);
  if (tag) {
    assert(!syncPointHasCompleteView(subtree.value), "If we're adding a query, it shouldn't be shadowed");
  } else {
    var queriesToStop = subtree.fold(function(relativePath, maybeChildSyncPoint, childMap) {
      if (!pathIsEmpty(relativePath) && maybeChildSyncPoint && syncPointHasCompleteView(maybeChildSyncPoint)) {
        return [syncPointGetCompleteView(maybeChildSyncPoint).query];
      } else {
        var queries_1 = [];
        if (maybeChildSyncPoint) {
          queries_1 = queries_1.concat(syncPointGetQueryViews(maybeChildSyncPoint).map(function(view2) {
            return view2.query;
          }));
        }
        each(childMap, function(_key, childQueries) {
          queries_1 = queries_1.concat(childQueries);
        });
        return queries_1;
      }
    });
    for (var i = 0; i < queriesToStop.length; ++i) {
      var queryToStop = queriesToStop[i];
      syncTree.listenProvider_.stopListening(syncTreeQueryForListening_(queryToStop), syncTreeTagForQuery_(syncTree, queryToStop));
    }
  }
  return events;
}
var ExistingValueProvider = (
  /** @class */
  function() {
    function ExistingValueProvider2(node_) {
      this.node_ = node_;
    }
    ExistingValueProvider2.prototype.getImmediateChild = function(childName) {
      var child3 = this.node_.getImmediateChild(childName);
      return new ExistingValueProvider2(child3);
    };
    ExistingValueProvider2.prototype.node = function() {
      return this.node_;
    };
    return ExistingValueProvider2;
  }()
);
var DeferredValueProvider = (
  /** @class */
  function() {
    function DeferredValueProvider2(syncTree, path) {
      this.syncTree_ = syncTree;
      this.path_ = path;
    }
    DeferredValueProvider2.prototype.getImmediateChild = function(childName) {
      var childPath = pathChild(this.path_, childName);
      return new DeferredValueProvider2(this.syncTree_, childPath);
    };
    DeferredValueProvider2.prototype.node = function() {
      return syncTreeCalcCompleteEventCache(this.syncTree_, this.path_);
    };
    return DeferredValueProvider2;
  }()
);
var generateWithValues = function(values) {
  values = values || {};
  values["timestamp"] = values["timestamp"] || (/* @__PURE__ */ new Date()).getTime();
  return values;
};
var resolveDeferredLeafValue = function(value, existingVal, serverValues) {
  if (!value || typeof value !== "object") {
    return value;
  }
  assert(".sv" in value, "Unexpected leaf node or priority contents");
  if (typeof value[".sv"] === "string") {
    return resolveScalarDeferredValue(value[".sv"], existingVal, serverValues);
  } else if (typeof value[".sv"] === "object") {
    return resolveComplexDeferredValue(value[".sv"], existingVal);
  } else {
    assert(false, "Unexpected server value: " + JSON.stringify(value, null, 2));
  }
};
var resolveScalarDeferredValue = function(op, existing, serverValues) {
  switch (op) {
    case "timestamp":
      return serverValues["timestamp"];
    default:
      assert(false, "Unexpected server value: " + op);
  }
};
var resolveComplexDeferredValue = function(op, existing, unused) {
  if (!op.hasOwnProperty("increment")) {
    assert(false, "Unexpected server value: " + JSON.stringify(op, null, 2));
  }
  var delta = op["increment"];
  if (typeof delta !== "number") {
    assert(false, "Unexpected increment value: " + delta);
  }
  var existingNode = existing.node();
  assert(existingNode !== null && typeof existingNode !== "undefined", "Expected ChildrenNode.EMPTY_NODE for nulls");
  if (!existingNode.isLeafNode()) {
    return delta;
  }
  var leaf = existingNode;
  var existingVal = leaf.getValue();
  if (typeof existingVal !== "number") {
    return delta;
  }
  return existingVal + delta;
};
var resolveDeferredValueTree = function(path, node, syncTree, serverValues) {
  return resolveDeferredValue(node, new DeferredValueProvider(syncTree, path), serverValues);
};
var resolveDeferredValueSnapshot = function(node, existing, serverValues) {
  return resolveDeferredValue(node, new ExistingValueProvider(existing), serverValues);
};
function resolveDeferredValue(node, existingVal, serverValues) {
  var rawPri = node.getPriority().val();
  var priority = resolveDeferredLeafValue(rawPri, existingVal.getImmediateChild(".priority"), serverValues);
  var newNode;
  if (node.isLeafNode()) {
    var leafNode = node;
    var value = resolveDeferredLeafValue(leafNode.getValue(), existingVal, serverValues);
    if (value !== leafNode.getValue() || priority !== leafNode.getPriority().val()) {
      return new LeafNode(value, nodeFromJSON(priority));
    } else {
      return node;
    }
  } else {
    var childrenNode = node;
    newNode = childrenNode;
    if (priority !== childrenNode.getPriority().val()) {
      newNode = newNode.updatePriority(new LeafNode(priority));
    }
    childrenNode.forEachChild(PRIORITY_INDEX, function(childName, childNode) {
      var newChildNode = resolveDeferredValue(childNode, existingVal.getImmediateChild(childName), serverValues);
      if (newChildNode !== childNode) {
        newNode = newNode.updateImmediateChild(childName, newChildNode);
      }
    });
    return newNode;
  }
}
var Tree = (
  /** @class */
  /* @__PURE__ */ function() {
    function Tree2(name10, parent2, node) {
      if (name10 === void 0) {
        name10 = "";
      }
      if (parent2 === void 0) {
        parent2 = null;
      }
      if (node === void 0) {
        node = { children: {}, childCount: 0 };
      }
      this.name = name10;
      this.parent = parent2;
      this.node = node;
    }
    return Tree2;
  }()
);
function treeSubTree(tree, pathObj) {
  var path = pathObj instanceof Path ? pathObj : new Path(pathObj);
  var child3 = tree, next = pathGetFront(path);
  while (next !== null) {
    var childNode = safeGet(child3.node.children, next) || {
      children: {},
      childCount: 0
    };
    child3 = new Tree(next, child3, childNode);
    path = pathPopFront(path);
    next = pathGetFront(path);
  }
  return child3;
}
function treeGetValue(tree) {
  return tree.node.value;
}
function treeSetValue(tree, value) {
  tree.node.value = value;
  treeUpdateParents(tree);
}
function treeHasChildren(tree) {
  return tree.node.childCount > 0;
}
function treeIsEmpty(tree) {
  return treeGetValue(tree) === void 0 && !treeHasChildren(tree);
}
function treeForEachChild(tree, action) {
  each(tree.node.children, function(child3, childTree) {
    action(new Tree(child3, tree, childTree));
  });
}
function treeForEachDescendant(tree, action, includeSelf, childrenFirst) {
  if (includeSelf && !childrenFirst) {
    action(tree);
  }
  treeForEachChild(tree, function(child3) {
    treeForEachDescendant(child3, action, true, childrenFirst);
  });
  if (includeSelf && childrenFirst) {
    action(tree);
  }
}
function treeForEachAncestor(tree, action, includeSelf) {
  var node = includeSelf ? tree : tree.parent;
  while (node !== null) {
    if (action(node)) {
      return true;
    }
    node = node.parent;
  }
  return false;
}
function treeGetPath(tree) {
  return new Path(tree.parent === null ? tree.name : treeGetPath(tree.parent) + "/" + tree.name);
}
function treeUpdateParents(tree) {
  if (tree.parent !== null) {
    treeUpdateChild(tree.parent, tree.name, tree);
  }
}
function treeUpdateChild(tree, childName, child3) {
  var childEmpty = treeIsEmpty(child3);
  var childExists = contains(tree.node.children, childName);
  if (childEmpty && childExists) {
    delete tree.node.children[childName];
    tree.node.childCount--;
    treeUpdateParents(tree);
  } else if (!childEmpty && !childExists) {
    tree.node.children[childName] = child3.node;
    tree.node.childCount++;
    treeUpdateParents(tree);
  }
}
var INVALID_KEY_REGEX_ = /[\[\].#$\/\u0000-\u001F\u007F]/;
var INVALID_PATH_REGEX_ = /[\[\].#$\u0000-\u001F\u007F]/;
var MAX_LEAF_SIZE_ = 10 * 1024 * 1024;
var isValidKey = function(key) {
  return typeof key === "string" && key.length !== 0 && !INVALID_KEY_REGEX_.test(key);
};
var isValidPathString = function(pathString) {
  return typeof pathString === "string" && pathString.length !== 0 && !INVALID_PATH_REGEX_.test(pathString);
};
var isValidRootPathString = function(pathString) {
  if (pathString) {
    pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
  }
  return isValidPathString(pathString);
};
var isValidPriority = function(priority) {
  return priority === null || typeof priority === "string" || typeof priority === "number" && !isInvalidJSONNumber(priority) || priority && typeof priority === "object" && // eslint-disable-next-line @typescript-eslint/no-explicit-any
  contains(priority, ".sv");
};
var validateFirebaseDataArg = function(fnName, value, path, optional) {
  if (optional && value === void 0) {
    return;
  }
  validateFirebaseData(errorPrefix(fnName, "value"), value, path);
};
var validateFirebaseData = function(errorPrefix2, data, path_) {
  var path = path_ instanceof Path ? new ValidationPath(path_, errorPrefix2) : path_;
  if (data === void 0) {
    throw new Error(errorPrefix2 + "contains undefined " + validationPathToErrorString(path));
  }
  if (typeof data === "function") {
    throw new Error(errorPrefix2 + "contains a function " + validationPathToErrorString(path) + " with contents = " + data.toString());
  }
  if (isInvalidJSONNumber(data)) {
    throw new Error(errorPrefix2 + "contains " + data.toString() + " " + validationPathToErrorString(path));
  }
  if (typeof data === "string" && data.length > MAX_LEAF_SIZE_ / 3 && stringLength(data) > MAX_LEAF_SIZE_) {
    throw new Error(errorPrefix2 + "contains a string greater than " + MAX_LEAF_SIZE_ + " utf8 bytes " + validationPathToErrorString(path) + " ('" + data.substring(0, 50) + "...')");
  }
  if (data && typeof data === "object") {
    var hasDotValue_1 = false;
    var hasActualChild_1 = false;
    each(data, function(key, value) {
      if (key === ".value") {
        hasDotValue_1 = true;
      } else if (key !== ".priority" && key !== ".sv") {
        hasActualChild_1 = true;
        if (!isValidKey(key)) {
          throw new Error(errorPrefix2 + " contains an invalid key (" + key + ") " + validationPathToErrorString(path) + `.  Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
        }
      }
      validationPathPush(path, key);
      validateFirebaseData(errorPrefix2, value, path);
      validationPathPop(path);
    });
    if (hasDotValue_1 && hasActualChild_1) {
      throw new Error(errorPrefix2 + ' contains ".value" child ' + validationPathToErrorString(path) + " in addition to actual children.");
    }
  }
};
var validateFirebaseMergePaths = function(errorPrefix2, mergePaths) {
  var i, curPath;
  for (i = 0; i < mergePaths.length; i++) {
    curPath = mergePaths[i];
    var keys = pathSlice(curPath);
    for (var j = 0; j < keys.length; j++) {
      if (keys[j] === ".priority" && j === keys.length - 1) ;
      else if (!isValidKey(keys[j])) {
        throw new Error(errorPrefix2 + "contains an invalid key (" + keys[j] + ") in path " + curPath.toString() + `. Keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]"`);
      }
    }
  }
  mergePaths.sort(pathCompare);
  var prevPath = null;
  for (i = 0; i < mergePaths.length; i++) {
    curPath = mergePaths[i];
    if (prevPath !== null && pathContains(prevPath, curPath)) {
      throw new Error(errorPrefix2 + "contains a path " + prevPath.toString() + " that is ancestor of another path " + curPath.toString());
    }
    prevPath = curPath;
  }
};
var validateFirebaseMergeDataArg = function(fnName, data, path, optional) {
  if (optional && data === void 0) {
    return;
  }
  var errorPrefix$1 = errorPrefix(fnName, "values");
  if (!(data && typeof data === "object") || Array.isArray(data)) {
    throw new Error(errorPrefix$1 + " must be an object containing the children to replace.");
  }
  var mergePaths = [];
  each(data, function(key, value) {
    var curPath = new Path(key);
    validateFirebaseData(errorPrefix$1, value, pathChild(path, curPath));
    if (pathGetBack(curPath) === ".priority") {
      if (!isValidPriority(value)) {
        throw new Error(errorPrefix$1 + "contains an invalid value for '" + curPath.toString() + "', which must be a valid Firebase priority (a string, finite number, server value, or null).");
      }
    }
    mergePaths.push(curPath);
  });
  validateFirebaseMergePaths(errorPrefix$1, mergePaths);
};
var validatePriority = function(fnName, priority, optional) {
  if (optional && priority === void 0) {
    return;
  }
  if (isInvalidJSONNumber(priority)) {
    throw new Error(errorPrefix(fnName, "priority") + "is " + priority.toString() + ", but must be a valid Firebase priority (a string, finite number, server value, or null).");
  }
  if (!isValidPriority(priority)) {
    throw new Error(errorPrefix(fnName, "priority") + "must be a valid Firebase priority (a string, finite number, server value, or null).");
  }
};
var validateEventType = function(fnName, eventType, optional) {
  if (optional && eventType === void 0) {
    return;
  }
  switch (eventType) {
    case "value":
    case "child_added":
    case "child_removed":
    case "child_changed":
    case "child_moved":
      break;
    default:
      throw new Error(errorPrefix(fnName, "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
  }
};
var validateKey = function(fnName, argumentName, key, optional) {
  if (optional && key === void 0) {
    return;
  }
  if (!isValidKey(key)) {
    throw new Error(errorPrefix(fnName, argumentName) + 'was an invalid key = "' + key + `".  Firebase keys must be non-empty strings and can't contain ".", "#", "$", "/", "[", or "]").`);
  }
};
var validatePathString = function(fnName, argumentName, pathString, optional) {
  if (optional && pathString === void 0) {
    return;
  }
  if (!isValidPathString(pathString)) {
    throw new Error(errorPrefix(fnName, argumentName) + 'was an invalid path = "' + pathString + `". Paths must be non-empty strings and can't contain ".", "#", "$", "[", or "]"`);
  }
};
var validateRootPathString = function(fnName, argumentName, pathString, optional) {
  if (pathString) {
    pathString = pathString.replace(/^\/*\.info(\/|$)/, "/");
  }
  validatePathString(fnName, argumentName, pathString, optional);
};
var validateWritablePath = function(fnName, path) {
  if (pathGetFront(path) === ".info") {
    throw new Error(fnName + " failed = Can't modify data under /.info/");
  }
};
var validateUrl = function(fnName, parsedUrl) {
  var pathString = parsedUrl.path.toString();
  if (!(typeof parsedUrl.repoInfo.host === "string") || parsedUrl.repoInfo.host.length === 0 || !isValidKey(parsedUrl.repoInfo.namespace) && parsedUrl.repoInfo.host.split(":")[0] !== "localhost" || pathString.length !== 0 && !isValidRootPathString(pathString)) {
    throw new Error(errorPrefix(fnName, "url") + `must be a valid firebase URL and the path can't contain ".", "#", "$", "[", or "]".`);
  }
};
var validateBoolean = function(fnName, argumentName, bool, optional) {
  if (optional && bool === void 0) {
    return;
  }
  if (typeof bool !== "boolean") {
    throw new Error(errorPrefix(fnName, argumentName) + "must be a boolean.");
  }
};
var EventQueue = (
  /** @class */
  /* @__PURE__ */ function() {
    function EventQueue2() {
      this.eventLists_ = [];
      this.recursionDepth_ = 0;
    }
    return EventQueue2;
  }()
);
function eventQueueQueueEvents(eventQueue, eventDataList) {
  var currList = null;
  for (var i = 0; i < eventDataList.length; i++) {
    var data = eventDataList[i];
    var path = data.getPath();
    if (currList !== null && !pathEquals(path, currList.path)) {
      eventQueue.eventLists_.push(currList);
      currList = null;
    }
    if (currList === null) {
      currList = { events: [], path };
    }
    currList.events.push(data);
  }
  if (currList) {
    eventQueue.eventLists_.push(currList);
  }
}
function eventQueueRaiseEventsAtPath(eventQueue, path, eventDataList) {
  eventQueueQueueEvents(eventQueue, eventDataList);
  eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function(eventPath) {
    return pathEquals(eventPath, path);
  });
}
function eventQueueRaiseEventsForChangedPath(eventQueue, changedPath, eventDataList) {
  eventQueueQueueEvents(eventQueue, eventDataList);
  eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, function(eventPath) {
    return pathContains(eventPath, changedPath) || pathContains(changedPath, eventPath);
  });
}
function eventQueueRaiseQueuedEventsMatchingPredicate(eventQueue, predicate) {
  eventQueue.recursionDepth_++;
  var sentAll = true;
  for (var i = 0; i < eventQueue.eventLists_.length; i++) {
    var eventList = eventQueue.eventLists_[i];
    if (eventList) {
      var eventPath = eventList.path;
      if (predicate(eventPath)) {
        eventListRaise(eventQueue.eventLists_[i]);
        eventQueue.eventLists_[i] = null;
      } else {
        sentAll = false;
      }
    }
  }
  if (sentAll) {
    eventQueue.eventLists_ = [];
  }
  eventQueue.recursionDepth_--;
}
function eventListRaise(eventList) {
  for (var i = 0; i < eventList.events.length; i++) {
    var eventData = eventList.events[i];
    if (eventData !== null) {
      eventList.events[i] = null;
      var eventFn = eventData.getEventRunner();
      if (logger) {
        log("event: " + eventData.toString());
      }
      exceptionGuard(eventFn);
    }
  }
}
var INTERRUPT_REASON = "repo_interrupt";
var MAX_TRANSACTION_RETRIES = 25;
var Repo = (
  /** @class */
  function() {
    function Repo2(repoInfo_, forceRestClient_, authTokenProvider_, appCheckProvider_) {
      this.repoInfo_ = repoInfo_;
      this.forceRestClient_ = forceRestClient_;
      this.authTokenProvider_ = authTokenProvider_;
      this.appCheckProvider_ = appCheckProvider_;
      this.dataUpdateCount = 0;
      this.statsListener_ = null;
      this.eventQueue_ = new EventQueue();
      this.nextWriteId_ = 1;
      this.interceptServerDataCallback_ = null;
      this.onDisconnect_ = newSparseSnapshotTree();
      this.transactionQueueTree_ = new Tree();
      this.persistentConnection_ = null;
      this.key = this.repoInfo_.toURLString();
    }
    Repo2.prototype.toString = function() {
      return (this.repoInfo_.secure ? "https://" : "http://") + this.repoInfo_.host;
    };
    return Repo2;
  }()
);
function repoStart(repo, appId, authOverride) {
  repo.stats_ = statsManagerGetCollection(repo.repoInfo_);
  if (repo.forceRestClient_ || beingCrawled()) {
    repo.server_ = new ReadonlyRestClient(repo.repoInfo_, function(pathString, data, isMerge, tag) {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, repo.authTokenProvider_, repo.appCheckProvider_);
    setTimeout(function() {
      return repoOnConnectStatus(
        repo,
        /* connectStatus= */
        true
      );
    }, 0);
  } else {
    if (typeof authOverride !== "undefined" && authOverride !== null) {
      if (typeof authOverride !== "object") {
        throw new Error("Only objects are supported for option databaseAuthVariableOverride");
      }
      try {
        stringify(authOverride);
      } catch (e) {
        throw new Error("Invalid authOverride provided: " + e);
      }
    }
    repo.persistentConnection_ = new PersistentConnection(repo.repoInfo_, appId, function(pathString, data, isMerge, tag) {
      repoOnDataUpdate(repo, pathString, data, isMerge, tag);
    }, function(connectStatus) {
      repoOnConnectStatus(repo, connectStatus);
    }, function(updates) {
      repoOnServerInfoUpdate(repo, updates);
    }, repo.authTokenProvider_, repo.appCheckProvider_, authOverride);
    repo.server_ = repo.persistentConnection_;
  }
  repo.authTokenProvider_.addTokenChangeListener(function(token) {
    repo.server_.refreshAuthToken(token);
  });
  repo.appCheckProvider_.addTokenChangeListener(function(result) {
    repo.server_.refreshAppCheckToken(result.token);
  });
  repo.statsReporter_ = statsManagerGetOrCreateReporter(repo.repoInfo_, function() {
    return new StatsReporter(repo.stats_, repo.server_);
  });
  repo.infoData_ = new SnapshotHolder();
  repo.infoSyncTree_ = new SyncTree({
    startListening: function(query2, tag, currentHashFn, onComplete) {
      var infoEvents = [];
      var node = repo.infoData_.getNode(query2._path);
      if (!node.isEmpty()) {
        infoEvents = syncTreeApplyServerOverwrite(repo.infoSyncTree_, query2._path, node);
        setTimeout(function() {
          onComplete("ok");
        }, 0);
      }
      return infoEvents;
    },
    stopListening: function() {
    }
  });
  repoUpdateInfo(repo, "connected", false);
  repo.serverSyncTree_ = new SyncTree({
    startListening: function(query2, tag, currentHashFn, onComplete) {
      repo.server_.listen(query2, currentHashFn, tag, function(status, data) {
        var events = onComplete(status, data);
        eventQueueRaiseEventsForChangedPath(repo.eventQueue_, query2._path, events);
      });
      return [];
    },
    stopListening: function(query2, tag) {
      repo.server_.unlisten(query2, tag);
    }
  });
}
function repoServerTime(repo) {
  var offsetNode = repo.infoData_.getNode(new Path(".info/serverTimeOffset"));
  var offset = offsetNode.val() || 0;
  return (/* @__PURE__ */ new Date()).getTime() + offset;
}
function repoGenerateServerValues(repo) {
  return generateWithValues({
    timestamp: repoServerTime(repo)
  });
}
function repoOnDataUpdate(repo, pathString, data, isMerge, tag) {
  repo.dataUpdateCount++;
  var path = new Path(pathString);
  data = repo.interceptServerDataCallback_ ? repo.interceptServerDataCallback_(pathString, data) : data;
  var events = [];
  if (tag) {
    if (isMerge) {
      var taggedChildren = map(data, function(raw) {
        return nodeFromJSON(raw);
      });
      events = syncTreeApplyTaggedQueryMerge(repo.serverSyncTree_, path, taggedChildren, tag);
    } else {
      var taggedSnap = nodeFromJSON(data);
      events = syncTreeApplyTaggedQueryOverwrite(repo.serverSyncTree_, path, taggedSnap, tag);
    }
  } else if (isMerge) {
    var changedChildren = map(data, function(raw) {
      return nodeFromJSON(raw);
    });
    events = syncTreeApplyServerMerge(repo.serverSyncTree_, path, changedChildren);
  } else {
    var snap = nodeFromJSON(data);
    events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap);
  }
  var affectedPath = path;
  if (events.length > 0) {
    affectedPath = repoRerunTransactions(repo, path);
  }
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, events);
}
function repoInterceptServerData(repo, callback) {
  repo.interceptServerDataCallback_ = callback;
}
function repoOnConnectStatus(repo, connectStatus) {
  repoUpdateInfo(repo, "connected", connectStatus);
  if (connectStatus === false) {
    repoRunOnDisconnectEvents(repo);
  }
}
function repoOnServerInfoUpdate(repo, updates) {
  each(updates, function(key, value) {
    repoUpdateInfo(repo, key, value);
  });
}
function repoUpdateInfo(repo, pathString, value) {
  var path = new Path("/.info/" + pathString);
  var newNode = nodeFromJSON(value);
  repo.infoData_.updateSnapshot(path, newNode);
  var events = syncTreeApplyServerOverwrite(repo.infoSyncTree_, path, newNode);
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
}
function repoGetNextWriteId(repo) {
  return repo.nextWriteId_++;
}
function repoGetValue(repo, query2) {
  var cached = syncTreeGetServerValue(repo.serverSyncTree_, query2);
  if (cached != null) {
    return Promise.resolve(cached);
  }
  return repo.server_.get(query2).then(function(payload) {
    var node = nodeFromJSON(payload).withIndex(query2._queryParams.getIndex());
    var events = syncTreeApplyServerOverwrite(repo.serverSyncTree_, query2._path, node);
    eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
    return Promise.resolve(node);
  }, function(err) {
    repoLog(repo, "get for query " + stringify(query2) + " failed: " + err);
    return Promise.reject(new Error(err));
  });
}
function repoSetWithPriority(repo, path, newVal, newPriority, onComplete) {
  repoLog(repo, "set", {
    path: path.toString(),
    value: newVal,
    priority: newPriority
  });
  var serverValues = repoGenerateServerValues(repo);
  var newNodeUnresolved = nodeFromJSON(newVal, newPriority);
  var existing = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path);
  var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, existing, serverValues);
  var writeId = repoGetNextWriteId(repo);
  var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, writeId, true);
  eventQueueQueueEvents(repo.eventQueue_, events);
  repo.server_.put(path.toString(), newNodeUnresolved.val(
    /*export=*/
    true
  ), function(status, errorReason) {
    var success = status === "ok";
    if (!success) {
      warn("set at " + path + " failed: " + status);
    }
    var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId, !success);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, clearEvents);
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
  var affectedPath = repoAbortTransactions(repo, path);
  repoRerunTransactions(repo, affectedPath);
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, []);
}
function repoUpdate(repo, path, childrenToMerge, onComplete) {
  repoLog(repo, "update", { path: path.toString(), value: childrenToMerge });
  var empty = true;
  var serverValues = repoGenerateServerValues(repo);
  var changedChildren = {};
  each(childrenToMerge, function(changedKey, changedValue) {
    empty = false;
    changedChildren[changedKey] = resolveDeferredValueTree(pathChild(path, changedKey), nodeFromJSON(changedValue), repo.serverSyncTree_, serverValues);
  });
  if (!empty) {
    var writeId_1 = repoGetNextWriteId(repo);
    var events = syncTreeApplyUserMerge(repo.serverSyncTree_, path, changedChildren, writeId_1);
    eventQueueQueueEvents(repo.eventQueue_, events);
    repo.server_.merge(path.toString(), childrenToMerge, function(status, errorReason) {
      var success = status === "ok";
      if (!success) {
        warn("update at " + path + " failed: " + status);
      }
      var clearEvents = syncTreeAckUserWrite(repo.serverSyncTree_, writeId_1, !success);
      var affectedPath = clearEvents.length > 0 ? repoRerunTransactions(repo, path) : path;
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, affectedPath, clearEvents);
      repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
    });
    each(childrenToMerge, function(changedPath) {
      var affectedPath = repoAbortTransactions(repo, pathChild(path, changedPath));
      repoRerunTransactions(repo, affectedPath);
    });
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, []);
  } else {
    log("update() called with empty data.  Don't do anything.");
    repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
  }
}
function repoRunOnDisconnectEvents(repo) {
  repoLog(repo, "onDisconnectEvents");
  var serverValues = repoGenerateServerValues(repo);
  var resolvedOnDisconnectTree = newSparseSnapshotTree();
  sparseSnapshotTreeForEachTree(repo.onDisconnect_, newEmptyPath(), function(path, node) {
    var resolved = resolveDeferredValueTree(path, node, repo.serverSyncTree_, serverValues);
    sparseSnapshotTreeRemember(resolvedOnDisconnectTree, path, resolved);
  });
  var events = [];
  sparseSnapshotTreeForEachTree(resolvedOnDisconnectTree, newEmptyPath(), function(path, snap) {
    events = events.concat(syncTreeApplyServerOverwrite(repo.serverSyncTree_, path, snap));
    var affectedPath = repoAbortTransactions(repo, path);
    repoRerunTransactions(repo, affectedPath);
  });
  repo.onDisconnect_ = newSparseSnapshotTree();
  eventQueueRaiseEventsForChangedPath(repo.eventQueue_, newEmptyPath(), events);
}
function repoOnDisconnectCancel(repo, path, onComplete) {
  repo.server_.onDisconnectCancel(path.toString(), function(status, errorReason) {
    if (status === "ok") {
      sparseSnapshotTreeForget(repo.onDisconnect_, path);
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoOnDisconnectSet(repo, path, value, onComplete) {
  var newNode = nodeFromJSON(value);
  repo.server_.onDisconnectPut(path.toString(), newNode.val(
    /*export=*/
    true
  ), function(status, errorReason) {
    if (status === "ok") {
      sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoOnDisconnectSetWithPriority(repo, path, value, priority, onComplete) {
  var newNode = nodeFromJSON(value, priority);
  repo.server_.onDisconnectPut(path.toString(), newNode.val(
    /*export=*/
    true
  ), function(status, errorReason) {
    if (status === "ok") {
      sparseSnapshotTreeRemember(repo.onDisconnect_, path, newNode);
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoOnDisconnectUpdate(repo, path, childrenToMerge, onComplete) {
  if (isEmpty(childrenToMerge)) {
    log("onDisconnect().update() called with empty data.  Don't do anything.");
    repoCallOnCompleteCallback(repo, onComplete, "ok", void 0);
    return;
  }
  repo.server_.onDisconnectMerge(path.toString(), childrenToMerge, function(status, errorReason) {
    if (status === "ok") {
      each(childrenToMerge, function(childName, childNode) {
        var newChildNode = nodeFromJSON(childNode);
        sparseSnapshotTreeRemember(repo.onDisconnect_, pathChild(path, childName), newChildNode);
      });
    }
    repoCallOnCompleteCallback(repo, onComplete, status, errorReason);
  });
}
function repoAddEventCallbackForQuery(repo, query2, eventRegistration) {
  var events;
  if (pathGetFront(query2._path) === ".info") {
    events = syncTreeAddEventRegistration(repo.infoSyncTree_, query2, eventRegistration);
  } else {
    events = syncTreeAddEventRegistration(repo.serverSyncTree_, query2, eventRegistration);
  }
  eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
}
function repoRemoveEventCallbackForQuery(repo, query2, eventRegistration) {
  var events;
  if (pathGetFront(query2._path) === ".info") {
    events = syncTreeRemoveEventRegistration(repo.infoSyncTree_, query2, eventRegistration);
  } else {
    events = syncTreeRemoveEventRegistration(repo.serverSyncTree_, query2, eventRegistration);
  }
  eventQueueRaiseEventsAtPath(repo.eventQueue_, query2._path, events);
}
function repoInterrupt(repo) {
  if (repo.persistentConnection_) {
    repo.persistentConnection_.interrupt(INTERRUPT_REASON);
  }
}
function repoResume(repo) {
  if (repo.persistentConnection_) {
    repo.persistentConnection_.resume(INTERRUPT_REASON);
  }
}
function repoStats(repo, showDelta) {
  if (showDelta === void 0) {
    showDelta = false;
  }
  if (typeof console === "undefined") {
    return;
  }
  var stats2;
  if (showDelta) {
    if (!repo.statsListener_) {
      repo.statsListener_ = new StatsListener(repo.stats_);
    }
    stats2 = repo.statsListener_.get();
  } else {
    stats2 = repo.stats_.get();
  }
  var longestName = Object.keys(stats2).reduce(function(previousValue, currentValue) {
    return Math.max(currentValue.length, previousValue);
  }, 0);
  each(stats2, function(stat, value) {
    var paddedStat = stat;
    for (var i = stat.length; i < longestName + 2; i++) {
      paddedStat += " ";
    }
    console.log(paddedStat + value);
  });
}
function repoStatsIncrementCounter(repo, metric) {
  repo.stats_.incrementCounter(metric);
  statsReporterIncludeStat(repo.statsReporter_, metric);
}
function repoLog(repo) {
  var varArgs = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    varArgs[_i - 1] = arguments[_i];
  }
  var prefix = "";
  if (repo.persistentConnection_) {
    prefix = repo.persistentConnection_.id + ":";
  }
  log.apply(void 0, __spreadArray([prefix], __read(varArgs)));
}
function repoCallOnCompleteCallback(repo, callback, status, errorReason) {
  if (callback) {
    exceptionGuard(function() {
      if (status === "ok") {
        callback(null);
      } else {
        var code = (status || "error").toUpperCase();
        var message = code;
        if (errorReason) {
          message += ": " + errorReason;
        }
        var error2 = new Error(message);
        error2.code = code;
        callback(error2);
      }
    });
  }
}
function repoStartTransaction(repo, path, transactionUpdate, onComplete, unwatcher, applyLocally) {
  repoLog(repo, "transaction on " + path);
  var transaction = {
    path,
    update: transactionUpdate,
    onComplete,
    // One of TransactionStatus enums.
    status: null,
    // Used when combining transactions at different locations to figure out
    // which one goes first.
    order: LUIDGenerator(),
    // Whether to raise local events for this transaction.
    applyLocally,
    // Count of how many times we've retried the transaction.
    retryCount: 0,
    // Function to call to clean up our .on() listener.
    unwatcher,
    // Stores why a transaction was aborted.
    abortReason: null,
    currentWriteId: null,
    currentInputSnapshot: null,
    currentOutputSnapshotRaw: null,
    currentOutputSnapshotResolved: null
  };
  var currentState = repoGetLatestState(repo, path, void 0);
  transaction.currentInputSnapshot = currentState;
  var newVal = transaction.update(currentState.val());
  if (newVal === void 0) {
    transaction.unwatcher();
    transaction.currentOutputSnapshotRaw = null;
    transaction.currentOutputSnapshotResolved = null;
    if (transaction.onComplete) {
      transaction.onComplete(null, false, transaction.currentInputSnapshot);
    }
  } else {
    validateFirebaseData("transaction failed: Data returned ", newVal, transaction.path);
    transaction.status = 0;
    var queueNode = treeSubTree(repo.transactionQueueTree_, path);
    var nodeQueue = treeGetValue(queueNode) || [];
    nodeQueue.push(transaction);
    treeSetValue(queueNode, nodeQueue);
    var priorityForNode = void 0;
    if (typeof newVal === "object" && newVal !== null && contains(newVal, ".priority")) {
      priorityForNode = safeGet(newVal, ".priority");
      assert(isValidPriority(priorityForNode), "Invalid priority returned by transaction. Priority must be a valid string, finite number, server value, or null.");
    } else {
      var currentNode = syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path) || ChildrenNode.EMPTY_NODE;
      priorityForNode = currentNode.getPriority().val();
    }
    var serverValues = repoGenerateServerValues(repo);
    var newNodeUnresolved = nodeFromJSON(newVal, priorityForNode);
    var newNode = resolveDeferredValueSnapshot(newNodeUnresolved, currentState, serverValues);
    transaction.currentOutputSnapshotRaw = newNodeUnresolved;
    transaction.currentOutputSnapshotResolved = newNode;
    transaction.currentWriteId = repoGetNextWriteId(repo);
    var events = syncTreeApplyUserOverwrite(repo.serverSyncTree_, path, newNode, transaction.currentWriteId, transaction.applyLocally);
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
    repoSendReadyTransactions(repo, repo.transactionQueueTree_);
  }
}
function repoGetLatestState(repo, path, excludeSets) {
  return syncTreeCalcCompleteEventCache(repo.serverSyncTree_, path, excludeSets) || ChildrenNode.EMPTY_NODE;
}
function repoSendReadyTransactions(repo, node) {
  if (node === void 0) {
    node = repo.transactionQueueTree_;
  }
  if (!node) {
    repoPruneCompletedTransactionsBelowNode(repo, node);
  }
  if (treeGetValue(node)) {
    var queue2 = repoBuildTransactionQueue(repo, node);
    assert(queue2.length > 0, "Sending zero length transaction queue");
    var allRun = queue2.every(function(transaction) {
      return transaction.status === 0;
    });
    if (allRun) {
      repoSendTransactionQueue(repo, treeGetPath(node), queue2);
    }
  } else if (treeHasChildren(node)) {
    treeForEachChild(node, function(childNode) {
      repoSendReadyTransactions(repo, childNode);
    });
  }
}
function repoSendTransactionQueue(repo, path, queue2) {
  var setsToIgnore = queue2.map(function(txn2) {
    return txn2.currentWriteId;
  });
  var latestState = repoGetLatestState(repo, path, setsToIgnore);
  var snapToSend = latestState;
  var latestHash = latestState.hash();
  for (var i = 0; i < queue2.length; i++) {
    var txn = queue2[i];
    assert(txn.status === 0, "tryToSendTransactionQueue_: items in queue should all be run.");
    txn.status = 1;
    txn.retryCount++;
    var relativePath = newRelativePath(path, txn.path);
    snapToSend = snapToSend.updateChild(relativePath, txn.currentOutputSnapshotRaw);
  }
  var dataToSend = snapToSend.val(true);
  var pathToSend = path;
  repo.server_.put(pathToSend.toString(), dataToSend, function(status) {
    repoLog(repo, "transaction put response", {
      path: pathToSend.toString(),
      status
    });
    var events = [];
    if (status === "ok") {
      var callbacks = [];
      var _loop_1 = function(i3) {
        queue2[i3].status = 2;
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue2[i3].currentWriteId));
        if (queue2[i3].onComplete) {
          callbacks.push(function() {
            return queue2[i3].onComplete(null, true, queue2[i3].currentOutputSnapshotResolved);
          });
        }
        queue2[i3].unwatcher();
      };
      for (var i2 = 0; i2 < queue2.length; i2++) {
        _loop_1(i2);
      }
      repoPruneCompletedTransactionsBelowNode(repo, treeSubTree(repo.transactionQueueTree_, path));
      repoSendReadyTransactions(repo, repo.transactionQueueTree_);
      eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
      for (var i2 = 0; i2 < callbacks.length; i2++) {
        exceptionGuard(callbacks[i2]);
      }
    } else {
      if (status === "datastale") {
        for (var i2 = 0; i2 < queue2.length; i2++) {
          if (queue2[i2].status === 3) {
            queue2[i2].status = 4;
          } else {
            queue2[i2].status = 0;
          }
        }
      } else {
        warn("transaction at " + pathToSend.toString() + " failed: " + status);
        for (var i2 = 0; i2 < queue2.length; i2++) {
          queue2[i2].status = 4;
          queue2[i2].abortReason = status;
        }
      }
      repoRerunTransactions(repo, path);
    }
  }, latestHash);
}
function repoRerunTransactions(repo, changedPath) {
  var rootMostTransactionNode = repoGetAncestorTransactionNode(repo, changedPath);
  var path = treeGetPath(rootMostTransactionNode);
  var queue2 = repoBuildTransactionQueue(repo, rootMostTransactionNode);
  repoRerunTransactionQueue(repo, queue2, path);
  return path;
}
function repoRerunTransactionQueue(repo, queue2, path) {
  if (queue2.length === 0) {
    return;
  }
  var callbacks = [];
  var events = [];
  var txnsToRerun = queue2.filter(function(q) {
    return q.status === 0;
  });
  var setsToIgnore = txnsToRerun.map(function(q) {
    return q.currentWriteId;
  });
  var _loop_2 = function(i2) {
    var transaction = queue2[i2];
    var relativePath = newRelativePath(path, transaction.path);
    var abortTransaction = false, abortReason;
    assert(relativePath !== null, "rerunTransactionsUnderNode_: relativePath should not be null.");
    if (transaction.status === 4) {
      abortTransaction = true;
      abortReason = transaction.abortReason;
      events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
    } else if (transaction.status === 0) {
      if (transaction.retryCount >= MAX_TRANSACTION_RETRIES) {
        abortTransaction = true;
        abortReason = "maxretry";
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
      } else {
        var currentNode = repoGetLatestState(repo, transaction.path, setsToIgnore);
        transaction.currentInputSnapshot = currentNode;
        var newData = queue2[i2].update(currentNode.val());
        if (newData !== void 0) {
          validateFirebaseData("transaction failed: Data returned ", newData, transaction.path);
          var newDataNode = nodeFromJSON(newData);
          var hasExplicitPriority = typeof newData === "object" && newData != null && contains(newData, ".priority");
          if (!hasExplicitPriority) {
            newDataNode = newDataNode.updatePriority(currentNode.getPriority());
          }
          var oldWriteId = transaction.currentWriteId;
          var serverValues = repoGenerateServerValues(repo);
          var newNodeResolved = resolveDeferredValueSnapshot(newDataNode, currentNode, serverValues);
          transaction.currentOutputSnapshotRaw = newDataNode;
          transaction.currentOutputSnapshotResolved = newNodeResolved;
          transaction.currentWriteId = repoGetNextWriteId(repo);
          setsToIgnore.splice(setsToIgnore.indexOf(oldWriteId), 1);
          events = events.concat(syncTreeApplyUserOverwrite(repo.serverSyncTree_, transaction.path, newNodeResolved, transaction.currentWriteId, transaction.applyLocally));
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, oldWriteId, true));
        } else {
          abortTransaction = true;
          abortReason = "nodata";
          events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, transaction.currentWriteId, true));
        }
      }
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, path, events);
    events = [];
    if (abortTransaction) {
      queue2[i2].status = 2;
      (function(unwatcher) {
        setTimeout(unwatcher, Math.floor(0));
      })(queue2[i2].unwatcher);
      if (queue2[i2].onComplete) {
        if (abortReason === "nodata") {
          callbacks.push(function() {
            return queue2[i2].onComplete(null, false, queue2[i2].currentInputSnapshot);
          });
        } else {
          callbacks.push(function() {
            return queue2[i2].onComplete(new Error(abortReason), false, null);
          });
        }
      }
    }
  };
  for (var i = 0; i < queue2.length; i++) {
    _loop_2(i);
  }
  repoPruneCompletedTransactionsBelowNode(repo, repo.transactionQueueTree_);
  for (var i = 0; i < callbacks.length; i++) {
    exceptionGuard(callbacks[i]);
  }
  repoSendReadyTransactions(repo, repo.transactionQueueTree_);
}
function repoGetAncestorTransactionNode(repo, path) {
  var front;
  var transactionNode = repo.transactionQueueTree_;
  front = pathGetFront(path);
  while (front !== null && treeGetValue(transactionNode) === void 0) {
    transactionNode = treeSubTree(transactionNode, front);
    path = pathPopFront(path);
    front = pathGetFront(path);
  }
  return transactionNode;
}
function repoBuildTransactionQueue(repo, transactionNode) {
  var transactionQueue = [];
  repoAggregateTransactionQueuesForNode(repo, transactionNode, transactionQueue);
  transactionQueue.sort(function(a, b) {
    return a.order - b.order;
  });
  return transactionQueue;
}
function repoAggregateTransactionQueuesForNode(repo, node, queue2) {
  var nodeQueue = treeGetValue(node);
  if (nodeQueue) {
    for (var i = 0; i < nodeQueue.length; i++) {
      queue2.push(nodeQueue[i]);
    }
  }
  treeForEachChild(node, function(child3) {
    repoAggregateTransactionQueuesForNode(repo, child3, queue2);
  });
}
function repoPruneCompletedTransactionsBelowNode(repo, node) {
  var queue2 = treeGetValue(node);
  if (queue2) {
    var to = 0;
    for (var from = 0; from < queue2.length; from++) {
      if (queue2[from].status !== 2) {
        queue2[to] = queue2[from];
        to++;
      }
    }
    queue2.length = to;
    treeSetValue(node, queue2.length > 0 ? queue2 : void 0);
  }
  treeForEachChild(node, function(childNode) {
    repoPruneCompletedTransactionsBelowNode(repo, childNode);
  });
}
function repoAbortTransactions(repo, path) {
  var affectedPath = treeGetPath(repoGetAncestorTransactionNode(repo, path));
  var transactionNode = treeSubTree(repo.transactionQueueTree_, path);
  treeForEachAncestor(transactionNode, function(node) {
    repoAbortTransactionsOnNode(repo, node);
  });
  repoAbortTransactionsOnNode(repo, transactionNode);
  treeForEachDescendant(transactionNode, function(node) {
    repoAbortTransactionsOnNode(repo, node);
  });
  return affectedPath;
}
function repoAbortTransactionsOnNode(repo, node) {
  var queue2 = treeGetValue(node);
  if (queue2) {
    var callbacks = [];
    var events = [];
    var lastSent = -1;
    for (var i = 0; i < queue2.length; i++) {
      if (queue2[i].status === 3) ;
      else if (queue2[i].status === 1) {
        assert(lastSent === i - 1, "All SENT items should be at beginning of queue.");
        lastSent = i;
        queue2[i].status = 3;
        queue2[i].abortReason = "set";
      } else {
        assert(queue2[i].status === 0, "Unexpected transaction status in abort");
        queue2[i].unwatcher();
        events = events.concat(syncTreeAckUserWrite(repo.serverSyncTree_, queue2[i].currentWriteId, true));
        if (queue2[i].onComplete) {
          callbacks.push(queue2[i].onComplete.bind(null, new Error("set"), false, null));
        }
      }
    }
    if (lastSent === -1) {
      treeSetValue(node, void 0);
    } else {
      queue2.length = lastSent + 1;
    }
    eventQueueRaiseEventsForChangedPath(repo.eventQueue_, treeGetPath(node), events);
    for (var i = 0; i < callbacks.length; i++) {
      exceptionGuard(callbacks[i]);
    }
  }
}
function decodePath(pathString) {
  var pathStringDecoded = "";
  var pieces = pathString.split("/");
  for (var i = 0; i < pieces.length; i++) {
    if (pieces[i].length > 0) {
      var piece = pieces[i];
      try {
        piece = decodeURIComponent(piece.replace(/\+/g, " "));
      } catch (e) {
      }
      pathStringDecoded += "/" + piece;
    }
  }
  return pathStringDecoded;
}
function decodeQuery(queryString) {
  var e_1, _a7;
  var results = {};
  if (queryString.charAt(0) === "?") {
    queryString = queryString.substring(1);
  }
  try {
    for (var _b = __values(queryString.split("&")), _c = _b.next(); !_c.done; _c = _b.next()) {
      var segment = _c.value;
      if (segment.length === 0) {
        continue;
      }
      var kv = segment.split("=");
      if (kv.length === 2) {
        results[decodeURIComponent(kv[0])] = decodeURIComponent(kv[1]);
      } else {
        warn("Invalid query segment '" + segment + "' in query '" + queryString + "'");
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a7 = _b.return)) _a7.call(_b);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return results;
}
var parseRepoInfo = function(dataURL, nodeAdmin) {
  var parsedUrl = parseDatabaseURL(dataURL), namespace = parsedUrl.namespace;
  if (parsedUrl.domain === "firebase.com") {
    fatal(parsedUrl.host + " is no longer supported. Please use <YOUR FIREBASE>.firebaseio.com instead");
  }
  if ((!namespace || namespace === "undefined") && parsedUrl.domain !== "localhost") {
    fatal("Cannot parse Firebase url. Please use https://<YOUR FIREBASE>.firebaseio.com");
  }
  if (!parsedUrl.secure) {
    warnIfPageIsSecure();
  }
  var webSocketOnly = parsedUrl.scheme === "ws" || parsedUrl.scheme === "wss";
  return {
    repoInfo: new RepoInfo(
      parsedUrl.host,
      parsedUrl.secure,
      namespace,
      nodeAdmin,
      webSocketOnly,
      /*persistenceKey=*/
      "",
      /*includeNamespaceInQueryParams=*/
      namespace !== parsedUrl.subdomain
    ),
    path: new Path(parsedUrl.pathString)
  };
};
var parseDatabaseURL = function(dataURL) {
  var host = "", domain = "", subdomain = "", pathString = "", namespace = "";
  var secure = true, scheme = "https", port = 443;
  if (typeof dataURL === "string") {
    var colonInd = dataURL.indexOf("//");
    if (colonInd >= 0) {
      scheme = dataURL.substring(0, colonInd - 1);
      dataURL = dataURL.substring(colonInd + 2);
    }
    var slashInd = dataURL.indexOf("/");
    if (slashInd === -1) {
      slashInd = dataURL.length;
    }
    var questionMarkInd = dataURL.indexOf("?");
    if (questionMarkInd === -1) {
      questionMarkInd = dataURL.length;
    }
    host = dataURL.substring(0, Math.min(slashInd, questionMarkInd));
    if (slashInd < questionMarkInd) {
      pathString = decodePath(dataURL.substring(slashInd, questionMarkInd));
    }
    var queryParams = decodeQuery(dataURL.substring(Math.min(dataURL.length, questionMarkInd)));
    colonInd = host.indexOf(":");
    if (colonInd >= 0) {
      secure = scheme === "https" || scheme === "wss";
      port = parseInt(host.substring(colonInd + 1), 10);
    } else {
      colonInd = host.length;
    }
    var hostWithoutPort = host.slice(0, colonInd);
    if (hostWithoutPort.toLowerCase() === "localhost") {
      domain = "localhost";
    } else if (hostWithoutPort.split(".").length <= 2) {
      domain = hostWithoutPort;
    } else {
      var dotInd = host.indexOf(".");
      subdomain = host.substring(0, dotInd).toLowerCase();
      domain = host.substring(dotInd + 1);
      namespace = subdomain;
    }
    if ("ns" in queryParams) {
      namespace = queryParams["ns"];
    }
  }
  return {
    host,
    port,
    domain,
    subdomain,
    secure,
    scheme,
    pathString,
    namespace
  };
};
var DataEvent = (
  /** @class */
  function() {
    function DataEvent2(eventType, eventRegistration, snapshot, prevName) {
      this.eventType = eventType;
      this.eventRegistration = eventRegistration;
      this.snapshot = snapshot;
      this.prevName = prevName;
    }
    DataEvent2.prototype.getPath = function() {
      var ref3 = this.snapshot.ref;
      if (this.eventType === "value") {
        return ref3._path;
      } else {
        return ref3.parent._path;
      }
    };
    DataEvent2.prototype.getEventType = function() {
      return this.eventType;
    };
    DataEvent2.prototype.getEventRunner = function() {
      return this.eventRegistration.getEventRunner(this);
    };
    DataEvent2.prototype.toString = function() {
      return this.getPath().toString() + ":" + this.eventType + ":" + stringify(this.snapshot.exportVal());
    };
    return DataEvent2;
  }()
);
var CancelEvent = (
  /** @class */
  function() {
    function CancelEvent2(eventRegistration, error2, path) {
      this.eventRegistration = eventRegistration;
      this.error = error2;
      this.path = path;
    }
    CancelEvent2.prototype.getPath = function() {
      return this.path;
    };
    CancelEvent2.prototype.getEventType = function() {
      return "cancel";
    };
    CancelEvent2.prototype.getEventRunner = function() {
      return this.eventRegistration.getEventRunner(this);
    };
    CancelEvent2.prototype.toString = function() {
      return this.path.toString() + ":cancel";
    };
    return CancelEvent2;
  }()
);
var CallbackContext = (
  /** @class */
  function() {
    function CallbackContext2(snapshotCallback, cancelCallback) {
      this.snapshotCallback = snapshotCallback;
      this.cancelCallback = cancelCallback;
    }
    CallbackContext2.prototype.onValue = function(expDataSnapshot, previousChildName) {
      this.snapshotCallback.call(null, expDataSnapshot, previousChildName);
    };
    CallbackContext2.prototype.onCancel = function(error2) {
      assert(this.hasCancelCallback, "Raising a cancel event on a listener with no cancel callback");
      return this.cancelCallback.call(null, error2);
    };
    Object.defineProperty(CallbackContext2.prototype, "hasCancelCallback", {
      get: function() {
        return !!this.cancelCallback;
      },
      enumerable: false,
      configurable: true
    });
    CallbackContext2.prototype.matches = function(other) {
      return this.snapshotCallback === other.snapshotCallback || this.snapshotCallback.userCallback !== void 0 && this.snapshotCallback.userCallback === other.snapshotCallback.userCallback && this.snapshotCallback.context === other.snapshotCallback.context;
    };
    return CallbackContext2;
  }()
);
var OnDisconnect$1 = (
  /** @class */
  function() {
    function OnDisconnect2(_repo, _path) {
      this._repo = _repo;
      this._path = _path;
    }
    OnDisconnect2.prototype.cancel = function() {
      var deferred = new Deferred();
      repoOnDisconnectCancel(this._repo, this._path, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    };
    OnDisconnect2.prototype.remove = function() {
      validateWritablePath("OnDisconnect.remove", this._path);
      var deferred = new Deferred();
      repoOnDisconnectSet(this._repo, this._path, null, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    };
    OnDisconnect2.prototype.set = function(value) {
      validateWritablePath("OnDisconnect.set", this._path);
      validateFirebaseDataArg("OnDisconnect.set", value, this._path, false);
      var deferred = new Deferred();
      repoOnDisconnectSet(this._repo, this._path, value, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    };
    OnDisconnect2.prototype.setWithPriority = function(value, priority) {
      validateWritablePath("OnDisconnect.setWithPriority", this._path);
      validateFirebaseDataArg("OnDisconnect.setWithPriority", value, this._path, false);
      validatePriority("OnDisconnect.setWithPriority", priority, false);
      var deferred = new Deferred();
      repoOnDisconnectSetWithPriority(this._repo, this._path, value, priority, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    };
    OnDisconnect2.prototype.update = function(values) {
      validateWritablePath("OnDisconnect.update", this._path);
      validateFirebaseMergeDataArg("OnDisconnect.update", values, this._path, false);
      var deferred = new Deferred();
      repoOnDisconnectUpdate(this._repo, this._path, values, deferred.wrapCallback(function() {
      }));
      return deferred.promise;
    };
    return OnDisconnect2;
  }()
);
var QueryImpl = (
  /** @class */
  function() {
    function QueryImpl2(_repo, _path, _queryParams, _orderByCalled) {
      this._repo = _repo;
      this._path = _path;
      this._queryParams = _queryParams;
      this._orderByCalled = _orderByCalled;
    }
    Object.defineProperty(QueryImpl2.prototype, "key", {
      get: function() {
        if (pathIsEmpty(this._path)) {
          return null;
        } else {
          return pathGetBack(this._path);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QueryImpl2.prototype, "ref", {
      get: function() {
        return new ReferenceImpl(this._repo, this._path);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QueryImpl2.prototype, "_queryIdentifier", {
      get: function() {
        var obj = queryParamsGetQueryObject(this._queryParams);
        var id = ObjectToUniqueKey(obj);
        return id === "{}" ? "default" : id;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(QueryImpl2.prototype, "_queryObject", {
      /**
       * An object representation of the query parameters used by this Query.
       */
      get: function() {
        return queryParamsGetQueryObject(this._queryParams);
      },
      enumerable: false,
      configurable: true
    });
    QueryImpl2.prototype.isEqual = function(other) {
      other = getModularInstance(other);
      if (!(other instanceof QueryImpl2)) {
        return false;
      }
      var sameRepo = this._repo === other._repo;
      var samePath = pathEquals(this._path, other._path);
      var sameQueryIdentifier = this._queryIdentifier === other._queryIdentifier;
      return sameRepo && samePath && sameQueryIdentifier;
    };
    QueryImpl2.prototype.toJSON = function() {
      return this.toString();
    };
    QueryImpl2.prototype.toString = function() {
      return this._repo.toString() + pathToUrlEncodedString(this._path);
    };
    return QueryImpl2;
  }()
);
function validateNoPreviousOrderByCall(query2, fnName) {
  if (query2._orderByCalled === true) {
    throw new Error(fnName + ": You can't combine multiple orderBy calls.");
  }
}
function validateQueryEndpoints(params) {
  var startNode = null;
  var endNode = null;
  if (params.hasStart()) {
    startNode = params.getIndexStartValue();
  }
  if (params.hasEnd()) {
    endNode = params.getIndexEndValue();
  }
  if (params.getIndex() === KEY_INDEX) {
    var tooManyArgsError = "Query: When ordering by key, you may only pass one argument to startAt(), endAt(), or equalTo().";
    var wrongArgTypeError = "Query: When ordering by key, the argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() must be a string.";
    if (params.hasStart()) {
      var startName = params.getIndexStartName();
      if (startName !== MIN_NAME) {
        throw new Error(tooManyArgsError);
      } else if (typeof startNode !== "string") {
        throw new Error(wrongArgTypeError);
      }
    }
    if (params.hasEnd()) {
      var endName = params.getIndexEndName();
      if (endName !== MAX_NAME) {
        throw new Error(tooManyArgsError);
      } else if (typeof endNode !== "string") {
        throw new Error(wrongArgTypeError);
      }
    }
  } else if (params.getIndex() === PRIORITY_INDEX) {
    if (startNode != null && !isValidPriority(startNode) || endNode != null && !isValidPriority(endNode)) {
      throw new Error("Query: When ordering by priority, the first argument passed to startAt(), startAfter() endAt(), endBefore(), or equalTo() must be a valid priority value (null, a number, or a string).");
    }
  } else {
    assert(params.getIndex() instanceof PathIndex || params.getIndex() === VALUE_INDEX, "unknown index type.");
    if (startNode != null && typeof startNode === "object" || endNode != null && typeof endNode === "object") {
      throw new Error("Query: First argument passed to startAt(), startAfter(), endAt(), endBefore(), or equalTo() cannot be an object.");
    }
  }
}
function validateLimit(params) {
  if (params.hasStart() && params.hasEnd() && params.hasLimit() && !params.hasAnchoredLimit()) {
    throw new Error("Query: Can't combine startAt(), startAfter(), endAt(), endBefore(), and limit(). Use limitToFirst() or limitToLast() instead.");
  }
}
var ReferenceImpl = (
  /** @class */
  function(_super) {
    __extends(ReferenceImpl2, _super);
    function ReferenceImpl2(repo, path) {
      return _super.call(this, repo, path, new QueryParams(), false) || this;
    }
    Object.defineProperty(ReferenceImpl2.prototype, "parent", {
      get: function() {
        var parentPath = pathParent(this._path);
        return parentPath === null ? null : new ReferenceImpl2(this._repo, parentPath);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceImpl2.prototype, "root", {
      get: function() {
        var ref3 = this;
        while (ref3.parent !== null) {
          ref3 = ref3.parent;
        }
        return ref3;
      },
      enumerable: false,
      configurable: true
    });
    return ReferenceImpl2;
  }(QueryImpl)
);
var DataSnapshot$1 = (
  /** @class */
  function() {
    function DataSnapshot2(_node, ref3, _index) {
      this._node = _node;
      this.ref = ref3;
      this._index = _index;
    }
    Object.defineProperty(DataSnapshot2.prototype, "priority", {
      /**
       * Gets the priority value of the data in this `DataSnapshot`.
       *
       * Applications need not use priority but can order collections by
       * ordinary properties (see
       * {@link https://firebase.google.com/docs/database/web/lists-of-data#sorting_and_filtering_data |Sorting and filtering data}
       * ).
       */
      get: function() {
        return this._node.getPriority().val();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DataSnapshot2.prototype, "key", {
      /**
       * The key (last part of the path) of the location of this `DataSnapshot`.
       *
       * The last token in a Database location is considered its key. For example,
       * "ada" is the key for the /users/ada/ node. Accessing the key on any
       * `DataSnapshot` will return the key for the location that generated it.
       * However, accessing the key on the root URL of a Database will return
       * `null`.
       */
      get: function() {
        return this.ref.key;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(DataSnapshot2.prototype, "size", {
      /** Returns the number of child properties of this `DataSnapshot`. */
      get: function() {
        return this._node.numChildren();
      },
      enumerable: false,
      configurable: true
    });
    DataSnapshot2.prototype.child = function(path) {
      var childPath = new Path(path);
      var childRef = child(this.ref, path);
      return new DataSnapshot2(this._node.getChild(childPath), childRef, PRIORITY_INDEX);
    };
    DataSnapshot2.prototype.exists = function() {
      return !this._node.isEmpty();
    };
    DataSnapshot2.prototype.exportVal = function() {
      return this._node.val(true);
    };
    DataSnapshot2.prototype.forEach = function(action) {
      var _this = this;
      if (this._node.isLeafNode()) {
        return false;
      }
      var childrenNode = this._node;
      return !!childrenNode.forEachChild(this._index, function(key, node) {
        return action(new DataSnapshot2(node, child(_this.ref, key), PRIORITY_INDEX));
      });
    };
    DataSnapshot2.prototype.hasChild = function(path) {
      var childPath = new Path(path);
      return !this._node.getChild(childPath).isEmpty();
    };
    DataSnapshot2.prototype.hasChildren = function() {
      if (this._node.isLeafNode()) {
        return false;
      } else {
        return !this._node.isEmpty();
      }
    };
    DataSnapshot2.prototype.toJSON = function() {
      return this.exportVal();
    };
    DataSnapshot2.prototype.val = function() {
      return this._node.val();
    };
    return DataSnapshot2;
  }()
);
function ref(db, path) {
  db = getModularInstance(db);
  db._checkNotDeleted("ref");
  return path !== void 0 ? child(db._root, path) : db._root;
}
function refFromURL(db, url) {
  db = getModularInstance(db);
  db._checkNotDeleted("refFromURL");
  var parsedURL = parseRepoInfo(url, db._repo.repoInfo_.nodeAdmin);
  validateUrl("refFromURL", parsedURL);
  var repoInfo = parsedURL.repoInfo;
  if (!db._repo.repoInfo_.isCustomHost() && repoInfo.host !== db._repo.repoInfo_.host) {
    fatal("refFromURL: Host name does not match the current database: (found " + repoInfo.host + " but expected " + db._repo.repoInfo_.host + ")");
  }
  return ref(db, parsedURL.path.toString());
}
function child(parent2, path) {
  parent2 = getModularInstance(parent2);
  if (pathGetFront(parent2._path) === null) {
    validateRootPathString("child", "path", path, false);
  } else {
    validatePathString("child", "path", path, false);
  }
  return new ReferenceImpl(parent2._repo, pathChild(parent2._path, path));
}
function push(parent2, value) {
  parent2 = getModularInstance(parent2);
  validateWritablePath("push", parent2._path);
  validateFirebaseDataArg("push", value, parent2._path, true);
  var now = repoServerTime(parent2._repo);
  var name10 = nextPushId(now);
  var thennablePushRef = child(parent2, name10);
  var pushRef = child(parent2, name10);
  var promise;
  if (value != null) {
    promise = set(pushRef, value).then(function() {
      return pushRef;
    });
  } else {
    promise = Promise.resolve(pushRef);
  }
  thennablePushRef.then = promise.then.bind(promise);
  thennablePushRef.catch = promise.then.bind(promise, void 0);
  return thennablePushRef;
}
function remove(ref3) {
  validateWritablePath("remove", ref3._path);
  return set(ref3, null);
}
function set(ref3, value) {
  ref3 = getModularInstance(ref3);
  validateWritablePath("set", ref3._path);
  validateFirebaseDataArg("set", value, ref3._path, false);
  var deferred = new Deferred();
  repoSetWithPriority(
    ref3._repo,
    ref3._path,
    value,
    /*priority=*/
    null,
    deferred.wrapCallback(function() {
    })
  );
  return deferred.promise;
}
function setPriority(ref3, priority) {
  ref3 = getModularInstance(ref3);
  validateWritablePath("setPriority", ref3._path);
  validatePriority("setPriority", priority, false);
  var deferred = new Deferred();
  repoSetWithPriority(ref3._repo, pathChild(ref3._path, ".priority"), priority, null, deferred.wrapCallback(function() {
  }));
  return deferred.promise;
}
function setWithPriority(ref3, value, priority) {
  validateWritablePath("setWithPriority", ref3._path);
  validateFirebaseDataArg("setWithPriority", value, ref3._path, false);
  validatePriority("setWithPriority", priority, false);
  if (ref3.key === ".length" || ref3.key === ".keys") {
    throw "setWithPriority failed: " + ref3.key + " is a read-only object.";
  }
  var deferred = new Deferred();
  repoSetWithPriority(ref3._repo, ref3._path, value, priority, deferred.wrapCallback(function() {
  }));
  return deferred.promise;
}
function update(ref3, values) {
  validateFirebaseMergeDataArg("update", values, ref3._path, false);
  var deferred = new Deferred();
  repoUpdate(ref3._repo, ref3._path, values, deferred.wrapCallback(function() {
  }));
  return deferred.promise;
}
function get(query2) {
  query2 = getModularInstance(query2);
  return repoGetValue(query2._repo, query2).then(function(node) {
    return new DataSnapshot$1(node, new ReferenceImpl(query2._repo, query2._path), query2._queryParams.getIndex());
  });
}
var ValueEventRegistration = (
  /** @class */
  function() {
    function ValueEventRegistration2(callbackContext) {
      this.callbackContext = callbackContext;
    }
    ValueEventRegistration2.prototype.respondsTo = function(eventType) {
      return eventType === "value";
    };
    ValueEventRegistration2.prototype.createEvent = function(change, query2) {
      var index = query2._queryParams.getIndex();
      return new DataEvent("value", this, new DataSnapshot$1(change.snapshotNode, new ReferenceImpl(query2._repo, query2._path), index));
    };
    ValueEventRegistration2.prototype.getEventRunner = function(eventData) {
      var _this = this;
      if (eventData.getEventType() === "cancel") {
        return function() {
          return _this.callbackContext.onCancel(eventData.error);
        };
      } else {
        return function() {
          return _this.callbackContext.onValue(eventData.snapshot, null);
        };
      }
    };
    ValueEventRegistration2.prototype.createCancelEvent = function(error2, path) {
      if (this.callbackContext.hasCancelCallback) {
        return new CancelEvent(this, error2, path);
      } else {
        return null;
      }
    };
    ValueEventRegistration2.prototype.matches = function(other) {
      if (!(other instanceof ValueEventRegistration2)) {
        return false;
      } else if (!other.callbackContext || !this.callbackContext) {
        return true;
      } else {
        return other.callbackContext.matches(this.callbackContext);
      }
    };
    ValueEventRegistration2.prototype.hasAnyCallback = function() {
      return this.callbackContext !== null;
    };
    return ValueEventRegistration2;
  }()
);
var ChildEventRegistration = (
  /** @class */
  function() {
    function ChildEventRegistration2(eventType, callbackContext) {
      this.eventType = eventType;
      this.callbackContext = callbackContext;
    }
    ChildEventRegistration2.prototype.respondsTo = function(eventType) {
      var eventToCheck = eventType === "children_added" ? "child_added" : eventType;
      eventToCheck = eventToCheck === "children_removed" ? "child_removed" : eventToCheck;
      return this.eventType === eventToCheck;
    };
    ChildEventRegistration2.prototype.createCancelEvent = function(error2, path) {
      if (this.callbackContext.hasCancelCallback) {
        return new CancelEvent(this, error2, path);
      } else {
        return null;
      }
    };
    ChildEventRegistration2.prototype.createEvent = function(change, query2) {
      assert(change.childName != null, "Child events should have a childName.");
      var childRef = child(new ReferenceImpl(query2._repo, query2._path), change.childName);
      var index = query2._queryParams.getIndex();
      return new DataEvent(change.type, this, new DataSnapshot$1(change.snapshotNode, childRef, index), change.prevName);
    };
    ChildEventRegistration2.prototype.getEventRunner = function(eventData) {
      var _this = this;
      if (eventData.getEventType() === "cancel") {
        return function() {
          return _this.callbackContext.onCancel(eventData.error);
        };
      } else {
        return function() {
          return _this.callbackContext.onValue(eventData.snapshot, eventData.prevName);
        };
      }
    };
    ChildEventRegistration2.prototype.matches = function(other) {
      if (other instanceof ChildEventRegistration2) {
        return this.eventType === other.eventType && (!this.callbackContext || !other.callbackContext || this.callbackContext.matches(other.callbackContext));
      }
      return false;
    };
    ChildEventRegistration2.prototype.hasAnyCallback = function() {
      return !!this.callbackContext;
    };
    return ChildEventRegistration2;
  }()
);
function addEventListener(query2, eventType, callback, cancelCallbackOrListenOptions, options) {
  var cancelCallback;
  if (typeof cancelCallbackOrListenOptions === "object") {
    cancelCallback = void 0;
    options = cancelCallbackOrListenOptions;
  }
  if (typeof cancelCallbackOrListenOptions === "function") {
    cancelCallback = cancelCallbackOrListenOptions;
  }
  if (options && options.onlyOnce) {
    var userCallback_1 = callback;
    var onceCallback = function(dataSnapshot, previousChildName) {
      repoRemoveEventCallbackForQuery(query2._repo, query2, container);
      userCallback_1(dataSnapshot, previousChildName);
    };
    onceCallback.userCallback = callback.userCallback;
    onceCallback.context = callback.context;
    callback = onceCallback;
  }
  var callbackContext = new CallbackContext(callback, cancelCallback || void 0);
  var container = eventType === "value" ? new ValueEventRegistration(callbackContext) : new ChildEventRegistration(eventType, callbackContext);
  repoAddEventCallbackForQuery(query2._repo, query2, container);
  return function() {
    return repoRemoveEventCallbackForQuery(query2._repo, query2, container);
  };
}
function onValue(query2, callback, cancelCallbackOrListenOptions, options) {
  return addEventListener(query2, "value", callback, cancelCallbackOrListenOptions, options);
}
function onChildAdded(query2, callback, cancelCallbackOrListenOptions, options) {
  return addEventListener(query2, "child_added", callback, cancelCallbackOrListenOptions, options);
}
function onChildChanged(query2, callback, cancelCallbackOrListenOptions, options) {
  return addEventListener(query2, "child_changed", callback, cancelCallbackOrListenOptions, options);
}
function onChildMoved(query2, callback, cancelCallbackOrListenOptions, options) {
  return addEventListener(query2, "child_moved", callback, cancelCallbackOrListenOptions, options);
}
function onChildRemoved(query2, callback, cancelCallbackOrListenOptions, options) {
  return addEventListener(query2, "child_removed", callback, cancelCallbackOrListenOptions, options);
}
function off(query2, eventType, callback) {
  var container = null;
  var expCallback = callback ? new CallbackContext(callback) : null;
  if (eventType === "value") {
    container = new ValueEventRegistration(expCallback);
  } else if (eventType) {
    container = new ChildEventRegistration(eventType, expCallback);
  }
  repoRemoveEventCallbackForQuery(query2._repo, query2, container);
}
var QueryConstraint = (
  /** @class */
  /* @__PURE__ */ function() {
    function QueryConstraint2() {
    }
    return QueryConstraint2;
  }()
);
var QueryEndAtConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryEndAtConstraint2, _super);
    function QueryEndAtConstraint2(_value, _key) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      _this._key = _key;
      return _this;
    }
    QueryEndAtConstraint2.prototype._apply = function(query2) {
      validateFirebaseDataArg("endAt", this._value, query2._path, true);
      var newParams = queryParamsEndAt(query2._queryParams, this._value, this._key);
      validateLimit(newParams);
      validateQueryEndpoints(newParams);
      if (query2._queryParams.hasEnd()) {
        throw new Error("endAt: Starting point was already set (by another call to endAt, endBefore or equalTo).");
      }
      return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
    };
    return QueryEndAtConstraint2;
  }(QueryConstraint)
);
function endAt(value, key) {
  validateKey("endAt", "key", key, true);
  return new QueryEndAtConstraint(value, key);
}
var QueryEndBeforeConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryEndBeforeConstraint2, _super);
    function QueryEndBeforeConstraint2(_value, _key) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      _this._key = _key;
      return _this;
    }
    QueryEndBeforeConstraint2.prototype._apply = function(query2) {
      validateFirebaseDataArg("endBefore", this._value, query2._path, false);
      var newParams = queryParamsEndBefore(query2._queryParams, this._value, this._key);
      validateLimit(newParams);
      validateQueryEndpoints(newParams);
      if (query2._queryParams.hasEnd()) {
        throw new Error("endBefore: Starting point was already set (by another call to endAt, endBefore or equalTo).");
      }
      return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
    };
    return QueryEndBeforeConstraint2;
  }(QueryConstraint)
);
function endBefore(value, key) {
  validateKey("endBefore", "key", key, true);
  return new QueryEndBeforeConstraint(value, key);
}
var QueryStartAtConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryStartAtConstraint2, _super);
    function QueryStartAtConstraint2(_value, _key) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      _this._key = _key;
      return _this;
    }
    QueryStartAtConstraint2.prototype._apply = function(query2) {
      validateFirebaseDataArg("startAt", this._value, query2._path, true);
      var newParams = queryParamsStartAt(query2._queryParams, this._value, this._key);
      validateLimit(newParams);
      validateQueryEndpoints(newParams);
      if (query2._queryParams.hasStart()) {
        throw new Error("startAt: Starting point was already set (by another call to startAt, startBefore or equalTo).");
      }
      return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
    };
    return QueryStartAtConstraint2;
  }(QueryConstraint)
);
function startAt(value, key) {
  if (value === void 0) {
    value = null;
  }
  validateKey("startAt", "key", key, true);
  return new QueryStartAtConstraint(value, key);
}
var QueryStartAfterConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryStartAfterConstraint2, _super);
    function QueryStartAfterConstraint2(_value, _key) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      _this._key = _key;
      return _this;
    }
    QueryStartAfterConstraint2.prototype._apply = function(query2) {
      validateFirebaseDataArg("startAfter", this._value, query2._path, false);
      var newParams = queryParamsStartAfter(query2._queryParams, this._value, this._key);
      validateLimit(newParams);
      validateQueryEndpoints(newParams);
      if (query2._queryParams.hasStart()) {
        throw new Error("startAfter: Starting point was already set (by another call to startAt, startAfter, or equalTo).");
      }
      return new QueryImpl(query2._repo, query2._path, newParams, query2._orderByCalled);
    };
    return QueryStartAfterConstraint2;
  }(QueryConstraint)
);
function startAfter(value, key) {
  validateKey("startAfter", "key", key, true);
  return new QueryStartAfterConstraint(value, key);
}
var QueryLimitToFirstConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryLimitToFirstConstraint2, _super);
    function QueryLimitToFirstConstraint2(_limit) {
      var _this = _super.call(this) || this;
      _this._limit = _limit;
      return _this;
    }
    QueryLimitToFirstConstraint2.prototype._apply = function(query2) {
      if (query2._queryParams.hasLimit()) {
        throw new Error("limitToFirst: Limit was already set (by another call to limitToFirst or limitToLast).");
      }
      return new QueryImpl(query2._repo, query2._path, queryParamsLimitToFirst(query2._queryParams, this._limit), query2._orderByCalled);
    };
    return QueryLimitToFirstConstraint2;
  }(QueryConstraint)
);
function limitToFirst(limit) {
  if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
    throw new Error("limitToFirst: First argument must be a positive integer.");
  }
  return new QueryLimitToFirstConstraint(limit);
}
var QueryLimitToLastConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryLimitToLastConstraint2, _super);
    function QueryLimitToLastConstraint2(_limit) {
      var _this = _super.call(this) || this;
      _this._limit = _limit;
      return _this;
    }
    QueryLimitToLastConstraint2.prototype._apply = function(query2) {
      if (query2._queryParams.hasLimit()) {
        throw new Error("limitToLast: Limit was already set (by another call to limitToFirst or limitToLast).");
      }
      return new QueryImpl(query2._repo, query2._path, queryParamsLimitToLast(query2._queryParams, this._limit), query2._orderByCalled);
    };
    return QueryLimitToLastConstraint2;
  }(QueryConstraint)
);
function limitToLast(limit) {
  if (typeof limit !== "number" || Math.floor(limit) !== limit || limit <= 0) {
    throw new Error("limitToLast: First argument must be a positive integer.");
  }
  return new QueryLimitToLastConstraint(limit);
}
var QueryOrderByChildConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryOrderByChildConstraint2, _super);
    function QueryOrderByChildConstraint2(_path) {
      var _this = _super.call(this) || this;
      _this._path = _path;
      return _this;
    }
    QueryOrderByChildConstraint2.prototype._apply = function(query2) {
      validateNoPreviousOrderByCall(query2, "orderByChild");
      var parsedPath = new Path(this._path);
      if (pathIsEmpty(parsedPath)) {
        throw new Error("orderByChild: cannot pass in empty path. Use orderByValue() instead.");
      }
      var index = new PathIndex(parsedPath);
      var newParams = queryParamsOrderBy(query2._queryParams, index);
      validateQueryEndpoints(newParams);
      return new QueryImpl(
        query2._repo,
        query2._path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    return QueryOrderByChildConstraint2;
  }(QueryConstraint)
);
function orderByChild(path) {
  if (path === "$key") {
    throw new Error('orderByChild: "$key" is invalid.  Use orderByKey() instead.');
  } else if (path === "$priority") {
    throw new Error('orderByChild: "$priority" is invalid.  Use orderByPriority() instead.');
  } else if (path === "$value") {
    throw new Error('orderByChild: "$value" is invalid.  Use orderByValue() instead.');
  }
  validatePathString("orderByChild", "path", path, false);
  return new QueryOrderByChildConstraint(path);
}
var QueryOrderByKeyConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryOrderByKeyConstraint2, _super);
    function QueryOrderByKeyConstraint2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryOrderByKeyConstraint2.prototype._apply = function(query2) {
      validateNoPreviousOrderByCall(query2, "orderByKey");
      var newParams = queryParamsOrderBy(query2._queryParams, KEY_INDEX);
      validateQueryEndpoints(newParams);
      return new QueryImpl(
        query2._repo,
        query2._path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    return QueryOrderByKeyConstraint2;
  }(QueryConstraint)
);
function orderByKey() {
  return new QueryOrderByKeyConstraint();
}
var QueryOrderByPriorityConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryOrderByPriorityConstraint2, _super);
    function QueryOrderByPriorityConstraint2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryOrderByPriorityConstraint2.prototype._apply = function(query2) {
      validateNoPreviousOrderByCall(query2, "orderByPriority");
      var newParams = queryParamsOrderBy(query2._queryParams, PRIORITY_INDEX);
      validateQueryEndpoints(newParams);
      return new QueryImpl(
        query2._repo,
        query2._path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    return QueryOrderByPriorityConstraint2;
  }(QueryConstraint)
);
function orderByPriority() {
  return new QueryOrderByPriorityConstraint();
}
var QueryOrderByValueConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryOrderByValueConstraint2, _super);
    function QueryOrderByValueConstraint2() {
      return _super !== null && _super.apply(this, arguments) || this;
    }
    QueryOrderByValueConstraint2.prototype._apply = function(query2) {
      validateNoPreviousOrderByCall(query2, "orderByValue");
      var newParams = queryParamsOrderBy(query2._queryParams, VALUE_INDEX);
      validateQueryEndpoints(newParams);
      return new QueryImpl(
        query2._repo,
        query2._path,
        newParams,
        /*orderByCalled=*/
        true
      );
    };
    return QueryOrderByValueConstraint2;
  }(QueryConstraint)
);
function orderByValue() {
  return new QueryOrderByValueConstraint();
}
var QueryEqualToValueConstraint = (
  /** @class */
  function(_super) {
    __extends(QueryEqualToValueConstraint2, _super);
    function QueryEqualToValueConstraint2(_value, _key) {
      var _this = _super.call(this) || this;
      _this._value = _value;
      _this._key = _key;
      return _this;
    }
    QueryEqualToValueConstraint2.prototype._apply = function(query2) {
      validateFirebaseDataArg("equalTo", this._value, query2._path, false);
      if (query2._queryParams.hasStart()) {
        throw new Error("equalTo: Starting point was already set (by another call to startAt/startAfter or equalTo).");
      }
      if (query2._queryParams.hasEnd()) {
        throw new Error("equalTo: Ending point was already set (by another call to endAt/endBefore or equalTo).");
      }
      return new QueryEndAtConstraint(this._value, this._key)._apply(new QueryStartAtConstraint(this._value, this._key)._apply(query2));
    };
    return QueryEqualToValueConstraint2;
  }(QueryConstraint)
);
function equalTo(value, key) {
  validateKey("equalTo", "key", key, true);
  return new QueryEqualToValueConstraint(value, key);
}
function query(query2) {
  var e_1, _a7;
  var queryConstraints = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    queryConstraints[_i - 1] = arguments[_i];
  }
  var queryImpl = getModularInstance(query2);
  try {
    for (var queryConstraints_1 = __values(queryConstraints), queryConstraints_1_1 = queryConstraints_1.next(); !queryConstraints_1_1.done; queryConstraints_1_1 = queryConstraints_1.next()) {
      var constraint = queryConstraints_1_1.value;
      queryImpl = constraint._apply(queryImpl);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (queryConstraints_1_1 && !queryConstraints_1_1.done && (_a7 = queryConstraints_1.return)) _a7.call(queryConstraints_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return queryImpl;
}
syncPointSetReferenceConstructor(ReferenceImpl);
syncTreeSetReferenceConstructor(ReferenceImpl);
var FIREBASE_DATABASE_EMULATOR_HOST_VAR = "FIREBASE_DATABASE_EMULATOR_HOST";
var repos = {};
var useRestClient = false;
function repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider) {
  repo.repoInfo_ = new RepoInfo(
    host + ":" + port,
    /* secure= */
    false,
    repo.repoInfo_.namespace,
    repo.repoInfo_.webSocketOnly,
    repo.repoInfo_.nodeAdmin,
    repo.repoInfo_.persistenceKey,
    repo.repoInfo_.includeNamespaceInQueryParams
  );
  if (tokenProvider) {
    repo.authTokenProvider_ = tokenProvider;
  }
}
function repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url, nodeAdmin) {
  var dbUrl = url || app.options.databaseURL;
  if (dbUrl === void 0) {
    if (!app.options.projectId) {
      fatal("Can't determine Firebase Database URL. Be sure to include  a Project ID when calling firebase.initializeApp().");
    }
    log("Using default host for project ", app.options.projectId);
    dbUrl = app.options.projectId + "-default-rtdb.firebaseio.com";
  }
  var parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
  var repoInfo = parsedUrl.repoInfo;
  var isEmulator;
  var dbEmulatorHost = void 0;
  if (typeof process !== "undefined") {
    dbEmulatorHost = process.env[FIREBASE_DATABASE_EMULATOR_HOST_VAR];
  }
  if (dbEmulatorHost) {
    isEmulator = true;
    dbUrl = "http://" + dbEmulatorHost + "?ns=" + repoInfo.namespace;
    parsedUrl = parseRepoInfo(dbUrl, nodeAdmin);
    repoInfo = parsedUrl.repoInfo;
  } else {
    isEmulator = !parsedUrl.repoInfo.secure;
  }
  var authTokenProvider = nodeAdmin && isEmulator ? new EmulatorTokenProvider(EmulatorTokenProvider.OWNER) : new FirebaseAuthTokenProvider(app.name, app.options, authProvider);
  validateUrl("Invalid Firebase Database URL", parsedUrl);
  if (!pathIsEmpty(parsedUrl.path)) {
    fatal("Database URL must point to the root of a Firebase Database (not including a child path).");
  }
  var repo = repoManagerCreateRepo(repoInfo, app, authTokenProvider, new AppCheckTokenProvider(app.name, appCheckProvider));
  return new Database$1(repo, app);
}
function repoManagerDeleteRepo(repo, appName) {
  var appRepos = repos[appName];
  if (!appRepos || appRepos[repo.key] !== repo) {
    fatal("Database " + appName + "(" + repo.repoInfo_ + ") has already been deleted.");
  }
  repoInterrupt(repo);
  delete appRepos[repo.key];
}
function repoManagerCreateRepo(repoInfo, app, authTokenProvider, appCheckProvider) {
  var appRepos = repos[app.name];
  if (!appRepos) {
    appRepos = {};
    repos[app.name] = appRepos;
  }
  var repo = appRepos[repoInfo.toURLString()];
  if (repo) {
    fatal("Database initialized multiple times. Please make sure the format of the database URL matches with each database() call.");
  }
  repo = new Repo(repoInfo, useRestClient, authTokenProvider, appCheckProvider);
  appRepos[repoInfo.toURLString()] = repo;
  return repo;
}
function repoManagerForceRestClient(forceRestClient2) {
  useRestClient = forceRestClient2;
}
var Database$1 = (
  /** @class */
  function() {
    function Database2(_repoInternal, app) {
      this._repoInternal = _repoInternal;
      this.app = app;
      this["type"] = "database";
      this._instanceStarted = false;
    }
    Object.defineProperty(Database2.prototype, "_repo", {
      get: function() {
        if (!this._instanceStarted) {
          repoStart(this._repoInternal, this.app.options.appId, this.app.options["databaseAuthVariableOverride"]);
          this._instanceStarted = true;
        }
        return this._repoInternal;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Database2.prototype, "_root", {
      get: function() {
        if (!this._rootInternal) {
          this._rootInternal = new ReferenceImpl(this._repo, newEmptyPath());
        }
        return this._rootInternal;
      },
      enumerable: false,
      configurable: true
    });
    Database2.prototype._delete = function() {
      if (this._rootInternal !== null) {
        repoManagerDeleteRepo(this._repo, this.app.name);
        this._repoInternal = null;
        this._rootInternal = null;
      }
      return Promise.resolve();
    };
    Database2.prototype._checkNotDeleted = function(apiName) {
      if (this._rootInternal === null) {
        fatal("Cannot call " + apiName + " on a deleted database.");
      }
    };
    return Database2;
  }()
);
function connectDatabaseEmulator(db, host, port, options) {
  if (options === void 0) {
    options = {};
  }
  db = getModularInstance(db);
  db._checkNotDeleted("useEmulator");
  if (db._instanceStarted) {
    fatal("Cannot call useEmulator() after instance has already been initialized.");
  }
  var repo = db._repoInternal;
  var tokenProvider = void 0;
  if (repo.repoInfo_.nodeAdmin) {
    if (options.mockUserToken) {
      fatal('mockUserToken is not supported by the Admin SDK. For client access with mock users, please use the "firebase" package instead of "firebase-admin".');
    }
    tokenProvider = new EmulatorTokenProvider(EmulatorTokenProvider.OWNER);
  } else if (options.mockUserToken) {
    var token = typeof options.mockUserToken === "string" ? options.mockUserToken : createMockUserToken(options.mockUserToken, db.app.options.projectId);
    tokenProvider = new EmulatorTokenProvider(token);
  }
  repoManagerApplyEmulatorSettings(repo, host, port, tokenProvider);
}
function goOffline(db) {
  db = getModularInstance(db);
  db._checkNotDeleted("goOffline");
  repoInterrupt(db._repo);
}
function goOnline(db) {
  db = getModularInstance(db);
  db._checkNotDeleted("goOnline");
  repoResume(db._repo);
}
var SERVER_TIMESTAMP = {
  ".sv": "timestamp"
};
function serverTimestamp() {
  return SERVER_TIMESTAMP;
}
function increment(delta) {
  return {
    ".sv": {
      "increment": delta
    }
  };
}
var TransactionResult$1 = (
  /** @class */
  function() {
    function TransactionResult2(committed, snapshot) {
      this.committed = committed;
      this.snapshot = snapshot;
    }
    TransactionResult2.prototype.toJSON = function() {
      return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult2;
  }()
);
function runTransaction(ref3, transactionUpdate, options) {
  var _a7;
  ref3 = getModularInstance(ref3);
  validateWritablePath("Reference.transaction", ref3._path);
  if (ref3.key === ".length" || ref3.key === ".keys") {
    throw "Reference.transaction failed: " + ref3.key + " is a read-only object.";
  }
  var applyLocally = (_a7 = options === null || options === void 0 ? void 0 : options.applyLocally) !== null && _a7 !== void 0 ? _a7 : true;
  var deferred = new Deferred();
  var promiseComplete = function(error2, committed, node) {
    var dataSnapshot = null;
    if (error2) {
      deferred.reject(error2);
    } else {
      dataSnapshot = new DataSnapshot$1(node, new ReferenceImpl(ref3._repo, ref3._path), PRIORITY_INDEX);
      deferred.resolve(new TransactionResult$1(committed, dataSnapshot));
    }
  };
  var unwatcher = onValue(ref3, function() {
  });
  repoStartTransaction(ref3._repo, ref3._path, transactionUpdate, promiseComplete, unwatcher, applyLocally);
  return deferred.promise;
}
var OnDisconnect = (
  /** @class */
  function() {
    function OnDisconnect2(_delegate) {
      this._delegate = _delegate;
    }
    OnDisconnect2.prototype.cancel = function(onComplete) {
      validateArgCount("OnDisconnect.cancel", 0, 1, arguments.length);
      validateCallback("OnDisconnect.cancel", "onComplete", onComplete, true);
      var result = this._delegate.cancel();
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    OnDisconnect2.prototype.remove = function(onComplete) {
      validateArgCount("OnDisconnect.remove", 0, 1, arguments.length);
      validateCallback("OnDisconnect.remove", "onComplete", onComplete, true);
      var result = this._delegate.remove();
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    OnDisconnect2.prototype.set = function(value, onComplete) {
      validateArgCount("OnDisconnect.set", 1, 2, arguments.length);
      validateCallback("OnDisconnect.set", "onComplete", onComplete, true);
      var result = this._delegate.set(value);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    OnDisconnect2.prototype.setWithPriority = function(value, priority, onComplete) {
      validateArgCount("OnDisconnect.setWithPriority", 2, 3, arguments.length);
      validateCallback("OnDisconnect.setWithPriority", "onComplete", onComplete, true);
      var result = this._delegate.setWithPriority(value, priority);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    OnDisconnect2.prototype.update = function(objectToMerge, onComplete) {
      validateArgCount("OnDisconnect.update", 1, 2, arguments.length);
      if (Array.isArray(objectToMerge)) {
        var newObjectToMerge = {};
        for (var i = 0; i < objectToMerge.length; ++i) {
          newObjectToMerge["" + i] = objectToMerge[i];
        }
        objectToMerge = newObjectToMerge;
        warn("Passing an Array to firebase.database.onDisconnect().update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
      }
      validateCallback("OnDisconnect.update", "onComplete", onComplete, true);
      var result = this._delegate.update(objectToMerge);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    return OnDisconnect2;
  }()
);
var TransactionResult = (
  /** @class */
  function() {
    function TransactionResult2(committed, snapshot) {
      this.committed = committed;
      this.snapshot = snapshot;
    }
    TransactionResult2.prototype.toJSON = function() {
      validateArgCount("TransactionResult.toJSON", 0, 1, arguments.length);
      return { committed: this.committed, snapshot: this.snapshot.toJSON() };
    };
    return TransactionResult2;
  }()
);
var DataSnapshot = (
  /** @class */
  function() {
    function DataSnapshot2(_database, _delegate) {
      this._database = _database;
      this._delegate = _delegate;
    }
    DataSnapshot2.prototype.val = function() {
      validateArgCount("DataSnapshot.val", 0, 0, arguments.length);
      return this._delegate.val();
    };
    DataSnapshot2.prototype.exportVal = function() {
      validateArgCount("DataSnapshot.exportVal", 0, 0, arguments.length);
      return this._delegate.exportVal();
    };
    DataSnapshot2.prototype.toJSON = function() {
      validateArgCount("DataSnapshot.toJSON", 0, 1, arguments.length);
      return this._delegate.toJSON();
    };
    DataSnapshot2.prototype.exists = function() {
      validateArgCount("DataSnapshot.exists", 0, 0, arguments.length);
      return this._delegate.exists();
    };
    DataSnapshot2.prototype.child = function(path) {
      validateArgCount("DataSnapshot.child", 0, 1, arguments.length);
      path = String(path);
      validatePathString("DataSnapshot.child", "path", path, false);
      return new DataSnapshot2(this._database, this._delegate.child(path));
    };
    DataSnapshot2.prototype.hasChild = function(path) {
      validateArgCount("DataSnapshot.hasChild", 1, 1, arguments.length);
      validatePathString("DataSnapshot.hasChild", "path", path, false);
      return this._delegate.hasChild(path);
    };
    DataSnapshot2.prototype.getPriority = function() {
      validateArgCount("DataSnapshot.getPriority", 0, 0, arguments.length);
      return this._delegate.priority;
    };
    DataSnapshot2.prototype.forEach = function(action) {
      var _this = this;
      validateArgCount("DataSnapshot.forEach", 1, 1, arguments.length);
      validateCallback("DataSnapshot.forEach", "action", action, false);
      return this._delegate.forEach(function(expDataSnapshot) {
        return action(new DataSnapshot2(_this._database, expDataSnapshot));
      });
    };
    DataSnapshot2.prototype.hasChildren = function() {
      validateArgCount("DataSnapshot.hasChildren", 0, 0, arguments.length);
      return this._delegate.hasChildren();
    };
    Object.defineProperty(DataSnapshot2.prototype, "key", {
      get: function() {
        return this._delegate.key;
      },
      enumerable: false,
      configurable: true
    });
    DataSnapshot2.prototype.numChildren = function() {
      validateArgCount("DataSnapshot.numChildren", 0, 0, arguments.length);
      return this._delegate.size;
    };
    DataSnapshot2.prototype.getRef = function() {
      validateArgCount("DataSnapshot.ref", 0, 0, arguments.length);
      return new Reference(this._database, this._delegate.ref);
    };
    Object.defineProperty(DataSnapshot2.prototype, "ref", {
      get: function() {
        return this.getRef();
      },
      enumerable: false,
      configurable: true
    });
    return DataSnapshot2;
  }()
);
var Query = (
  /** @class */
  function() {
    function Query2(database, _delegate) {
      this.database = database;
      this._delegate = _delegate;
    }
    Query2.prototype.on = function(eventType, callback, cancelCallbackOrContext, context) {
      var _this = this;
      var _a7;
      validateArgCount("Query.on", 2, 4, arguments.length);
      validateCallback("Query.on", "callback", callback, false);
      var ret = Query2.getCancelAndContextArgs_("Query.on", cancelCallbackOrContext, context);
      var valueCallback = function(expSnapshot, previousChildName) {
        callback.call(ret.context, new DataSnapshot(_this.database, expSnapshot), previousChildName);
      };
      valueCallback.userCallback = callback;
      valueCallback.context = ret.context;
      var cancelCallback = (_a7 = ret.cancel) === null || _a7 === void 0 ? void 0 : _a7.bind(ret.context);
      switch (eventType) {
        case "value":
          onValue(this._delegate, valueCallback, cancelCallback);
          return callback;
        case "child_added":
          onChildAdded(this._delegate, valueCallback, cancelCallback);
          return callback;
        case "child_removed":
          onChildRemoved(this._delegate, valueCallback, cancelCallback);
          return callback;
        case "child_changed":
          onChildChanged(this._delegate, valueCallback, cancelCallback);
          return callback;
        case "child_moved":
          onChildMoved(this._delegate, valueCallback, cancelCallback);
          return callback;
        default:
          throw new Error(errorPrefix("Query.on", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
      }
    };
    Query2.prototype.off = function(eventType, callback, context) {
      validateArgCount("Query.off", 0, 3, arguments.length);
      validateEventType("Query.off", eventType, true);
      validateCallback("Query.off", "callback", callback, true);
      validateContextObject("Query.off", "context", context, true);
      if (callback) {
        var valueCallback = function() {
        };
        valueCallback.userCallback = callback;
        valueCallback.context = context;
        off(this._delegate, eventType, valueCallback);
      } else {
        off(this._delegate, eventType);
      }
    };
    Query2.prototype.get = function() {
      var _this = this;
      return get(this._delegate).then(function(expSnapshot) {
        return new DataSnapshot(_this.database, expSnapshot);
      });
    };
    Query2.prototype.once = function(eventType, callback, failureCallbackOrContext, context) {
      var _this = this;
      validateArgCount("Query.once", 1, 4, arguments.length);
      validateCallback("Query.once", "callback", callback, true);
      var ret = Query2.getCancelAndContextArgs_("Query.once", failureCallbackOrContext, context);
      var deferred = new Deferred();
      var valueCallback = function(expSnapshot, previousChildName) {
        var result = new DataSnapshot(_this.database, expSnapshot);
        if (callback) {
          callback.call(ret.context, result, previousChildName);
        }
        deferred.resolve(result);
      };
      valueCallback.userCallback = callback;
      valueCallback.context = ret.context;
      var cancelCallback = function(error2) {
        if (ret.cancel) {
          ret.cancel.call(ret.context, error2);
        }
        deferred.reject(error2);
      };
      switch (eventType) {
        case "value":
          onValue(this._delegate, valueCallback, cancelCallback, {
            onlyOnce: true
          });
          break;
        case "child_added":
          onChildAdded(this._delegate, valueCallback, cancelCallback, {
            onlyOnce: true
          });
          break;
        case "child_removed":
          onChildRemoved(this._delegate, valueCallback, cancelCallback, {
            onlyOnce: true
          });
          break;
        case "child_changed":
          onChildChanged(this._delegate, valueCallback, cancelCallback, {
            onlyOnce: true
          });
          break;
        case "child_moved":
          onChildMoved(this._delegate, valueCallback, cancelCallback, {
            onlyOnce: true
          });
          break;
        default:
          throw new Error(errorPrefix("Query.once", "eventType") + 'must be a valid event type = "value", "child_added", "child_removed", "child_changed", or "child_moved".');
      }
      return deferred.promise;
    };
    Query2.prototype.limitToFirst = function(limit) {
      validateArgCount("Query.limitToFirst", 1, 1, arguments.length);
      return new Query2(this.database, query(this._delegate, limitToFirst(limit)));
    };
    Query2.prototype.limitToLast = function(limit) {
      validateArgCount("Query.limitToLast", 1, 1, arguments.length);
      return new Query2(this.database, query(this._delegate, limitToLast(limit)));
    };
    Query2.prototype.orderByChild = function(path) {
      validateArgCount("Query.orderByChild", 1, 1, arguments.length);
      return new Query2(this.database, query(this._delegate, orderByChild(path)));
    };
    Query2.prototype.orderByKey = function() {
      validateArgCount("Query.orderByKey", 0, 0, arguments.length);
      return new Query2(this.database, query(this._delegate, orderByKey()));
    };
    Query2.prototype.orderByPriority = function() {
      validateArgCount("Query.orderByPriority", 0, 0, arguments.length);
      return new Query2(this.database, query(this._delegate, orderByPriority()));
    };
    Query2.prototype.orderByValue = function() {
      validateArgCount("Query.orderByValue", 0, 0, arguments.length);
      return new Query2(this.database, query(this._delegate, orderByValue()));
    };
    Query2.prototype.startAt = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.startAt", 0, 2, arguments.length);
      return new Query2(this.database, query(this._delegate, startAt(value, name10)));
    };
    Query2.prototype.startAfter = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.startAfter", 0, 2, arguments.length);
      return new Query2(this.database, query(this._delegate, startAfter(value, name10)));
    };
    Query2.prototype.endAt = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.endAt", 0, 2, arguments.length);
      return new Query2(this.database, query(this._delegate, endAt(value, name10)));
    };
    Query2.prototype.endBefore = function(value, name10) {
      if (value === void 0) {
        value = null;
      }
      validateArgCount("Query.endBefore", 0, 2, arguments.length);
      return new Query2(this.database, query(this._delegate, endBefore(value, name10)));
    };
    Query2.prototype.equalTo = function(value, name10) {
      validateArgCount("Query.equalTo", 1, 2, arguments.length);
      return new Query2(this.database, query(this._delegate, equalTo(value, name10)));
    };
    Query2.prototype.toString = function() {
      validateArgCount("Query.toString", 0, 0, arguments.length);
      return this._delegate.toString();
    };
    Query2.prototype.toJSON = function() {
      validateArgCount("Query.toJSON", 0, 1, arguments.length);
      return this._delegate.toJSON();
    };
    Query2.prototype.isEqual = function(other) {
      validateArgCount("Query.isEqual", 1, 1, arguments.length);
      if (!(other instanceof Query2)) {
        var error2 = "Query.isEqual failed: First argument must be an instance of firebase.database.Query.";
        throw new Error(error2);
      }
      return this._delegate.isEqual(other._delegate);
    };
    Query2.getCancelAndContextArgs_ = function(fnName, cancelOrContext, context) {
      var ret = { cancel: void 0, context: void 0 };
      if (cancelOrContext && context) {
        ret.cancel = cancelOrContext;
        validateCallback(fnName, "cancel", ret.cancel, true);
        ret.context = context;
        validateContextObject(fnName, "context", ret.context, true);
      } else if (cancelOrContext) {
        if (typeof cancelOrContext === "object" && cancelOrContext !== null) {
          ret.context = cancelOrContext;
        } else if (typeof cancelOrContext === "function") {
          ret.cancel = cancelOrContext;
        } else {
          throw new Error(errorPrefix(fnName, "cancelOrContext") + " must either be a cancel callback or a context object.");
        }
      }
      return ret;
    };
    Object.defineProperty(Query2.prototype, "ref", {
      get: function() {
        return new Reference(this.database, new ReferenceImpl(this._delegate._repo, this._delegate._path));
      },
      enumerable: false,
      configurable: true
    });
    return Query2;
  }()
);
var Reference = (
  /** @class */
  function(_super) {
    __extends(Reference3, _super);
    function Reference3(database, _delegate) {
      var _this = _super.call(this, database, new QueryImpl(_delegate._repo, _delegate._path, new QueryParams(), false)) || this;
      _this.database = database;
      _this._delegate = _delegate;
      return _this;
    }
    Reference3.prototype.getKey = function() {
      validateArgCount("Reference.key", 0, 0, arguments.length);
      return this._delegate.key;
    };
    Reference3.prototype.child = function(pathString) {
      validateArgCount("Reference.child", 1, 1, arguments.length);
      if (typeof pathString === "number") {
        pathString = String(pathString);
      }
      return new Reference3(this.database, child(this._delegate, pathString));
    };
    Reference3.prototype.getParent = function() {
      validateArgCount("Reference.parent", 0, 0, arguments.length);
      var parent2 = this._delegate.parent;
      return parent2 ? new Reference3(this.database, parent2) : null;
    };
    Reference3.prototype.getRoot = function() {
      validateArgCount("Reference.root", 0, 0, arguments.length);
      return new Reference3(this.database, this._delegate.root);
    };
    Reference3.prototype.set = function(newVal, onComplete) {
      validateArgCount("Reference.set", 1, 2, arguments.length);
      validateCallback("Reference.set", "onComplete", onComplete, true);
      var result = set(this._delegate, newVal);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    Reference3.prototype.update = function(values, onComplete) {
      validateArgCount("Reference.update", 1, 2, arguments.length);
      if (Array.isArray(values)) {
        var newObjectToMerge = {};
        for (var i = 0; i < values.length; ++i) {
          newObjectToMerge["" + i] = values[i];
        }
        values = newObjectToMerge;
        warn("Passing an Array to Firebase.update() is deprecated. Use set() if you want to overwrite the existing data, or an Object with integer keys if you really do want to only update some of the children.");
      }
      validateWritablePath("Reference.update", this._delegate._path);
      validateCallback("Reference.update", "onComplete", onComplete, true);
      var result = update(this._delegate, values);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    Reference3.prototype.setWithPriority = function(newVal, newPriority, onComplete) {
      validateArgCount("Reference.setWithPriority", 2, 3, arguments.length);
      validateCallback("Reference.setWithPriority", "onComplete", onComplete, true);
      var result = setWithPriority(this._delegate, newVal, newPriority);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    Reference3.prototype.remove = function(onComplete) {
      validateArgCount("Reference.remove", 0, 1, arguments.length);
      validateCallback("Reference.remove", "onComplete", onComplete, true);
      var result = remove(this._delegate);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    Reference3.prototype.transaction = function(transactionUpdate, onComplete, applyLocally) {
      var _this = this;
      validateArgCount("Reference.transaction", 1, 3, arguments.length);
      validateCallback("Reference.transaction", "transactionUpdate", transactionUpdate, false);
      validateCallback("Reference.transaction", "onComplete", onComplete, true);
      validateBoolean("Reference.transaction", "applyLocally", applyLocally, true);
      var result = runTransaction(this._delegate, transactionUpdate, {
        applyLocally
      }).then(function(transactionResult) {
        return new TransactionResult(transactionResult.committed, new DataSnapshot(_this.database, transactionResult.snapshot));
      });
      if (onComplete) {
        result.then(function(transactionResult) {
          return onComplete(null, transactionResult.committed, transactionResult.snapshot);
        }, function(error2) {
          return onComplete(error2, false, null);
        });
      }
      return result;
    };
    Reference3.prototype.setPriority = function(priority, onComplete) {
      validateArgCount("Reference.setPriority", 1, 2, arguments.length);
      validateCallback("Reference.setPriority", "onComplete", onComplete, true);
      var result = setPriority(this._delegate, priority);
      if (onComplete) {
        result.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      return result;
    };
    Reference3.prototype.push = function(value, onComplete) {
      var _this = this;
      validateArgCount("Reference.push", 0, 2, arguments.length);
      validateCallback("Reference.push", "onComplete", onComplete, true);
      var expPromise = push(this._delegate, value);
      var promise = expPromise.then(function(expRef) {
        return new Reference3(_this.database, expRef);
      });
      if (onComplete) {
        promise.then(function() {
          return onComplete(null);
        }, function(error2) {
          return onComplete(error2);
        });
      }
      var result = new Reference3(this.database, expPromise);
      result.then = promise.then.bind(promise);
      result.catch = promise.catch.bind(promise, void 0);
      return result;
    };
    Reference3.prototype.onDisconnect = function() {
      validateWritablePath("Reference.onDisconnect", this._delegate._path);
      return new OnDisconnect(new OnDisconnect$1(this._delegate._repo, this._delegate._path));
    };
    Object.defineProperty(Reference3.prototype, "key", {
      get: function() {
        return this.getKey();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "parent", {
      get: function() {
        return this.getParent();
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "root", {
      get: function() {
        return this.getRoot();
      },
      enumerable: false,
      configurable: true
    });
    return Reference3;
  }(Query)
);
var Database = (
  /** @class */
  function() {
    function Database2(_delegate, app) {
      var _this = this;
      this._delegate = _delegate;
      this.app = app;
      this.INTERNAL = {
        delete: function() {
          return _this._delegate._delete();
        }
      };
    }
    Database2.prototype.useEmulator = function(host, port, options) {
      if (options === void 0) {
        options = {};
      }
      connectDatabaseEmulator(this._delegate, host, port, options);
    };
    Database2.prototype.ref = function(path) {
      validateArgCount("database.ref", 0, 1, arguments.length);
      if (path instanceof Reference) {
        var childRef = refFromURL(this._delegate, path.toString());
        return new Reference(this, childRef);
      } else {
        var childRef = ref(this._delegate, path);
        return new Reference(this, childRef);
      }
    };
    Database2.prototype.refFromURL = function(url) {
      var apiName = "database.refFromURL";
      validateArgCount(apiName, 1, 1, arguments.length);
      var childRef = refFromURL(this._delegate, url);
      return new Reference(this, childRef);
    };
    Database2.prototype.goOffline = function() {
      validateArgCount("database.goOffline", 0, 0, arguments.length);
      return goOffline(this._delegate);
    };
    Database2.prototype.goOnline = function() {
      validateArgCount("database.goOnline", 0, 0, arguments.length);
      return goOnline(this._delegate);
    };
    Database2.ServerValue = {
      TIMESTAMP: serverTimestamp(),
      increment: function(delta) {
        return increment(delta);
      }
    };
    return Database2;
  }()
);
var forceLongPolling = function() {
  WebSocketConnection.forceDisallow();
  BrowserPollConnection.forceAllow();
};
var forceWebSockets = function() {
  BrowserPollConnection.forceDisallow();
};
var isWebSocketsAvailable = function() {
  return WebSocketConnection["isAvailable"]();
};
var setSecurityDebugCallback = function(ref3, callback) {
  var connection = ref3._delegate._repo.persistentConnection_;
  connection.securityDebugCallback_ = callback;
};
var stats = function(ref3, showDelta) {
  repoStats(ref3._delegate._repo, showDelta);
};
var statsIncrementCounter = function(ref3, metric) {
  repoStatsIncrementCounter(ref3._delegate._repo, metric);
};
var dataUpdateCount = function(ref3) {
  return ref3._delegate._repo.dataUpdateCount;
};
var interceptServerData = function(ref3, callback) {
  return repoInterceptServerData(ref3._delegate._repo, callback);
};
function initStandalone(_a7) {
  var app = _a7.app, url = _a7.url, version10 = _a7.version, customAuthImpl = _a7.customAuthImpl, namespace = _a7.namespace, _b = _a7.nodeAdmin, nodeAdmin = _b === void 0 ? false : _b;
  setSDKVersion(version10);
  var authProvider = new Provider("auth-internal", new ComponentContainer("database-standalone"));
  authProvider.setComponent(new Component(
    "auth-internal",
    function() {
      return customAuthImpl;
    },
    "PRIVATE"
    /* PRIVATE */
  ));
  return {
    instance: new Database(repoManagerDatabaseFromApp(
      app,
      authProvider,
      /* appCheckProvider= */
      void 0,
      url,
      nodeAdmin
    ), app),
    namespace
  };
}
var INTERNAL = Object.freeze({
  __proto__: null,
  forceLongPolling,
  forceWebSockets,
  isWebSocketsAvailable,
  setSecurityDebugCallback,
  stats,
  statsIncrementCounter,
  dataUpdateCount,
  interceptServerData,
  initStandalone
});
var DataConnection = PersistentConnection;
PersistentConnection.prototype.simpleListen = function(pathString, onComplete) {
  this.sendRequest("q", { p: pathString }, onComplete);
};
PersistentConnection.prototype.echo = function(data, onEcho) {
  this.sendRequest("echo", { d: data }, onEcho);
};
var RealTimeConnection = Connection;
var hijackHash = function(newHash) {
  var oldPut = PersistentConnection.prototype.put;
  PersistentConnection.prototype.put = function(pathString, data, onComplete, hash) {
    if (hash !== void 0) {
      hash = newHash();
    }
    oldPut.call(this, pathString, data, onComplete, hash);
  };
  return function() {
    PersistentConnection.prototype.put = oldPut;
  };
};
var ConnectionTarget = RepoInfo;
var queryIdentifier = function(query2) {
  return query2._delegate._queryIdentifier;
};
var forceRestClient = function(forceRestClient2) {
  repoManagerForceRestClient(forceRestClient2);
};
var TEST_ACCESS = Object.freeze({
  __proto__: null,
  DataConnection,
  RealTimeConnection,
  hijackHash,
  ConnectionTarget,
  queryIdentifier,
  forceRestClient
});
var ServerValue = Database.ServerValue;
function registerDatabase(instance) {
  setSDKVersion(instance.SDK_VERSION);
  var namespace = instance.INTERNAL.registerComponent(new Component(
    "database",
    function(container, _a7) {
      var url = _a7.instanceIdentifier;
      var app = container.getProvider("app").getImmediate();
      var authProvider = container.getProvider("auth-internal");
      var appCheckProvider = container.getProvider("app-check-internal");
      return new Database(repoManagerDatabaseFromApp(app, authProvider, appCheckProvider, url), app);
    },
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(
    // firebase.database namespace properties
    {
      Reference,
      Query,
      Database,
      DataSnapshot,
      enableLogging,
      INTERNAL,
      ServerValue,
      TEST_ACCESS
    }
  ).setMultipleInstances(true));
  instance.registerVersion(name, version);
  if (isNodeSdk()) {
    module.exports = namespace;
  }
}
registerDatabase(index_esm_default);

// node_modules/@firebase/firestore/dist/esm5/bundle.js
function t(o) {
  o.prototype.loadBundle = Gc, o.prototype.namedQuery = Qc;
}
t(Sc);

// node_modules/@firebase/functions/dist/index.esm.js
var errorCodeMap = {
  OK: "ok",
  CANCELLED: "cancelled",
  UNKNOWN: "unknown",
  INVALID_ARGUMENT: "invalid-argument",
  DEADLINE_EXCEEDED: "deadline-exceeded",
  NOT_FOUND: "not-found",
  ALREADY_EXISTS: "already-exists",
  PERMISSION_DENIED: "permission-denied",
  UNAUTHENTICATED: "unauthenticated",
  RESOURCE_EXHAUSTED: "resource-exhausted",
  FAILED_PRECONDITION: "failed-precondition",
  ABORTED: "aborted",
  OUT_OF_RANGE: "out-of-range",
  UNIMPLEMENTED: "unimplemented",
  INTERNAL: "internal",
  UNAVAILABLE: "unavailable",
  DATA_LOSS: "data-loss"
};
var HttpsErrorImpl = (
  /** @class */
  function(_super) {
    __extends(HttpsErrorImpl2, _super);
    function HttpsErrorImpl2(code, message, details) {
      var _this = _super.call(this, message) || this;
      Object.setPrototypeOf(_this, HttpsErrorImpl2.prototype);
      _this.code = code;
      _this.details = details;
      return _this;
    }
    return HttpsErrorImpl2;
  }(Error)
);
function codeForHTTPStatus(status) {
  if (status >= 200 && status < 300) {
    return "ok";
  }
  switch (status) {
    case 0:
      return "internal";
    case 400:
      return "invalid-argument";
    case 401:
      return "unauthenticated";
    case 403:
      return "permission-denied";
    case 404:
      return "not-found";
    case 409:
      return "aborted";
    case 429:
      return "resource-exhausted";
    case 499:
      return "cancelled";
    case 500:
      return "internal";
    case 501:
      return "unimplemented";
    case 503:
      return "unavailable";
    case 504:
      return "deadline-exceeded";
  }
  return "unknown";
}
function _errorForResponse(status, bodyJSON, serializer2) {
  var code = codeForHTTPStatus(status);
  var description = code;
  var details = void 0;
  try {
    var errorJSON = bodyJSON && bodyJSON.error;
    if (errorJSON) {
      var status_1 = errorJSON.status;
      if (typeof status_1 === "string") {
        if (!errorCodeMap[status_1]) {
          return new HttpsErrorImpl("internal", "internal");
        }
        code = errorCodeMap[status_1];
        description = status_1;
      }
      var message = errorJSON.message;
      if (typeof message === "string") {
        description = message;
      }
      details = errorJSON.details;
      if (details !== void 0) {
        details = serializer2.decode(details);
      }
    }
  } catch (e) {
  }
  if (code === "ok") {
    return null;
  }
  return new HttpsErrorImpl(code, description, details);
}
var ContextProvider = (
  /** @class */
  function() {
    function ContextProvider2(authProvider, messagingProvider) {
      var _this = this;
      this.auth = null;
      this.messaging = null;
      this.auth = authProvider.getImmediate({ optional: true });
      this.messaging = messagingProvider.getImmediate({
        optional: true
      });
      if (!this.auth) {
        authProvider.get().then(function(auth) {
          return _this.auth = auth;
        }, function() {
        });
      }
      if (!this.messaging) {
        messagingProvider.get().then(function(messaging) {
          return _this.messaging = messaging;
        }, function() {
        });
      }
    }
    ContextProvider2.prototype.getAuthToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var token;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!this.auth) {
                return [2, void 0];
              }
              _a7.label = 1;
            case 1:
              _a7.trys.push([1, 3, , 4]);
              return [4, this.auth.getToken()];
            case 2:
              token = _a7.sent();
              if (!token) {
                return [2, void 0];
              }
              return [2, token.accessToken];
            case 3:
              _a7.sent();
              return [2, void 0];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    ContextProvider2.prototype.getInstanceIdToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!this.messaging || !("Notification" in self) || Notification.permission !== "granted") {
                return [2, void 0];
              }
              _a7.label = 1;
            case 1:
              _a7.trys.push([1, 3, , 4]);
              return [4, this.messaging.getToken()];
            case 2:
              return [2, _a7.sent()];
            case 3:
              _a7.sent();
              return [2, void 0];
            case 4:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    ContextProvider2.prototype.getContext = function() {
      return __awaiter(this, void 0, void 0, function() {
        var authToken, instanceIdToken;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              return [4, this.getAuthToken()];
            case 1:
              authToken = _a7.sent();
              return [4, this.getInstanceIdToken()];
            case 2:
              instanceIdToken = _a7.sent();
              return [2, { authToken, instanceIdToken }];
          }
        });
      });
    };
    return ContextProvider2;
  }()
);
var LONG_TYPE = "type.googleapis.com/google.protobuf.Int64Value";
var UNSIGNED_LONG_TYPE = "type.googleapis.com/google.protobuf.UInt64Value";
function mapValues(o, f) {
  var result = {};
  for (var key in o) {
    if (o.hasOwnProperty(key)) {
      result[key] = f(o[key]);
    }
  }
  return result;
}
var Serializer = (
  /** @class */
  function() {
    function Serializer2() {
    }
    Serializer2.prototype.encode = function(data) {
      var _this = this;
      if (data == null) {
        return null;
      }
      if (data instanceof Number) {
        data = data.valueOf();
      }
      if (typeof data === "number" && isFinite(data)) {
        return data;
      }
      if (data === true || data === false) {
        return data;
      }
      if (Object.prototype.toString.call(data) === "[object String]") {
        return data;
      }
      if (data instanceof Date) {
        return data.toISOString();
      }
      if (Array.isArray(data)) {
        return data.map(function(x) {
          return _this.encode(x);
        });
      }
      if (typeof data === "function" || typeof data === "object") {
        return mapValues(data, function(x) {
          return _this.encode(x);
        });
      }
      throw new Error("Data cannot be encoded in JSON: " + data);
    };
    Serializer2.prototype.decode = function(json) {
      var _this = this;
      if (json == null) {
        return json;
      }
      if (json["@type"]) {
        switch (json["@type"]) {
          case LONG_TYPE:
          // Fall through and handle this the same as unsigned.
          case UNSIGNED_LONG_TYPE: {
            var value = Number(json["value"]);
            if (isNaN(value)) {
              throw new Error("Data cannot be decoded from JSON: " + json);
            }
            return value;
          }
          default: {
            throw new Error("Data cannot be decoded from JSON: " + json);
          }
        }
      }
      if (Array.isArray(json)) {
        return json.map(function(x) {
          return _this.decode(x);
        });
      }
      if (typeof json === "function" || typeof json === "object") {
        return mapValues(json, function(x) {
          return _this.decode(x);
        });
      }
      return json;
    };
    return Serializer2;
  }()
);
function failAfter(millis) {
  var timer;
  var promise = new Promise(function(_, reject) {
    timer = setTimeout(function() {
      reject(new HttpsErrorImpl("deadline-exceeded", "deadline-exceeded"));
    }, millis);
  });
  return {
    timer,
    promise
  };
}
var Service = (
  /** @class */
  function() {
    function Service2(app_, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain_, fetchImpl) {
      var _this = this;
      if (regionOrCustomDomain_ === void 0) {
        regionOrCustomDomain_ = "us-central1";
      }
      this.app_ = app_;
      this.appCheckProvider = appCheckProvider;
      this.fetchImpl = fetchImpl;
      this.serializer = new Serializer();
      this.emulatorOrigin = null;
      this.INTERNAL = {
        delete: function() {
          return Promise.resolve(_this.deleteService());
        }
      };
      this.contextProvider = new ContextProvider(authProvider, messagingProvider);
      this.cancelAllRequests = new Promise(function(resolve) {
        _this.deleteService = function() {
          return resolve();
        };
      });
      try {
        var url = new URL(regionOrCustomDomain_);
        this.customDomain = url.origin;
        this.region = "us-central1";
      } catch (e) {
        this.customDomain = null;
        this.region = regionOrCustomDomain_;
      }
    }
    Object.defineProperty(Service2.prototype, "app", {
      get: function() {
        return this.app_;
      },
      enumerable: false,
      configurable: true
    });
    Service2.prototype._url = function(name10) {
      var projectId = this.app_.options.projectId;
      if (this.emulatorOrigin !== null) {
        var origin_1 = this.emulatorOrigin;
        return origin_1 + "/" + projectId + "/" + this.region + "/" + name10;
      }
      if (this.customDomain !== null) {
        return this.customDomain + "/" + name10;
      }
      return "https://" + this.region + "-" + projectId + ".cloudfunctions.net/" + name10;
    };
    Service2.prototype.useEmulator = function(host, port) {
      this.emulatorOrigin = "http://" + host + ":" + port;
    };
    Service2.prototype.useFunctionsEmulator = function(origin) {
      this.emulatorOrigin = origin;
    };
    Service2.prototype.httpsCallable = function(name10, options) {
      var _this = this;
      return function(data) {
        return _this.call(name10, data, options || {});
      };
    };
    Service2.prototype.postJSON = function(url, body, headers) {
      return __awaiter(this, void 0, void 0, function() {
        var appCheckToken, response, json;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              headers["Content-Type"] = "application/json";
              return [4, this.getAppCheckToken()];
            case 1:
              appCheckToken = _a7.sent();
              if (appCheckToken !== null) {
                headers["X-Firebase-AppCheck"] = appCheckToken;
              }
              _a7.label = 2;
            case 2:
              _a7.trys.push([2, 4, , 5]);
              return [4, this.fetchImpl(url, {
                method: "POST",
                body: JSON.stringify(body),
                headers
              })];
            case 3:
              response = _a7.sent();
              return [3, 5];
            case 4:
              _a7.sent();
              return [2, {
                status: 0,
                json: null
              }];
            case 5:
              json = null;
              _a7.label = 6;
            case 6:
              _a7.trys.push([6, 8, , 9]);
              return [4, response.json()];
            case 7:
              json = _a7.sent();
              return [3, 9];
            case 8:
              _a7.sent();
              return [3, 9];
            case 9:
              return [2, {
                status: response.status,
                json
              }];
          }
        });
      });
    };
    Service2.prototype.getAppCheckToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var appCheck, result;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              appCheck = this.appCheckProvider.getImmediate({ optional: true });
              if (!appCheck) return [3, 2];
              return [4, appCheck.getToken()];
            case 1:
              result = _a7.sent();
              return [2, result.token];
            case 2:
              return [2, null];
          }
        });
      });
    };
    Service2.prototype.call = function(name10, data, options) {
      return __awaiter(this, void 0, void 0, function() {
        var url, body, headers, context, timeout, _a7, timer, failAfterPromise, response, error2, responseData, decodedData;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              url = this._url(name10);
              data = this.serializer.encode(data);
              body = { data };
              headers = {};
              return [4, this.contextProvider.getContext()];
            case 1:
              context = _b.sent();
              if (context.authToken) {
                headers["Authorization"] = "Bearer " + context.authToken;
              }
              if (context.instanceIdToken) {
                headers["Firebase-Instance-ID-Token"] = context.instanceIdToken;
              }
              timeout = options.timeout || 7e4;
              _a7 = failAfter(timeout), timer = _a7.timer, failAfterPromise = _a7.promise;
              return [4, Promise.race([
                clearTimeoutWrapper(timer, this.postJSON(url, body, headers)),
                failAfterPromise,
                clearTimeoutWrapper(timer, this.cancelAllRequests)
              ])];
            case 2:
              response = _b.sent();
              if (!response) {
                throw new HttpsErrorImpl("cancelled", "Firebase Functions instance was deleted.");
              }
              error2 = _errorForResponse(response.status, response.json, this.serializer);
              if (error2) {
                throw error2;
              }
              if (!response.json) {
                throw new HttpsErrorImpl("internal", "Response is not valid JSON object.");
              }
              responseData = response.json.data;
              if (typeof responseData === "undefined") {
                responseData = response.json.result;
              }
              if (typeof responseData === "undefined") {
                throw new HttpsErrorImpl("internal", "Response is missing data field.");
              }
              decodedData = this.serializer.decode(responseData);
              return [2, { data: decodedData }];
          }
        });
      });
    };
    return Service2;
  }()
);
function clearTimeoutWrapper(timer, promise) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, promise];
        case 1:
          result = _a7.sent();
          clearTimeout(timer);
          return [2, result];
      }
    });
  });
}
var FUNCTIONS_TYPE = "functions";
function registerFunctions(instance, fetchImpl) {
  var namespaceExports = {
    // no-inline
    Functions: Service
  };
  function factory4(container, _a7) {
    var regionOrCustomDomain = _a7.instanceIdentifier;
    var app = container.getProvider("app").getImmediate();
    var authProvider = container.getProvider("auth-internal");
    var appCheckProvider = container.getProvider("app-check-internal");
    var messagingProvider = container.getProvider("messaging");
    return new Service(app, authProvider, messagingProvider, appCheckProvider, regionOrCustomDomain, fetchImpl);
  }
  instance.INTERNAL.registerComponent(new Component(
    FUNCTIONS_TYPE,
    factory4,
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(namespaceExports).setMultipleInstances(true));
}
var name2 = "@firebase/functions";
var version2 = "0.6.16";
registerFunctions(index_esm_default, fetch.bind(self));
index_esm_default.registerVersion(name2, version2);

// node_modules/idb/lib/idb.mjs
function toArray(arr) {
  return Array.prototype.slice.call(arr);
}
function promisifyRequest(request) {
  return new Promise(function(resolve, reject) {
    request.onsuccess = function() {
      resolve(request.result);
    };
    request.onerror = function() {
      reject(request.error);
    };
  });
}
function promisifyRequestCall(obj, method, args) {
  var request;
  var p = new Promise(function(resolve, reject) {
    request = obj[method].apply(obj, args);
    promisifyRequest(request).then(resolve, reject);
  });
  p.request = request;
  return p;
}
function promisifyCursorRequestCall(obj, method, args) {
  var p = promisifyRequestCall(obj, method, args);
  return p.then(function(value) {
    if (!value) return;
    return new Cursor(value, p.request);
  });
}
function proxyProperties(ProxyClass, targetProp, properties) {
  properties.forEach(function(prop) {
    Object.defineProperty(ProxyClass.prototype, prop, {
      get: function() {
        return this[targetProp][prop];
      },
      set: function(val) {
        this[targetProp][prop] = val;
      }
    });
  });
}
function proxyRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype)) return;
    ProxyClass.prototype[prop] = function() {
      return promisifyRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function proxyMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype)) return;
    ProxyClass.prototype[prop] = function() {
      return this[targetProp][prop].apply(this[targetProp], arguments);
    };
  });
}
function proxyCursorRequestMethods(ProxyClass, targetProp, Constructor, properties) {
  properties.forEach(function(prop) {
    if (!(prop in Constructor.prototype)) return;
    ProxyClass.prototype[prop] = function() {
      return promisifyCursorRequestCall(this[targetProp], prop, arguments);
    };
  });
}
function Index2(index) {
  this._index = index;
}
proxyProperties(Index2, "_index", [
  "name",
  "keyPath",
  "multiEntry",
  "unique"
]);
proxyRequestMethods(Index2, "_index", IDBIndex, [
  "get",
  "getKey",
  "getAll",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(Index2, "_index", IDBIndex, [
  "openCursor",
  "openKeyCursor"
]);
function Cursor(cursor, request) {
  this._cursor = cursor;
  this._request = request;
}
proxyProperties(Cursor, "_cursor", [
  "direction",
  "key",
  "primaryKey",
  "value"
]);
proxyRequestMethods(Cursor, "_cursor", IDBCursor, [
  "update",
  "delete"
]);
["advance", "continue", "continuePrimaryKey"].forEach(function(methodName) {
  if (!(methodName in IDBCursor.prototype)) return;
  Cursor.prototype[methodName] = function() {
    var cursor = this;
    var args = arguments;
    return Promise.resolve().then(function() {
      cursor._cursor[methodName].apply(cursor._cursor, args);
      return promisifyRequest(cursor._request).then(function(value) {
        if (!value) return;
        return new Cursor(value, cursor._request);
      });
    });
  };
});
function ObjectStore(store) {
  this._store = store;
}
ObjectStore.prototype.createIndex = function() {
  return new Index2(this._store.createIndex.apply(this._store, arguments));
};
ObjectStore.prototype.index = function() {
  return new Index2(this._store.index.apply(this._store, arguments));
};
proxyProperties(ObjectStore, "_store", [
  "name",
  "keyPath",
  "indexNames",
  "autoIncrement"
]);
proxyRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "put",
  "add",
  "delete",
  "clear",
  "get",
  "getAll",
  "getKey",
  "getAllKeys",
  "count"
]);
proxyCursorRequestMethods(ObjectStore, "_store", IDBObjectStore, [
  "openCursor",
  "openKeyCursor"
]);
proxyMethods(ObjectStore, "_store", IDBObjectStore, [
  "deleteIndex"
]);
function Transaction(idbTransaction) {
  this._tx = idbTransaction;
  this.complete = new Promise(function(resolve, reject) {
    idbTransaction.oncomplete = function() {
      resolve();
    };
    idbTransaction.onerror = function() {
      reject(idbTransaction.error);
    };
    idbTransaction.onabort = function() {
      reject(idbTransaction.error);
    };
  });
}
Transaction.prototype.objectStore = function() {
  return new ObjectStore(this._tx.objectStore.apply(this._tx, arguments));
};
proxyProperties(Transaction, "_tx", [
  "objectStoreNames",
  "mode"
]);
proxyMethods(Transaction, "_tx", IDBTransaction, [
  "abort"
]);
function UpgradeDB(db, oldVersion, transaction) {
  this._db = db;
  this.oldVersion = oldVersion;
  this.transaction = new Transaction(transaction);
}
UpgradeDB.prototype.createObjectStore = function() {
  return new ObjectStore(this._db.createObjectStore.apply(this._db, arguments));
};
proxyProperties(UpgradeDB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(UpgradeDB, "_db", IDBDatabase, [
  "deleteObjectStore",
  "close"
]);
function DB(db) {
  this._db = db;
}
DB.prototype.transaction = function() {
  return new Transaction(this._db.transaction.apply(this._db, arguments));
};
proxyProperties(DB, "_db", [
  "name",
  "version",
  "objectStoreNames"
]);
proxyMethods(DB, "_db", IDBDatabase, [
  "close"
]);
["openCursor", "openKeyCursor"].forEach(function(funcName) {
  [ObjectStore, Index2].forEach(function(Constructor) {
    if (!(funcName in Constructor.prototype)) return;
    Constructor.prototype[funcName.replace("open", "iterate")] = function() {
      var args = toArray(arguments);
      var callback = args[args.length - 1];
      var nativeObject = this._store || this._index;
      var request = nativeObject[funcName].apply(nativeObject, args.slice(0, -1));
      request.onsuccess = function() {
        callback(request.result);
      };
    };
  });
});
[Index2, ObjectStore].forEach(function(Constructor) {
  if (Constructor.prototype.getAll) return;
  Constructor.prototype.getAll = function(query2, count) {
    var instance = this;
    var items = [];
    return new Promise(function(resolve) {
      instance.iterateCursor(query2, function(cursor) {
        if (!cursor) {
          resolve(items);
          return;
        }
        items.push(cursor.value);
        if (count !== void 0 && items.length == count) {
          resolve(items);
          return;
        }
        cursor.continue();
      });
    });
  };
});
function openDb(name10, version10, upgradeCallback) {
  var p = promisifyRequestCall(indexedDB, "open", [name10, version10]);
  var request = p.request;
  if (request) {
    request.onupgradeneeded = function(event) {
      if (upgradeCallback) {
        upgradeCallback(new UpgradeDB(request.result, event.oldVersion, request.transaction));
      }
    };
  }
  return p.then(function(db) {
    return new DB(db);
  });
}
function deleteDb(name10) {
  return promisifyRequestCall(indexedDB, "deleteDatabase", [name10]);
}

// node_modules/@firebase/installations/dist/index.esm.js
var name3 = "@firebase/installations";
var version3 = "0.4.32";
var PENDING_TIMEOUT_MS = 1e4;
var PACKAGE_VERSION = "w:" + version3;
var INTERNAL_AUTH_VERSION = "FIS_v2";
var INSTALLATIONS_API_URL = "https://firebaseinstallations.googleapis.com/v1";
var TOKEN_EXPIRATION_BUFFER = 60 * 60 * 1e3;
var SERVICE = "installations";
var SERVICE_NAME = "Installations";
var _a;
var ERROR_DESCRIPTION_MAP = (_a = {}, _a[
  "missing-app-config-values"
  /* MISSING_APP_CONFIG_VALUES */
] = 'Missing App configuration value: "{$valueName}"', _a[
  "not-registered"
  /* NOT_REGISTERED */
] = "Firebase Installation is not registered.", _a[
  "installation-not-found"
  /* INSTALLATION_NOT_FOUND */
] = "Firebase Installation not found.", _a[
  "request-failed"
  /* REQUEST_FAILED */
] = '{$requestName} request failed with error "{$serverCode} {$serverStatus}: {$serverMessage}"', _a[
  "app-offline"
  /* APP_OFFLINE */
] = "Could not process request. Application offline.", _a[
  "delete-pending-registration"
  /* DELETE_PENDING_REGISTRATION */
] = "Can't delete installation while there is a pending registration request.", _a);
var ERROR_FACTORY = new ErrorFactory(SERVICE, SERVICE_NAME, ERROR_DESCRIPTION_MAP);
function isServerError(error2) {
  return error2 instanceof FirebaseError && error2.code.includes(
    "request-failed"
    /* REQUEST_FAILED */
  );
}
function getInstallationsEndpoint(_a7) {
  var projectId = _a7.projectId;
  return INSTALLATIONS_API_URL + "/projects/" + projectId + "/installations";
}
function extractAuthTokenInfoFromResponse(response) {
  return {
    token: response.token,
    requestStatus: 2,
    expiresIn: getExpiresInFromResponseExpiresIn(response.expiresIn),
    creationTime: Date.now()
  };
}
function getErrorFromResponse(requestName, response) {
  return __awaiter(this, void 0, void 0, function() {
    var responseJson, errorData;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, response.json()];
        case 1:
          responseJson = _a7.sent();
          errorData = responseJson.error;
          return [2, ERROR_FACTORY.create("request-failed", {
            requestName,
            serverCode: errorData.code,
            serverMessage: errorData.message,
            serverStatus: errorData.status
          })];
      }
    });
  });
}
function getHeaders(_a7) {
  var apiKey = _a7.apiKey;
  return new Headers({
    "Content-Type": "application/json",
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function getHeadersWithAuth(appConfig, _a7) {
  var refreshToken = _a7.refreshToken;
  var headers = getHeaders(appConfig);
  headers.append("Authorization", getAuthorizationHeader(refreshToken));
  return headers;
}
function retryIfServerError(fn) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, fn()];
        case 1:
          result = _a7.sent();
          if (result.status >= 500 && result.status < 600) {
            return [2, fn()];
          }
          return [2, result];
      }
    });
  });
}
function getExpiresInFromResponseExpiresIn(responseExpiresIn) {
  return Number(responseExpiresIn.replace("s", "000"));
}
function getAuthorizationHeader(refreshToken) {
  return INTERNAL_AUTH_VERSION + " " + refreshToken;
}
function createInstallationRequest(appConfig, _a7) {
  var fid = _a7.fid;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, body, request, response, responseValue, registeredInstallationEntry;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getInstallationsEndpoint(appConfig);
          headers = getHeaders(appConfig);
          body = {
            fid,
            authVersion: INTERNAL_AUTH_VERSION,
            appId: appConfig.appId,
            sdkVersion: PACKAGE_VERSION
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok) return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          registeredInstallationEntry = {
            fid: responseValue.fid || fid,
            registrationStatus: 2,
            refreshToken: responseValue.refreshToken,
            authToken: extractAuthTokenInfoFromResponse(responseValue.authToken)
          };
          return [2, registeredInstallationEntry];
        case 3:
          return [4, getErrorFromResponse("Create Installation", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function sleep(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
function bufferToBase64UrlSafe(array) {
  var b64 = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(array))));
  return b64.replace(/\+/g, "-").replace(/\//g, "_");
}
var VALID_FID_PATTERN = /^[cdef][\w-]{21}$/;
var INVALID_FID = "";
function generateFid() {
  try {
    var fidByteArray = new Uint8Array(17);
    var crypto_1 = self.crypto || self.msCrypto;
    crypto_1.getRandomValues(fidByteArray);
    fidByteArray[0] = 112 + fidByteArray[0] % 16;
    var fid = encode(fidByteArray);
    return VALID_FID_PATTERN.test(fid) ? fid : INVALID_FID;
  } catch (_a7) {
    return INVALID_FID;
  }
}
function encode(fidByteArray) {
  var b64String = bufferToBase64UrlSafe(fidByteArray);
  return b64String.substr(0, 22);
}
function getKey(appConfig) {
  return appConfig.appName + "!" + appConfig.appId;
}
var fidChangeCallbacks = /* @__PURE__ */ new Map();
function fidChanged(appConfig, fid) {
  var key = getKey(appConfig);
  callFidChangeCallbacks(key, fid);
  broadcastFidChange(key, fid);
}
function addCallback(appConfig, callback) {
  getBroadcastChannel();
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    callbackSet = /* @__PURE__ */ new Set();
    fidChangeCallbacks.set(key, callbackSet);
  }
  callbackSet.add(callback);
}
function removeCallback(appConfig, callback) {
  var key = getKey(appConfig);
  var callbackSet = fidChangeCallbacks.get(key);
  if (!callbackSet) {
    return;
  }
  callbackSet.delete(callback);
  if (callbackSet.size === 0) {
    fidChangeCallbacks.delete(key);
  }
  closeBroadcastChannel();
}
function callFidChangeCallbacks(key, fid) {
  var e_1, _a7;
  var callbacks = fidChangeCallbacks.get(key);
  if (!callbacks) {
    return;
  }
  try {
    for (var callbacks_1 = __values(callbacks), callbacks_1_1 = callbacks_1.next(); !callbacks_1_1.done; callbacks_1_1 = callbacks_1.next()) {
      var callback = callbacks_1_1.value;
      callback(fid);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (callbacks_1_1 && !callbacks_1_1.done && (_a7 = callbacks_1.return)) _a7.call(callbacks_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
}
function broadcastFidChange(key, fid) {
  var channel = getBroadcastChannel();
  if (channel) {
    channel.postMessage({ key, fid });
  }
  closeBroadcastChannel();
}
var broadcastChannel = null;
function getBroadcastChannel() {
  if (!broadcastChannel && "BroadcastChannel" in self) {
    broadcastChannel = new BroadcastChannel("[Firebase] FID Change");
    broadcastChannel.onmessage = function(e) {
      callFidChangeCallbacks(e.data.key, e.data.fid);
    };
  }
  return broadcastChannel;
}
function closeBroadcastChannel() {
  if (fidChangeCallbacks.size === 0 && broadcastChannel) {
    broadcastChannel.close();
    broadcastChannel = null;
  }
}
var DATABASE_NAME = "firebase-installations-database";
var DATABASE_VERSION = 1;
var OBJECT_STORE_NAME = "firebase-installations-store";
var dbPromise = null;
function getDbPromise() {
  if (!dbPromise) {
    dbPromise = openDb(DATABASE_NAME, DATABASE_VERSION, function(upgradeDB) {
      switch (upgradeDB.oldVersion) {
        case 0:
          upgradeDB.createObjectStore(OBJECT_STORE_NAME);
      }
    });
  }
  return dbPromise;
}
function set2(appConfig, value) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx, objectStore, oldValue;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a7.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          objectStore = tx.objectStore(OBJECT_STORE_NAME);
          return [4, objectStore.get(key)];
        case 2:
          oldValue = _a7.sent();
          return [4, objectStore.put(value, key)];
        case 3:
          _a7.sent();
          return [4, tx.complete];
        case 4:
          _a7.sent();
          if (!oldValue || oldValue.fid !== value.fid) {
            fidChanged(appConfig, value.fid);
          }
          return [2, value];
      }
    });
  });
}
function remove2(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a7.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME).delete(key)];
        case 2:
          _a7.sent();
          return [4, tx.complete];
        case 3:
          _a7.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function update2(appConfig, updateFn) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx, store, oldValue, newValue;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          key = getKey(appConfig);
          return [4, getDbPromise()];
        case 1:
          db = _a7.sent();
          tx = db.transaction(OBJECT_STORE_NAME, "readwrite");
          store = tx.objectStore(OBJECT_STORE_NAME);
          return [4, store.get(key)];
        case 2:
          oldValue = _a7.sent();
          newValue = updateFn(oldValue);
          if (!(newValue === void 0)) return [3, 4];
          return [4, store.delete(key)];
        case 3:
          _a7.sent();
          return [3, 6];
        case 4:
          return [4, store.put(newValue, key)];
        case 5:
          _a7.sent();
          _a7.label = 6;
        case 6:
          return [4, tx.complete];
        case 7:
          _a7.sent();
          if (newValue && (!oldValue || oldValue.fid !== newValue.fid)) {
            fidChanged(appConfig, newValue.fid);
          }
          return [2, newValue];
      }
    });
  });
}
function getInstallationEntry(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise, installationEntry;
    var _a7;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update2(appConfig, function(oldEntry) {
            var installationEntry2 = updateOrCreateInstallationEntry(oldEntry);
            var entryWithPromise = triggerRegistrationIfNecessary(appConfig, installationEntry2);
            registrationPromise = entryWithPromise.registrationPromise;
            return entryWithPromise.installationEntry;
          })];
        case 1:
          installationEntry = _b.sent();
          if (!(installationEntry.fid === INVALID_FID)) return [3, 3];
          _a7 = {};
          return [4, registrationPromise];
        case 2:
          return [2, (_a7.installationEntry = _b.sent(), _a7)];
        case 3:
          return [2, {
            installationEntry,
            registrationPromise
          }];
      }
    });
  });
}
function updateOrCreateInstallationEntry(oldEntry) {
  var entry = oldEntry || {
    fid: generateFid(),
    registrationStatus: 0
    /* NOT_STARTED */
  };
  return clearTimedOutRequest(entry);
}
function triggerRegistrationIfNecessary(appConfig, installationEntry) {
  if (installationEntry.registrationStatus === 0) {
    if (!navigator.onLine) {
      var registrationPromiseWithError = Promise.reject(ERROR_FACTORY.create(
        "app-offline"
        /* APP_OFFLINE */
      ));
      return {
        installationEntry,
        registrationPromise: registrationPromiseWithError
      };
    }
    var inProgressEntry = {
      fid: installationEntry.fid,
      registrationStatus: 1,
      registrationTime: Date.now()
    };
    var registrationPromise = registerInstallation(appConfig, inProgressEntry);
    return { installationEntry: inProgressEntry, registrationPromise };
  } else if (installationEntry.registrationStatus === 1) {
    return {
      installationEntry,
      registrationPromise: waitUntilFidRegistration(appConfig)
    };
  } else {
    return { installationEntry };
  }
}
function registerInstallation(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var registeredInstallationEntry, e_1;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          _a7.trys.push([0, 2, , 7]);
          return [4, createInstallationRequest(appConfig, installationEntry)];
        case 1:
          registeredInstallationEntry = _a7.sent();
          return [2, set2(appConfig, registeredInstallationEntry)];
        case 2:
          e_1 = _a7.sent();
          if (!(isServerError(e_1) && e_1.customData.serverCode === 409)) return [3, 4];
          return [4, remove2(appConfig)];
        case 3:
          _a7.sent();
          return [3, 6];
        case 4:
          return [4, set2(appConfig, {
            fid: installationEntry.fid,
            registrationStatus: 0
            /* NOT_STARTED */
          })];
        case 5:
          _a7.sent();
          _a7.label = 6;
        case 6:
          throw e_1;
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function waitUntilFidRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, _a7, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, updateInstallationRequest(appConfig)];
        case 1:
          entry = _b.sent();
          _b.label = 2;
        case 2:
          if (!(entry.registrationStatus === 1)) return [3, 5];
          return [4, sleep(100)];
        case 3:
          _b.sent();
          return [4, updateInstallationRequest(appConfig)];
        case 4:
          entry = _b.sent();
          return [3, 2];
        case 5:
          if (!(entry.registrationStatus === 0)) return [3, 7];
          return [4, getInstallationEntry(appConfig)];
        case 6:
          _a7 = _b.sent(), installationEntry = _a7.installationEntry, registrationPromise = _a7.registrationPromise;
          if (registrationPromise) {
            return [2, registrationPromise];
          } else {
            return [2, installationEntry];
          }
        case 7:
          return [2, entry];
      }
    });
  });
}
function updateInstallationRequest(appConfig) {
  return update2(appConfig, function(oldEntry) {
    if (!oldEntry) {
      throw ERROR_FACTORY.create(
        "installation-not-found"
        /* INSTALLATION_NOT_FOUND */
      );
    }
    return clearTimedOutRequest(oldEntry);
  });
}
function clearTimedOutRequest(entry) {
  if (hasInstallationRequestTimedOut(entry)) {
    return {
      fid: entry.fid,
      registrationStatus: 0
      /* NOT_STARTED */
    };
  }
  return entry;
}
function hasInstallationRequestTimedOut(installationEntry) {
  return installationEntry.registrationStatus === 1 && installationEntry.registrationTime + PENDING_TIMEOUT_MS < Date.now();
}
function generateAuthTokenRequest(_a7, installationEntry) {
  var appConfig = _a7.appConfig, platformLoggerProvider = _a7.platformLoggerProvider;
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, platformLogger, body, request, response, responseValue, completedAuthToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          endpoint = getGenerateAuthTokenEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          platformLogger = platformLoggerProvider.getImmediate({
            optional: true
          });
          if (platformLogger) {
            headers.append("x-firebase-client", platformLogger.getPlatformInfoString());
          }
          body = {
            installation: {
              sdkVersion: PACKAGE_VERSION
            }
          };
          request = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _b.sent();
          if (!response.ok) return [3, 3];
          return [4, response.json()];
        case 2:
          responseValue = _b.sent();
          completedAuthToken = extractAuthTokenInfoFromResponse(responseValue);
          return [2, completedAuthToken];
        case 3:
          return [4, getErrorFromResponse("Generate Auth Token", response)];
        case 4:
          throw _b.sent();
      }
    });
  });
}
function getGenerateAuthTokenEndpoint(appConfig, _a7) {
  var fid = _a7.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid + "/authTokens:generate";
}
function refreshAuthToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var tokenPromise, entry, authToken, _a7;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, update2(dependencies.appConfig, function(oldEntry) {
            if (!isEntryRegistered(oldEntry)) {
              throw ERROR_FACTORY.create(
                "not-registered"
                /* NOT_REGISTERED */
              );
            }
            var oldAuthToken = oldEntry.authToken;
            if (!forceRefresh && isAuthTokenValid(oldAuthToken)) {
              return oldEntry;
            } else if (oldAuthToken.requestStatus === 1) {
              tokenPromise = waitUntilAuthTokenRequest(dependencies, forceRefresh);
              return oldEntry;
            } else {
              if (!navigator.onLine) {
                throw ERROR_FACTORY.create(
                  "app-offline"
                  /* APP_OFFLINE */
                );
              }
              var inProgressEntry = makeAuthTokenRequestInProgressEntry(oldEntry);
              tokenPromise = fetchAuthTokenFromServer(dependencies, inProgressEntry);
              return inProgressEntry;
            }
          })];
        case 1:
          entry = _b.sent();
          if (!tokenPromise) return [3, 3];
          return [4, tokenPromise];
        case 2:
          _a7 = _b.sent();
          return [3, 4];
        case 3:
          _a7 = entry.authToken;
          _b.label = 4;
        case 4:
          authToken = _a7;
          return [2, authToken];
      }
    });
  });
}
function waitUntilAuthTokenRequest(dependencies, forceRefresh) {
  return __awaiter(this, void 0, void 0, function() {
    var entry, authToken;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 1:
          entry = _a7.sent();
          _a7.label = 2;
        case 2:
          if (!(entry.authToken.requestStatus === 1)) return [3, 5];
          return [4, sleep(100)];
        case 3:
          _a7.sent();
          return [4, updateAuthTokenRequest(dependencies.appConfig)];
        case 4:
          entry = _a7.sent();
          return [3, 2];
        case 5:
          authToken = entry.authToken;
          if (authToken.requestStatus === 0) {
            return [2, refreshAuthToken(dependencies, forceRefresh)];
          } else {
            return [2, authToken];
          }
      }
    });
  });
}
function updateAuthTokenRequest(appConfig) {
  return update2(appConfig, function(oldEntry) {
    if (!isEntryRegistered(oldEntry)) {
      throw ERROR_FACTORY.create(
        "not-registered"
        /* NOT_REGISTERED */
      );
    }
    var oldAuthToken = oldEntry.authToken;
    if (hasAuthTokenRequestTimedOut(oldAuthToken)) {
      return __assign(__assign({}, oldEntry), { authToken: {
        requestStatus: 0
        /* NOT_STARTED */
      } });
    }
    return oldEntry;
  });
}
function fetchAuthTokenFromServer(dependencies, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var authToken, updatedInstallationEntry, e_1, updatedInstallationEntry;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          _a7.trys.push([0, 3, , 8]);
          return [4, generateAuthTokenRequest(dependencies, installationEntry)];
        case 1:
          authToken = _a7.sent();
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken });
          return [4, set2(dependencies.appConfig, updatedInstallationEntry)];
        case 2:
          _a7.sent();
          return [2, authToken];
        case 3:
          e_1 = _a7.sent();
          if (!(isServerError(e_1) && (e_1.customData.serverCode === 401 || e_1.customData.serverCode === 404))) return [3, 5];
          return [4, remove2(dependencies.appConfig)];
        case 4:
          _a7.sent();
          return [3, 7];
        case 5:
          updatedInstallationEntry = __assign(__assign({}, installationEntry), { authToken: {
            requestStatus: 0
            /* NOT_STARTED */
          } });
          return [4, set2(dependencies.appConfig, updatedInstallationEntry)];
        case 6:
          _a7.sent();
          _a7.label = 7;
        case 7:
          throw e_1;
        case 8:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function isEntryRegistered(installationEntry) {
  return installationEntry !== void 0 && installationEntry.registrationStatus === 2;
}
function isAuthTokenValid(authToken) {
  return authToken.requestStatus === 2 && !isAuthTokenExpired(authToken);
}
function isAuthTokenExpired(authToken) {
  var now = Date.now();
  return now < authToken.creationTime || authToken.creationTime + authToken.expiresIn < now + TOKEN_EXPIRATION_BUFFER;
}
function makeAuthTokenRequestInProgressEntry(oldEntry) {
  var inProgressAuthToken = {
    requestStatus: 1,
    requestTime: Date.now()
  };
  return __assign(__assign({}, oldEntry), { authToken: inProgressAuthToken });
}
function hasAuthTokenRequestTimedOut(authToken) {
  return authToken.requestStatus === 1 && authToken.requestTime + PENDING_TIMEOUT_MS < Date.now();
}
function getId(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var _a7, installationEntry, registrationPromise;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getInstallationEntry(dependencies.appConfig)];
        case 1:
          _a7 = _b.sent(), installationEntry = _a7.installationEntry, registrationPromise = _a7.registrationPromise;
          if (registrationPromise) {
            registrationPromise.catch(console.error);
          } else {
            refreshAuthToken(dependencies).catch(console.error);
          }
          return [2, installationEntry.fid];
      }
    });
  });
}
function getToken(dependencies, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, completeInstallationRegistration(dependencies.appConfig)];
        case 1:
          _a7.sent();
          return [4, refreshAuthToken(dependencies, forceRefresh)];
        case 2:
          authToken = _a7.sent();
          return [2, authToken.token];
      }
    });
  });
}
function completeInstallationRegistration(appConfig) {
  return __awaiter(this, void 0, void 0, function() {
    var registrationPromise;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getInstallationEntry(appConfig)];
        case 1:
          registrationPromise = _a7.sent().registrationPromise;
          if (!registrationPromise) return [3, 3];
          return [4, registrationPromise];
        case 2:
          _a7.sent();
          _a7.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function deleteInstallationRequest(appConfig, installationEntry) {
  return __awaiter(this, void 0, void 0, function() {
    var endpoint, headers, request, response;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          endpoint = getDeleteEndpoint(appConfig, installationEntry);
          headers = getHeadersWithAuth(appConfig, installationEntry);
          request = {
            method: "DELETE",
            headers
          };
          return [4, retryIfServerError(function() {
            return fetch(endpoint, request);
          })];
        case 1:
          response = _a7.sent();
          if (!!response.ok) return [3, 3];
          return [4, getErrorFromResponse("Delete Installation", response)];
        case 2:
          throw _a7.sent();
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getDeleteEndpoint(appConfig, _a7) {
  var fid = _a7.fid;
  return getInstallationsEndpoint(appConfig) + "/" + fid;
}
function deleteInstallation(dependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var appConfig, entry;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          appConfig = dependencies.appConfig;
          return [4, update2(appConfig, function(oldEntry) {
            if (oldEntry && oldEntry.registrationStatus === 0) {
              return void 0;
            }
            return oldEntry;
          })];
        case 1:
          entry = _a7.sent();
          if (!entry) return [3, 6];
          if (!(entry.registrationStatus === 1)) return [3, 2];
          throw ERROR_FACTORY.create(
            "delete-pending-registration"
            /* DELETE_PENDING_REGISTRATION */
          );
        case 2:
          if (!(entry.registrationStatus === 2)) return [3, 6];
          if (!!navigator.onLine) return [3, 3];
          throw ERROR_FACTORY.create(
            "app-offline"
            /* APP_OFFLINE */
          );
        case 3:
          return [4, deleteInstallationRequest(appConfig, entry)];
        case 4:
          _a7.sent();
          return [4, remove2(appConfig)];
        case 5:
          _a7.sent();
          _a7.label = 6;
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function onIdChange(_a7, callback) {
  var appConfig = _a7.appConfig;
  addCallback(appConfig, callback);
  return function() {
    removeCallback(appConfig, callback);
  };
}
function extractAppConfig(app) {
  var e_1, _a7;
  if (!app || !app.options) {
    throw getMissingValueError("App Configuration");
  }
  if (!app.name) {
    throw getMissingValueError("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId"
  ];
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!app.options[keyName]) {
        throw getMissingValueError(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a7 = configKeys_1.return)) _a7.call(configKeys_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: app.options.projectId,
    apiKey: app.options.apiKey,
    appId: app.options.appId
  };
}
function getMissingValueError(valueName) {
  return ERROR_FACTORY.create("missing-app-config-values", {
    valueName
  });
}
function registerInstallations(instance) {
  var installationsName = "installations";
  instance.INTERNAL.registerComponent(new Component(
    installationsName,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var appConfig = extractAppConfig(app);
      var platformLoggerProvider = container.getProvider("platform-logger");
      var dependencies = {
        appConfig,
        platformLoggerProvider
      };
      var installations = {
        app,
        getId: function() {
          return getId(dependencies);
        },
        getToken: function(forceRefresh) {
          return getToken(dependencies, forceRefresh);
        },
        delete: function() {
          return deleteInstallation(dependencies);
        },
        onIdChange: function(callback) {
          return onIdChange(dependencies, callback);
        }
      };
      return installations;
    },
    "PUBLIC"
    /* PUBLIC */
  ));
  instance.registerVersion(name3, version3);
}
registerInstallations(index_esm_default);

// node_modules/@firebase/messaging/dist/index.esm.js
var _a2;
var ERROR_MAP = (_a2 = {}, _a2[
  "missing-app-config-values"
  /* MISSING_APP_CONFIG_VALUES */
] = 'Missing App configuration value: "{$valueName}"', _a2[
  "only-available-in-window"
  /* AVAILABLE_IN_WINDOW */
] = "This method is available in a Window context.", _a2[
  "only-available-in-sw"
  /* AVAILABLE_IN_SW */
] = "This method is available in a service worker context.", _a2[
  "permission-default"
  /* PERMISSION_DEFAULT */
] = "The notification permission was not granted and dismissed instead.", _a2[
  "permission-blocked"
  /* PERMISSION_BLOCKED */
] = "The notification permission was not granted and blocked instead.", _a2[
  "unsupported-browser"
  /* UNSUPPORTED_BROWSER */
] = "This browser doesn't support the API's required to use the firebase SDK.", _a2[
  "failed-service-worker-registration"
  /* FAILED_DEFAULT_REGISTRATION */
] = "We are unable to register the default service worker. {$browserErrorMessage}", _a2[
  "token-subscribe-failed"
  /* TOKEN_SUBSCRIBE_FAILED */
] = "A problem occurred while subscribing the user to FCM: {$errorInfo}", _a2[
  "token-subscribe-no-token"
  /* TOKEN_SUBSCRIBE_NO_TOKEN */
] = "FCM returned no token when subscribing the user to push.", _a2[
  "token-unsubscribe-failed"
  /* TOKEN_UNSUBSCRIBE_FAILED */
] = "A problem occurred while unsubscribing the user from FCM: {$errorInfo}", _a2[
  "token-update-failed"
  /* TOKEN_UPDATE_FAILED */
] = "A problem occurred while updating the user from FCM: {$errorInfo}", _a2[
  "token-update-no-token"
  /* TOKEN_UPDATE_NO_TOKEN */
] = "FCM returned no token when updating the user to push.", _a2[
  "use-sw-after-get-token"
  /* USE_SW_AFTER_GET_TOKEN */
] = "The useServiceWorker() method may only be called once and must be called before calling getToken() to ensure your service worker is used.", _a2[
  "invalid-sw-registration"
  /* INVALID_SW_REGISTRATION */
] = "The input to useServiceWorker() must be a ServiceWorkerRegistration.", _a2[
  "invalid-bg-handler"
  /* INVALID_BG_HANDLER */
] = "The input to setBackgroundMessageHandler() must be a function.", _a2[
  "invalid-vapid-key"
  /* INVALID_VAPID_KEY */
] = "The public VAPID key must be a string.", _a2[
  "use-vapid-key-after-get-token"
  /* USE_VAPID_KEY_AFTER_GET_TOKEN */
] = "The usePublicVapidKey() method may only be called once and must be called before calling getToken() to ensure your VAPID key is used.", _a2);
var ERROR_FACTORY2 = new ErrorFactory("messaging", "Messaging", ERROR_MAP);
var DEFAULT_SW_PATH = "/firebase-messaging-sw.js";
var DEFAULT_SW_SCOPE = "/firebase-cloud-messaging-push-scope";
var DEFAULT_VAPID_KEY = "BDOU99-h67HcA6JeFXHbSNMu7e2yNNu3RzoMj8TM4W88jITfq7ZmPvIM1Iv-4_l2LxQcYwhqby2xGpWwzjfAnG4";
var ENDPOINT = "https://fcmregistrations.googleapis.com/v1";
var FCM_MSG = "FCM_MSG";
var TAG = "FirebaseMessaging: ";
var CONSOLE_CAMPAIGN_ANALYTICS_ENABLED = "google.c.a.e";
var CONSOLE_CAMPAIGN_ID = "google.c.a.c_id";
var CONSOLE_CAMPAIGN_TIME = "google.c.a.ts";
var CONSOLE_CAMPAIGN_NAME = "google.c.a.c_l";
var BACKGROUND_HANDLE_EXECUTION_TIME_LIMIT_MS = 1e3;
var FOREGROUND_HANDLE_PREPARATION_TIME_MS = 3e3;
var MessageType;
(function(MessageType2) {
  MessageType2["PUSH_RECEIVED"] = "push-received";
  MessageType2["NOTIFICATION_CLICKED"] = "notification-clicked";
})(MessageType || (MessageType = {}));
function arrayToBase64(array) {
  var uint8Array = new Uint8Array(array);
  var base64String = btoa(String.fromCharCode.apply(String, __spreadArray([], __read(uint8Array))));
  return base64String.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function base64ToArray(base64String) {
  var padding = "=".repeat((4 - base64String.length % 4) % 4);
  var base642 = (base64String + padding).replace(/\-/g, "+").replace(/_/g, "/");
  var rawData = atob(base642);
  var outputArray = new Uint8Array(rawData.length);
  for (var i = 0; i < rawData.length; ++i) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}
var OLD_DB_NAME = "fcm_token_details_db";
var OLD_DB_VERSION = 5;
var OLD_OBJECT_STORE_NAME = "fcm_token_object_Store";
function migrateOldDatabase(senderId) {
  return __awaiter(this, void 0, void 0, function() {
    var databases, dbNames, tokenDetails, db;
    var _this = this;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (!("databases" in indexedDB)) return [3, 2];
          return [4, indexedDB.databases()];
        case 1:
          databases = _a7.sent();
          dbNames = databases.map(function(db2) {
            return db2.name;
          });
          if (!dbNames.includes(OLD_DB_NAME)) {
            return [2, null];
          }
          _a7.label = 2;
        case 2:
          tokenDetails = null;
          return [4, openDb(OLD_DB_NAME, OLD_DB_VERSION, function(db2) {
            return __awaiter(_this, void 0, void 0, function() {
              var objectStore, value, oldDetails, oldDetails, oldDetails;
              var _a8;
              return __generator(this, function(_b) {
                switch (_b.label) {
                  case 0:
                    if (db2.oldVersion < 2) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    if (!db2.objectStoreNames.contains(OLD_OBJECT_STORE_NAME)) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    objectStore = db2.transaction.objectStore(OLD_OBJECT_STORE_NAME);
                    return [4, objectStore.index("fcmSenderId").get(senderId)];
                  case 1:
                    value = _b.sent();
                    return [4, objectStore.clear()];
                  case 2:
                    _b.sent();
                    if (!value) {
                      return [
                        2
                        /*return*/
                      ];
                    }
                    if (db2.oldVersion === 2) {
                      oldDetails = value;
                      if (!oldDetails.auth || !oldDetails.p256dh || !oldDetails.endpoint) {
                        return [
                          2
                          /*return*/
                        ];
                      }
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: (_a8 = oldDetails.createTime) !== null && _a8 !== void 0 ? _a8 : Date.now(),
                        subscriptionOptions: {
                          auth: oldDetails.auth,
                          p256dh: oldDetails.p256dh,
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: typeof oldDetails.vapidKey === "string" ? oldDetails.vapidKey : arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    } else if (db2.oldVersion === 3) {
                      oldDetails = value;
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: oldDetails.createTime,
                        subscriptionOptions: {
                          auth: arrayToBase64(oldDetails.auth),
                          p256dh: arrayToBase64(oldDetails.p256dh),
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    } else if (db2.oldVersion === 4) {
                      oldDetails = value;
                      tokenDetails = {
                        token: oldDetails.fcmToken,
                        createTime: oldDetails.createTime,
                        subscriptionOptions: {
                          auth: arrayToBase64(oldDetails.auth),
                          p256dh: arrayToBase64(oldDetails.p256dh),
                          endpoint: oldDetails.endpoint,
                          swScope: oldDetails.swScope,
                          vapidKey: arrayToBase64(oldDetails.vapidKey)
                        }
                      };
                    }
                    return [
                      2
                      /*return*/
                    ];
                }
              });
            });
          })];
        case 3:
          db = _a7.sent();
          db.close();
          return [4, deleteDb(OLD_DB_NAME)];
        case 4:
          _a7.sent();
          return [4, deleteDb("fcm_vapid_details_db")];
        case 5:
          _a7.sent();
          return [4, deleteDb("undefined")];
        case 6:
          _a7.sent();
          return [2, checkTokenDetails(tokenDetails) ? tokenDetails : null];
      }
    });
  });
}
function checkTokenDetails(tokenDetails) {
  if (!tokenDetails || !tokenDetails.subscriptionOptions) {
    return false;
  }
  var subscriptionOptions = tokenDetails.subscriptionOptions;
  return typeof tokenDetails.createTime === "number" && tokenDetails.createTime > 0 && typeof tokenDetails.token === "string" && tokenDetails.token.length > 0 && typeof subscriptionOptions.auth === "string" && subscriptionOptions.auth.length > 0 && typeof subscriptionOptions.p256dh === "string" && subscriptionOptions.p256dh.length > 0 && typeof subscriptionOptions.endpoint === "string" && subscriptionOptions.endpoint.length > 0 && typeof subscriptionOptions.swScope === "string" && subscriptionOptions.swScope.length > 0 && typeof subscriptionOptions.vapidKey === "string" && subscriptionOptions.vapidKey.length > 0;
}
var DATABASE_NAME2 = "firebase-messaging-database";
var DATABASE_VERSION2 = 1;
var OBJECT_STORE_NAME2 = "firebase-messaging-store";
var dbPromise2 = null;
function getDbPromise2() {
  if (!dbPromise2) {
    dbPromise2 = openDb(DATABASE_NAME2, DATABASE_VERSION2, function(upgradeDb) {
      switch (upgradeDb.oldVersion) {
        case 0:
          upgradeDb.createObjectStore(OBJECT_STORE_NAME2);
      }
    });
  }
  return dbPromise2;
}
function dbGet(firebaseDependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tokenDetails, oldTokenDetails;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db = _a7.sent();
          return [4, db.transaction(OBJECT_STORE_NAME2).objectStore(OBJECT_STORE_NAME2).get(key)];
        case 2:
          tokenDetails = _a7.sent();
          if (!tokenDetails) return [3, 3];
          return [2, tokenDetails];
        case 3:
          return [4, migrateOldDatabase(firebaseDependencies.appConfig.senderId)];
        case 4:
          oldTokenDetails = _a7.sent();
          if (!oldTokenDetails) return [3, 6];
          return [4, dbSet(firebaseDependencies, oldTokenDetails)];
        case 5:
          _a7.sent();
          return [2, oldTokenDetails];
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function dbSet(firebaseDependencies, tokenDetails) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db = _a7.sent();
          tx = db.transaction(OBJECT_STORE_NAME2, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME2).put(tokenDetails, key)];
        case 2:
          _a7.sent();
          return [4, tx.complete];
        case 3:
          _a7.sent();
          return [2, tokenDetails];
      }
    });
  });
}
function dbRemove(firebaseDependencies) {
  return __awaiter(this, void 0, void 0, function() {
    var key, db, tx;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          key = getKey2(firebaseDependencies);
          return [4, getDbPromise2()];
        case 1:
          db = _a7.sent();
          tx = db.transaction(OBJECT_STORE_NAME2, "readwrite");
          return [4, tx.objectStore(OBJECT_STORE_NAME2).delete(key)];
        case 2:
          _a7.sent();
          return [4, tx.complete];
        case 3:
          _a7.sent();
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getKey2(_a7) {
  var appConfig = _a7.appConfig;
  return appConfig.appId;
}
function requestGetToken(firebaseDependencies, subscriptionOptions) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, body, subscribeOptions, responseData, response, err_1, message;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a7.sent();
          body = getBody(subscriptionOptions);
          subscribeOptions = {
            method: "POST",
            headers,
            body: JSON.stringify(body)
          };
          _a7.label = 2;
        case 2:
          _a7.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig), subscribeOptions)];
        case 3:
          response = _a7.sent();
          return [4, response.json()];
        case 4:
          responseData = _a7.sent();
          return [3, 6];
        case 5:
          err_1 = _a7.sent();
          throw ERROR_FACTORY2.create("token-subscribe-failed", {
            errorInfo: err_1
          });
        case 6:
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY2.create("token-subscribe-failed", {
              errorInfo: message
            });
          }
          if (!responseData.token) {
            throw ERROR_FACTORY2.create(
              "token-subscribe-no-token"
              /* TOKEN_SUBSCRIBE_NO_TOKEN */
            );
          }
          return [2, responseData.token];
      }
    });
  });
}
function requestUpdateToken(firebaseDependencies, tokenDetails) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, body, updateOptions, responseData, response, err_2, message;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a7.sent();
          body = getBody(tokenDetails.subscriptionOptions);
          updateOptions = {
            method: "PATCH",
            headers,
            body: JSON.stringify(body)
          };
          _a7.label = 2;
        case 2:
          _a7.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig) + "/" + tokenDetails.token, updateOptions)];
        case 3:
          response = _a7.sent();
          return [4, response.json()];
        case 4:
          responseData = _a7.sent();
          return [3, 6];
        case 5:
          err_2 = _a7.sent();
          throw ERROR_FACTORY2.create("token-update-failed", {
            errorInfo: err_2
          });
        case 6:
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY2.create("token-update-failed", {
              errorInfo: message
            });
          }
          if (!responseData.token) {
            throw ERROR_FACTORY2.create(
              "token-update-no-token"
              /* TOKEN_UPDATE_NO_TOKEN */
            );
          }
          return [2, responseData.token];
      }
    });
  });
}
function requestDeleteToken(firebaseDependencies, token) {
  return __awaiter(this, void 0, void 0, function() {
    var headers, unsubscribeOptions, response, responseData, message, err_3;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getHeaders2(firebaseDependencies)];
        case 1:
          headers = _a7.sent();
          unsubscribeOptions = {
            method: "DELETE",
            headers
          };
          _a7.label = 2;
        case 2:
          _a7.trys.push([2, 5, , 6]);
          return [4, fetch(getEndpoint(firebaseDependencies.appConfig) + "/" + token, unsubscribeOptions)];
        case 3:
          response = _a7.sent();
          return [4, response.json()];
        case 4:
          responseData = _a7.sent();
          if (responseData.error) {
            message = responseData.error.message;
            throw ERROR_FACTORY2.create("token-unsubscribe-failed", {
              errorInfo: message
            });
          }
          return [3, 6];
        case 5:
          err_3 = _a7.sent();
          throw ERROR_FACTORY2.create("token-unsubscribe-failed", {
            errorInfo: err_3
          });
        case 6:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getEndpoint(_a7) {
  var projectId = _a7.projectId;
  return ENDPOINT + "/projects/" + projectId + "/registrations";
}
function getHeaders2(_a7) {
  var appConfig = _a7.appConfig, installations = _a7.installations;
  return __awaiter(this, void 0, void 0, function() {
    var authToken;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, installations.getToken()];
        case 1:
          authToken = _b.sent();
          return [2, new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "x-goog-api-key": appConfig.apiKey,
            "x-goog-firebase-installations-auth": "FIS " + authToken
          })];
      }
    });
  });
}
function getBody(_a7) {
  var p256dh = _a7.p256dh, auth = _a7.auth, endpoint = _a7.endpoint, vapidKey = _a7.vapidKey;
  var body = {
    web: {
      endpoint,
      auth,
      p256dh
    }
  };
  if (vapidKey !== DEFAULT_VAPID_KEY) {
    body.web.applicationPubKey = vapidKey;
  }
  return body;
}
var TOKEN_EXPIRATION_MS = 7 * 24 * 60 * 60 * 1e3;
function getToken2(firebaseDependencies, swRegistration, vapidKey) {
  return __awaiter(this, void 0, void 0, function() {
    var pushSubscription, tokenDetails, subscriptionOptions, e_1;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (Notification.permission !== "granted") {
            throw ERROR_FACTORY2.create(
              "permission-blocked"
              /* PERMISSION_BLOCKED */
            );
          }
          return [4, getPushSubscription(swRegistration, vapidKey)];
        case 1:
          pushSubscription = _a7.sent();
          return [4, dbGet(firebaseDependencies)];
        case 2:
          tokenDetails = _a7.sent();
          subscriptionOptions = {
            vapidKey,
            swScope: swRegistration.scope,
            endpoint: pushSubscription.endpoint,
            auth: arrayToBase64(pushSubscription.getKey("auth")),
            p256dh: arrayToBase64(pushSubscription.getKey("p256dh"))
          };
          if (!!tokenDetails) return [3, 3];
          return [2, getNewToken(firebaseDependencies, subscriptionOptions)];
        case 3:
          if (!!isTokenValid(tokenDetails.subscriptionOptions, subscriptionOptions)) return [3, 8];
          _a7.label = 4;
        case 4:
          _a7.trys.push([4, 6, , 7]);
          return [4, requestDeleteToken(firebaseDependencies, tokenDetails.token)];
        case 5:
          _a7.sent();
          return [3, 7];
        case 6:
          e_1 = _a7.sent();
          console.warn(e_1);
          return [3, 7];
        case 7:
          return [2, getNewToken(firebaseDependencies, subscriptionOptions)];
        case 8:
          if (Date.now() >= tokenDetails.createTime + TOKEN_EXPIRATION_MS) {
            return [2, updateToken({
              token: tokenDetails.token,
              createTime: Date.now(),
              subscriptionOptions
            }, firebaseDependencies, swRegistration)];
          } else {
            return [2, tokenDetails.token];
          }
        case 9:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function deleteToken(firebaseDependencies, swRegistration) {
  return __awaiter(this, void 0, void 0, function() {
    var tokenDetails, pushSubscription;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, dbGet(firebaseDependencies)];
        case 1:
          tokenDetails = _a7.sent();
          if (!tokenDetails) return [3, 4];
          return [4, requestDeleteToken(firebaseDependencies, tokenDetails.token)];
        case 2:
          _a7.sent();
          return [4, dbRemove(firebaseDependencies)];
        case 3:
          _a7.sent();
          _a7.label = 4;
        case 4:
          return [4, swRegistration.pushManager.getSubscription()];
        case 5:
          pushSubscription = _a7.sent();
          if (pushSubscription) {
            return [2, pushSubscription.unsubscribe()];
          }
          return [2, true];
      }
    });
  });
}
function updateToken(tokenDetails, firebaseDependencies, swRegistration) {
  return __awaiter(this, void 0, void 0, function() {
    var updatedToken, updatedTokenDetails, e_2;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          _a7.trys.push([0, 3, , 5]);
          return [4, requestUpdateToken(firebaseDependencies, tokenDetails)];
        case 1:
          updatedToken = _a7.sent();
          updatedTokenDetails = __assign(__assign({}, tokenDetails), { token: updatedToken, createTime: Date.now() });
          return [4, dbSet(firebaseDependencies, updatedTokenDetails)];
        case 2:
          _a7.sent();
          return [2, updatedToken];
        case 3:
          e_2 = _a7.sent();
          return [4, deleteToken(firebaseDependencies, swRegistration)];
        case 4:
          _a7.sent();
          throw e_2;
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function getNewToken(firebaseDependencies, subscriptionOptions) {
  return __awaiter(this, void 0, void 0, function() {
    var token, tokenDetails;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, requestGetToken(firebaseDependencies, subscriptionOptions)];
        case 1:
          token = _a7.sent();
          tokenDetails = {
            token,
            createTime: Date.now(),
            subscriptionOptions
          };
          return [4, dbSet(firebaseDependencies, tokenDetails)];
        case 2:
          _a7.sent();
          return [2, tokenDetails.token];
      }
    });
  });
}
function getPushSubscription(swRegistration, vapidKey) {
  return __awaiter(this, void 0, void 0, function() {
    var subscription;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, swRegistration.pushManager.getSubscription()];
        case 1:
          subscription = _a7.sent();
          if (subscription) {
            return [2, subscription];
          }
          return [2, swRegistration.pushManager.subscribe({
            userVisibleOnly: true,
            // Chrome <= 75 doesn't support base64-encoded VAPID key. For backward compatibility, VAPID key
            // submitted to pushManager#subscribe must be of type Uint8Array.
            applicationServerKey: base64ToArray(vapidKey)
          })];
      }
    });
  });
}
function isTokenValid(dbOptions, currentOptions) {
  var isVapidKeyEqual = currentOptions.vapidKey === dbOptions.vapidKey;
  var isEndpointEqual = currentOptions.endpoint === dbOptions.endpoint;
  var isAuthEqual = currentOptions.auth === dbOptions.auth;
  var isP256dhEqual = currentOptions.p256dh === dbOptions.p256dh;
  return isVapidKeyEqual && isEndpointEqual && isAuthEqual && isP256dhEqual;
}
function externalizePayload(internalPayload) {
  var payload = {
    from: internalPayload.from,
    // eslint-disable-next-line camelcase
    collapseKey: internalPayload.collapse_key,
    // eslint-disable-next-line camelcase
    messageId: internalPayload.fcm_message_id
  };
  propagateNotificationPayload(payload, internalPayload);
  propagateDataPayload(payload, internalPayload);
  propagateFcmOptions(payload, internalPayload);
  return payload;
}
function propagateNotificationPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.notification) {
    return;
  }
  payload.notification = {};
  var title = messagePayloadInternal.notification.title;
  if (!!title) {
    payload.notification.title = title;
  }
  var body = messagePayloadInternal.notification.body;
  if (!!body) {
    payload.notification.body = body;
  }
  var image = messagePayloadInternal.notification.image;
  if (!!image) {
    payload.notification.image = image;
  }
}
function propagateDataPayload(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.data) {
    return;
  }
  payload.data = messagePayloadInternal.data;
}
function propagateFcmOptions(payload, messagePayloadInternal) {
  if (!messagePayloadInternal.fcmOptions) {
    return;
  }
  payload.fcmOptions = {};
  var link = messagePayloadInternal.fcmOptions.link;
  if (!!link) {
    payload.fcmOptions.link = link;
  }
  var analyticsLabel = messagePayloadInternal.fcmOptions.analytics_label;
  if (!!analyticsLabel) {
    payload.fcmOptions.analyticsLabel = analyticsLabel;
  }
}
function isConsoleMessage(data) {
  return typeof data === "object" && !!data && CONSOLE_CAMPAIGN_ID in data;
}
function sleep2(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
var SwController = (
  /** @class */
  function() {
    function SwController2(firebaseDependencies) {
      var _this = this;
      this.firebaseDependencies = firebaseDependencies;
      this.isOnBackgroundMessageUsed = null;
      this.vapidKey = null;
      this.bgMessageHandler = null;
      self.addEventListener("push", function(e) {
        e.waitUntil(_this.onPush(e));
      });
      self.addEventListener("pushsubscriptionchange", function(e) {
        e.waitUntil(_this.onSubChange(e));
      });
      self.addEventListener("notificationclick", function(e) {
        e.waitUntil(_this.onNotificationClick(e));
      });
    }
    Object.defineProperty(SwController2.prototype, "app", {
      get: function() {
        return this.firebaseDependencies.app;
      },
      enumerable: false,
      configurable: true
    });
    SwController2.prototype.setBackgroundMessageHandler = function(callback) {
      this.isOnBackgroundMessageUsed = false;
      if (!callback || typeof callback !== "function") {
        throw ERROR_FACTORY2.create(
          "invalid-bg-handler"
          /* INVALID_BG_HANDLER */
        );
      }
      this.bgMessageHandler = callback;
    };
    SwController2.prototype.onBackgroundMessage = function(nextOrObserver) {
      var _this = this;
      this.isOnBackgroundMessageUsed = true;
      this.bgMessageHandler = nextOrObserver;
      return function() {
        _this.bgMessageHandler = null;
      };
    };
    SwController2.prototype.getToken = function() {
      var _a7, _b;
      return __awaiter(this, void 0, void 0, function() {
        var tokenDetails;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              if (!!this.vapidKey) return [3, 2];
              return [4, dbGet(this.firebaseDependencies)];
            case 1:
              tokenDetails = _c.sent();
              this.vapidKey = (_b = (_a7 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a7 === void 0 ? void 0 : _a7.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY;
              _c.label = 2;
            case 2:
              return [2, getToken2(this.firebaseDependencies, self.registration, this.vapidKey)];
          }
        });
      });
    };
    SwController2.prototype.deleteToken = function() {
      return deleteToken(this.firebaseDependencies, self.registration);
    };
    SwController2.prototype.requestPermission = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.usePublicVapidKey = function(vapidKey) {
      if (this.vapidKey !== null) {
        throw ERROR_FACTORY2.create(
          "use-vapid-key-after-get-token"
          /* USE_VAPID_KEY_AFTER_GET_TOKEN */
        );
      }
      if (typeof vapidKey !== "string" || vapidKey.length === 0) {
        throw ERROR_FACTORY2.create(
          "invalid-vapid-key"
          /* INVALID_VAPID_KEY */
        );
      }
      this.vapidKey = vapidKey;
    };
    SwController2.prototype.useServiceWorker = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onMessage = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onTokenRefresh = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-window"
        /* AVAILABLE_IN_WINDOW */
      );
    };
    SwController2.prototype.onPush = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, clientList, isNotificationShown, payload;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              internalPayload = getMessagePayloadInternal(event);
              if (!internalPayload) {
                console.debug(TAG + "failed to get parsed MessagePayload from the PushEvent. Skip handling the push.");
                return [
                  2
                  /*return*/
                ];
              }
              return [4, getClientList()];
            case 1:
              clientList = _a7.sent();
              if (hasVisibleClients(clientList)) {
                return [2, sendMessagePayloadInternalToWindows(clientList, internalPayload)];
              }
              isNotificationShown = false;
              if (!!!internalPayload.notification) return [3, 3];
              return [4, showNotification(wrapInternalPayload(internalPayload))];
            case 2:
              _a7.sent();
              isNotificationShown = true;
              _a7.label = 3;
            case 3:
              if (isNotificationShown === true && this.isOnBackgroundMessageUsed === false) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!!this.bgMessageHandler) {
                payload = externalizePayload(internalPayload);
                if (typeof this.bgMessageHandler === "function") {
                  this.bgMessageHandler(payload);
                } else {
                  this.bgMessageHandler.next(payload);
                }
              }
              return [4, sleep2(BACKGROUND_HANDLE_EXECUTION_TIME_LIMIT_MS)];
            case 4:
              _a7.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SwController2.prototype.onSubChange = function(event) {
      var _a7, _b;
      return __awaiter(this, void 0, void 0, function() {
        var newSubscription, tokenDetails;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              newSubscription = event.newSubscription;
              if (!!newSubscription) return [3, 2];
              return [4, deleteToken(this.firebaseDependencies, self.registration)];
            case 1:
              _c.sent();
              return [
                2
                /*return*/
              ];
            case 2:
              return [4, dbGet(this.firebaseDependencies)];
            case 3:
              tokenDetails = _c.sent();
              return [4, deleteToken(this.firebaseDependencies, self.registration)];
            case 4:
              _c.sent();
              return [4, getToken2(this.firebaseDependencies, self.registration, (_b = (_a7 = tokenDetails === null || tokenDetails === void 0 ? void 0 : tokenDetails.subscriptionOptions) === null || _a7 === void 0 ? void 0 : _a7.vapidKey) !== null && _b !== void 0 ? _b : DEFAULT_VAPID_KEY)];
            case 5:
              _c.sent();
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    SwController2.prototype.onNotificationClick = function(event) {
      var _a7, _b;
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, link, url, originUrl, client;
        return __generator(this, function(_c) {
          switch (_c.label) {
            case 0:
              internalPayload = (_b = (_a7 = event.notification) === null || _a7 === void 0 ? void 0 : _a7.data) === null || _b === void 0 ? void 0 : _b[FCM_MSG];
              if (!internalPayload) {
                return [
                  2
                  /*return*/
                ];
              } else if (event.action) {
                return [
                  2
                  /*return*/
                ];
              }
              event.stopImmediatePropagation();
              event.notification.close();
              link = getLink(internalPayload);
              if (!link) {
                return [
                  2
                  /*return*/
                ];
              }
              url = new URL(link, self.location.href);
              originUrl = new URL(self.location.origin);
              if (url.host !== originUrl.host) {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, getWindowClient(url)];
            case 1:
              client = _c.sent();
              if (!!client) return [3, 4];
              return [4, self.clients.openWindow(link)];
            case 2:
              client = _c.sent();
              return [4, sleep2(FOREGROUND_HANDLE_PREPARATION_TIME_MS)];
            case 3:
              _c.sent();
              return [3, 6];
            case 4:
              return [4, client.focus()];
            case 5:
              client = _c.sent();
              _c.label = 6;
            case 6:
              if (!client) {
                return [
                  2
                  /*return*/
                ];
              }
              internalPayload.messageType = MessageType.NOTIFICATION_CLICKED;
              internalPayload.isFirebaseMessaging = true;
              return [2, client.postMessage(internalPayload)];
          }
        });
      });
    };
    return SwController2;
  }()
);
function wrapInternalPayload(internalPayload) {
  var _a7;
  var wrappedInternalPayload = __assign({}, internalPayload.notification);
  wrappedInternalPayload.data = (_a7 = {}, _a7[FCM_MSG] = internalPayload, _a7);
  return wrappedInternalPayload;
}
function getMessagePayloadInternal(_a7) {
  var data = _a7.data;
  if (!data) {
    return null;
  }
  try {
    return data.json();
  } catch (err) {
    return null;
  }
}
function getWindowClient(url) {
  return __awaiter(this, void 0, void 0, function() {
    var clientList, clientList_1, clientList_1_1, client, clientUrl;
    var e_1, _a7;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          return [4, getClientList()];
        case 1:
          clientList = _b.sent();
          try {
            for (clientList_1 = __values(clientList), clientList_1_1 = clientList_1.next(); !clientList_1_1.done; clientList_1_1 = clientList_1.next()) {
              client = clientList_1_1.value;
              clientUrl = new URL(client.url, self.location.href);
              if (url.host === clientUrl.host) {
                return [2, client];
              }
            }
          } catch (e_1_1) {
            e_1 = { error: e_1_1 };
          } finally {
            try {
              if (clientList_1_1 && !clientList_1_1.done && (_a7 = clientList_1.return)) _a7.call(clientList_1);
            } finally {
              if (e_1) throw e_1.error;
            }
          }
          return [2, null];
      }
    });
  });
}
function hasVisibleClients(clientList) {
  return clientList.some(function(client) {
    return client.visibilityState === "visible" && // Ignore chrome-extension clients as that matches the background pages of extensions, which
    // are always considered visible for some reason.
    !client.url.startsWith("chrome-extension://");
  });
}
function sendMessagePayloadInternalToWindows(clientList, internalPayload) {
  var e_2, _a7;
  internalPayload.isFirebaseMessaging = true;
  internalPayload.messageType = MessageType.PUSH_RECEIVED;
  try {
    for (var clientList_2 = __values(clientList), clientList_2_1 = clientList_2.next(); !clientList_2_1.done; clientList_2_1 = clientList_2.next()) {
      var client = clientList_2_1.value;
      client.postMessage(internalPayload);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (clientList_2_1 && !clientList_2_1.done && (_a7 = clientList_2.return)) _a7.call(clientList_2);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
}
function getClientList() {
  return self.clients.matchAll({
    type: "window",
    includeUncontrolled: true
    // TS doesn't know that "type: 'window'" means it'll return WindowClient[]
  });
}
function showNotification(notificationPayloadInternal) {
  var _a7;
  var actions = notificationPayloadInternal.actions;
  var maxActions = Notification.maxActions;
  if (actions && maxActions && actions.length > maxActions) {
    console.warn("This browser only supports " + maxActions + " actions. The remaining actions will not be displayed.");
  }
  return self.registration.showNotification(
    /* title= */
    (_a7 = notificationPayloadInternal.title) !== null && _a7 !== void 0 ? _a7 : "",
    notificationPayloadInternal
  );
}
function getLink(payload) {
  var _a7, _b, _c;
  var link = (_b = (_a7 = payload.fcmOptions) === null || _a7 === void 0 ? void 0 : _a7.link) !== null && _b !== void 0 ? _b : (_c = payload.notification) === null || _c === void 0 ? void 0 : _c.click_action;
  if (link) {
    return link;
  }
  if (isConsoleMessage(payload.data)) {
    return self.location.origin;
  } else {
    return null;
  }
}
var WindowController = (
  /** @class */
  function() {
    function WindowController2(firebaseDependencies) {
      var _this = this;
      this.firebaseDependencies = firebaseDependencies;
      this.vapidKey = null;
      this.onMessageCallback = null;
      navigator.serviceWorker.addEventListener("message", function(e) {
        return _this.messageEventListener(e);
      });
    }
    Object.defineProperty(WindowController2.prototype, "app", {
      get: function() {
        return this.firebaseDependencies.app;
      },
      enumerable: false,
      configurable: true
    });
    WindowController2.prototype.messageEventListener = function(event) {
      return __awaiter(this, void 0, void 0, function() {
        var internalPayload, dataPayload;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              internalPayload = event.data;
              if (!internalPayload.isFirebaseMessaging) {
                return [
                  2
                  /*return*/
                ];
              }
              if (this.onMessageCallback && internalPayload.messageType === MessageType.PUSH_RECEIVED) {
                if (typeof this.onMessageCallback === "function") {
                  this.onMessageCallback(stripInternalFields(Object.assign({}, internalPayload)));
                } else {
                  this.onMessageCallback.next(Object.assign({}, internalPayload));
                }
              }
              dataPayload = internalPayload.data;
              if (!(isConsoleMessage(dataPayload) && dataPayload[CONSOLE_CAMPAIGN_ANALYTICS_ENABLED] === "1")) return [3, 2];
              return [4, this.logEvent(internalPayload.messageType, dataPayload)];
            case 1:
              _a7.sent();
              _a7.label = 2;
            case 2:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.getVapidKey = function() {
      return this.vapidKey;
    };
    WindowController2.prototype.getSwReg = function() {
      return this.swRegistration;
    };
    WindowController2.prototype.getToken = function(options) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!(Notification.permission === "default")) return [3, 2];
              return [4, Notification.requestPermission()];
            case 1:
              _a7.sent();
              _a7.label = 2;
            case 2:
              if (Notification.permission !== "granted") {
                throw ERROR_FACTORY2.create(
                  "permission-blocked"
                  /* PERMISSION_BLOCKED */
                );
              }
              return [4, this.updateVapidKey(options === null || options === void 0 ? void 0 : options.vapidKey)];
            case 3:
              _a7.sent();
              return [4, this.updateSwReg(options === null || options === void 0 ? void 0 : options.serviceWorkerRegistration)];
            case 4:
              _a7.sent();
              return [2, getToken2(this.firebaseDependencies, this.swRegistration, this.vapidKey)];
          }
        });
      });
    };
    WindowController2.prototype.updateVapidKey = function(vapidKey) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a7) {
          if (!!vapidKey) {
            this.vapidKey = vapidKey;
          } else if (!this.vapidKey) {
            this.vapidKey = DEFAULT_VAPID_KEY;
          }
          return [
            2
            /*return*/
          ];
        });
      });
    };
    WindowController2.prototype.updateSwReg = function(swRegistration) {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!(!swRegistration && !this.swRegistration)) return [3, 2];
              return [4, this.registerDefaultSw()];
            case 1:
              _a7.sent();
              _a7.label = 2;
            case 2:
              if (!swRegistration && !!this.swRegistration) {
                return [
                  2
                  /*return*/
                ];
              }
              if (!(swRegistration instanceof ServiceWorkerRegistration)) {
                throw ERROR_FACTORY2.create(
                  "invalid-sw-registration"
                  /* INVALID_SW_REGISTRATION */
                );
              }
              this.swRegistration = swRegistration;
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.registerDefaultSw = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a7, e_1;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              _b.trys.push([0, 2, , 3]);
              _a7 = this;
              return [4, navigator.serviceWorker.register(DEFAULT_SW_PATH, {
                scope: DEFAULT_SW_SCOPE
              })];
            case 1:
              _a7.swRegistration = _b.sent();
              this.swRegistration.update().catch(function() {
              });
              return [3, 3];
            case 2:
              e_1 = _b.sent();
              throw ERROR_FACTORY2.create("failed-service-worker-registration", {
                browserErrorMessage: e_1.message
              });
            case 3:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    WindowController2.prototype.deleteToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!!this.swRegistration) return [3, 2];
              return [4, this.registerDefaultSw()];
            case 1:
              _a7.sent();
              _a7.label = 2;
            case 2:
              return [2, deleteToken(this.firebaseDependencies, this.swRegistration)];
          }
        });
      });
    };
    WindowController2.prototype.requestPermission = function() {
      return __awaiter(this, void 0, void 0, function() {
        var permissionResult;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (Notification.permission === "granted") {
                return [
                  2
                  /*return*/
                ];
              }
              return [4, Notification.requestPermission()];
            case 1:
              permissionResult = _a7.sent();
              if (permissionResult === "granted") {
                return [
                  2
                  /*return*/
                ];
              } else if (permissionResult === "denied") {
                throw ERROR_FACTORY2.create(
                  "permission-blocked"
                  /* PERMISSION_BLOCKED */
                );
              } else {
                throw ERROR_FACTORY2.create(
                  "permission-default"
                  /* PERMISSION_DEFAULT */
                );
              }
          }
        });
      });
    };
    WindowController2.prototype.usePublicVapidKey = function(vapidKey) {
      if (this.vapidKey !== null) {
        throw ERROR_FACTORY2.create(
          "use-vapid-key-after-get-token"
          /* USE_VAPID_KEY_AFTER_GET_TOKEN */
        );
      }
      if (typeof vapidKey !== "string" || vapidKey.length === 0) {
        throw ERROR_FACTORY2.create(
          "invalid-vapid-key"
          /* INVALID_VAPID_KEY */
        );
      }
      this.vapidKey = vapidKey;
    };
    WindowController2.prototype.useServiceWorker = function(swRegistration) {
      if (!(swRegistration instanceof ServiceWorkerRegistration)) {
        throw ERROR_FACTORY2.create(
          "invalid-sw-registration"
          /* INVALID_SW_REGISTRATION */
        );
      }
      if (this.swRegistration) {
        throw ERROR_FACTORY2.create(
          "use-sw-after-get-token"
          /* USE_SW_AFTER_GET_TOKEN */
        );
      }
      this.swRegistration = swRegistration;
    };
    WindowController2.prototype.onMessage = function(nextOrObserver) {
      var _this = this;
      this.onMessageCallback = nextOrObserver;
      return function() {
        _this.onMessageCallback = null;
      };
    };
    WindowController2.prototype.setBackgroundMessageHandler = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-sw"
        /* AVAILABLE_IN_SW */
      );
    };
    WindowController2.prototype.onBackgroundMessage = function() {
      throw ERROR_FACTORY2.create(
        "only-available-in-sw"
        /* AVAILABLE_IN_SW */
      );
    };
    WindowController2.prototype.onTokenRefresh = function() {
      return function() {
      };
    };
    WindowController2.prototype.logEvent = function(messageType, data) {
      return __awaiter(this, void 0, void 0, function() {
        var eventType, analytics;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              eventType = getEventType(messageType);
              return [4, this.firebaseDependencies.analyticsProvider.get()];
            case 1:
              analytics = _a7.sent();
              analytics.logEvent(eventType, {
                /* eslint-disable camelcase */
                message_id: data[CONSOLE_CAMPAIGN_ID],
                message_name: data[CONSOLE_CAMPAIGN_NAME],
                message_time: data[CONSOLE_CAMPAIGN_TIME],
                message_device_time: Math.floor(Date.now() / 1e3)
                /* eslint-enable camelcase */
              });
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return WindowController2;
  }()
);
function getEventType(messageType) {
  switch (messageType) {
    case MessageType.NOTIFICATION_CLICKED:
      return "notification_open";
    case MessageType.PUSH_RECEIVED:
      return "notification_foreground";
    default:
      throw new Error();
  }
}
function stripInternalFields(internalPayload) {
  delete internalPayload.messageType;
  delete internalPayload.isFirebaseMessaging;
  return internalPayload;
}
function extractAppConfig2(app) {
  var e_1, _a7;
  if (!app || !app.options) {
    throw getMissingValueError2("App Configuration Object");
  }
  if (!app.name) {
    throw getMissingValueError2("App Name");
  }
  var configKeys = [
    "projectId",
    "apiKey",
    "appId",
    "messagingSenderId"
  ];
  var options = app.options;
  try {
    for (var configKeys_1 = __values(configKeys), configKeys_1_1 = configKeys_1.next(); !configKeys_1_1.done; configKeys_1_1 = configKeys_1.next()) {
      var keyName = configKeys_1_1.value;
      if (!options[keyName]) {
        throw getMissingValueError2(keyName);
      }
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (configKeys_1_1 && !configKeys_1_1.done && (_a7 = configKeys_1.return)) _a7.call(configKeys_1);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  return {
    appName: app.name,
    projectId: options.projectId,
    apiKey: options.apiKey,
    appId: options.appId,
    senderId: options.messagingSenderId
  };
}
function getMissingValueError2(valueName) {
  return ERROR_FACTORY2.create("missing-app-config-values", {
    valueName
  });
}
var MESSAGING_NAME = "messaging";
function factoryMethod(container) {
  var app = container.getProvider("app").getImmediate();
  var appConfig = extractAppConfig2(app);
  var installations = container.getProvider("installations").getImmediate();
  var analyticsProvider = container.getProvider("analytics-internal");
  var firebaseDependencies = {
    app,
    appConfig,
    installations,
    analyticsProvider
  };
  if (!isSupported()) {
    throw ERROR_FACTORY2.create(
      "unsupported-browser"
      /* UNSUPPORTED_BROWSER */
    );
  }
  if (self && "ServiceWorkerGlobalScope" in self) {
    return new SwController(firebaseDependencies);
  } else {
    return new WindowController(firebaseDependencies);
  }
}
var NAMESPACE_EXPORTS = {
  isSupported
};
index_esm_default.INTERNAL.registerComponent(new Component(
  MESSAGING_NAME,
  factoryMethod,
  "PUBLIC"
  /* PUBLIC */
).setServiceProps(NAMESPACE_EXPORTS));
function isSupported() {
  if (self && "ServiceWorkerGlobalScope" in self) {
    return isSWControllerSupported();
  } else {
    return isWindowControllerSupported();
  }
}
function isWindowControllerSupported() {
  return "indexedDB" in window && indexedDB !== null && navigator.cookieEnabled && "serviceWorker" in navigator && "PushManager" in window && "Notification" in window && "fetch" in window && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}
function isSWControllerSupported() {
  return "indexedDB" in self && indexedDB !== null && "PushManager" in self && "Notification" in self && ServiceWorkerRegistration.prototype.hasOwnProperty("showNotification") && PushSubscription.prototype.hasOwnProperty("getKey");
}

// node_modules/@firebase/storage/dist/index.browser.esm.js
var DEFAULT_HOST = "firebasestorage.googleapis.com";
var CONFIG_STORAGE_BUCKET_KEY = "storageBucket";
var DEFAULT_MAX_OPERATION_RETRY_TIME = 2 * 60 * 1e3;
var DEFAULT_MAX_UPLOAD_RETRY_TIME = 10 * 60 * 1e3;
var FirebaseStorageError = (
  /** @class */
  function(_super) {
    __extends(FirebaseStorageError2, _super);
    function FirebaseStorageError2(code, message) {
      var _this = _super.call(this, prependCode(code), "Firebase Storage: " + message + " (" + prependCode(code) + ")") || this;
      _this.customData = { serverResponse: null };
      _this._baseMessage = _this.message;
      Object.setPrototypeOf(_this, FirebaseStorageError2.prototype);
      return _this;
    }
    FirebaseStorageError2.prototype._codeEquals = function(code) {
      return prependCode(code) === this.code;
    };
    Object.defineProperty(FirebaseStorageError2.prototype, "serverResponse", {
      /**
       * Optional response message that was added by the server.
       */
      get: function() {
        return this.customData.serverResponse;
      },
      set: function(serverResponse) {
        this.customData.serverResponse = serverResponse;
        if (this.customData.serverResponse) {
          this.message = this._baseMessage + "\n" + this.customData.serverResponse;
        } else {
          this.message = this._baseMessage;
        }
      },
      enumerable: false,
      configurable: true
    });
    return FirebaseStorageError2;
  }(FirebaseError)
);
function prependCode(code) {
  return "storage/" + code;
}
function unknown() {
  var message = "An unknown error occurred, please check the error payload for server response.";
  return new FirebaseStorageError("unknown", message);
}
function objectNotFound(path) {
  return new FirebaseStorageError("object-not-found", "Object '" + path + "' does not exist.");
}
function quotaExceeded(bucket) {
  return new FirebaseStorageError("quota-exceeded", "Quota for bucket '" + bucket + "' exceeded, please view quota on https://firebase.google.com/pricing/.");
}
function unauthenticated() {
  var message = "User is not authenticated, please authenticate using Firebase Authentication and try again.";
  return new FirebaseStorageError("unauthenticated", message);
}
function unauthorizedApp() {
  return new FirebaseStorageError("unauthorized-app", "This app does not have permission to access Firebase Storage on this project.");
}
function unauthorized(path) {
  return new FirebaseStorageError("unauthorized", "User does not have permission to access '" + path + "'.");
}
function retryLimitExceeded() {
  return new FirebaseStorageError("retry-limit-exceeded", "Max retry time for operation exceeded, please try again.");
}
function canceled() {
  return new FirebaseStorageError("canceled", "User canceled the upload/download.");
}
function invalidUrl(url) {
  return new FirebaseStorageError("invalid-url", "Invalid URL '" + url + "'.");
}
function invalidDefaultBucket(bucket) {
  return new FirebaseStorageError("invalid-default-bucket", "Invalid default bucket '" + bucket + "'.");
}
function noDefaultBucket() {
  return new FirebaseStorageError("no-default-bucket", "No default bucket found. Did you set the '" + CONFIG_STORAGE_BUCKET_KEY + "' property when initializing the app?");
}
function cannotSliceBlob() {
  return new FirebaseStorageError("cannot-slice-blob", "Cannot slice blob for upload. Please retry the upload.");
}
function serverFileWrongSize() {
  return new FirebaseStorageError("server-file-wrong-size", "Server recorded incorrect upload file size, please retry the upload.");
}
function noDownloadURL() {
  return new FirebaseStorageError("no-download-url", "The given file does not have any download URLs.");
}
function invalidArgument(message) {
  return new FirebaseStorageError("invalid-argument", message);
}
function appDeleted() {
  return new FirebaseStorageError("app-deleted", "The Firebase app was deleted.");
}
function invalidRootOperation(name10) {
  return new FirebaseStorageError("invalid-root-operation", "The operation '" + name10 + "' cannot be performed on a root reference, create a non-root reference using child, such as .child('file.png').");
}
function invalidFormat(format, message) {
  return new FirebaseStorageError("invalid-format", "String does not match format '" + format + "': " + message);
}
function internalError(message) {
  throw new FirebaseStorageError("internal-error", "Internal error: " + message);
}
function decodeBase64(encoded) {
  return atob(encoded);
}
var StringFormat = {
  /**
   * Indicates the string should be interpreted "raw", that is, as normal text.
   * The string will be interpreted as UTF-16, then uploaded as a UTF-8 byte
   * sequence.
   * Example: The string 'Hello! \\ud83d\\ude0a' becomes the byte sequence
   * 48 65 6c 6c 6f 21 20 f0 9f 98 8a
   */
  RAW: "raw",
  /**
   * Indicates the string should be interpreted as base64-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO++E6t7/rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64: "base64",
  /**
   * Indicates the string should be interpreted as base64url-encoded data.
   * Padding characters (trailing '='s) are optional.
   * Example: The string 'rWmO--E6t7_rlw==' becomes the byte sequence
   * ad 69 8e fb e1 3a b7 bf eb 97
   */
  BASE64URL: "base64url",
  /**
   * Indicates the string is a data URL, such as one obtained from
   * canvas.toDataURL().
   * Example: the string 'data:application/octet-stream;base64,aaaa'
   * becomes the byte sequence
   * 69 a6 9a
   * (the content-type "application/octet-stream" is also applied, but can
   * be overridden in the metadata object).
   */
  DATA_URL: "data_url"
};
var StringData = (
  /** @class */
  /* @__PURE__ */ function() {
    function StringData2(data, contentType) {
      this.data = data;
      this.contentType = contentType || null;
    }
    return StringData2;
  }()
);
function dataFromString(format, stringData) {
  switch (format) {
    case StringFormat.RAW:
      return new StringData(utf8Bytes_(stringData));
    case StringFormat.BASE64:
    case StringFormat.BASE64URL:
      return new StringData(base64Bytes_(format, stringData));
    case StringFormat.DATA_URL:
      return new StringData(dataURLBytes_(stringData), dataURLContentType_(stringData));
  }
  throw unknown();
}
function utf8Bytes_(value) {
  var b = [];
  for (var i = 0; i < value.length; i++) {
    var c = value.charCodeAt(i);
    if (c <= 127) {
      b.push(c);
    } else {
      if (c <= 2047) {
        b.push(192 | c >> 6, 128 | c & 63);
      } else {
        if ((c & 64512) === 55296) {
          var valid = i < value.length - 1 && (value.charCodeAt(i + 1) & 64512) === 56320;
          if (!valid) {
            b.push(239, 191, 189);
          } else {
            var hi = c;
            var lo = value.charCodeAt(++i);
            c = 65536 | (hi & 1023) << 10 | lo & 1023;
            b.push(240 | c >> 18, 128 | c >> 12 & 63, 128 | c >> 6 & 63, 128 | c & 63);
          }
        } else {
          if ((c & 64512) === 56320) {
            b.push(239, 191, 189);
          } else {
            b.push(224 | c >> 12, 128 | c >> 6 & 63, 128 | c & 63);
          }
        }
      }
    }
  }
  return new Uint8Array(b);
}
function percentEncodedBytes_(value) {
  var decoded;
  try {
    decoded = decodeURIComponent(value);
  } catch (e) {
    throw invalidFormat(StringFormat.DATA_URL, "Malformed data URL.");
  }
  return utf8Bytes_(decoded);
}
function base64Bytes_(format, value) {
  switch (format) {
    case StringFormat.BASE64: {
      var hasMinus = value.indexOf("-") !== -1;
      var hasUnder = value.indexOf("_") !== -1;
      if (hasMinus || hasUnder) {
        var invalidChar = hasMinus ? "-" : "_";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64url encoded?");
      }
      break;
    }
    case StringFormat.BASE64URL: {
      var hasPlus = value.indexOf("+") !== -1;
      var hasSlash = value.indexOf("/") !== -1;
      if (hasPlus || hasSlash) {
        var invalidChar = hasPlus ? "+" : "/";
        throw invalidFormat(format, "Invalid character '" + invalidChar + "' found: is it base64 encoded?");
      }
      value = value.replace(/-/g, "+").replace(/_/g, "/");
      break;
    }
  }
  var bytes;
  try {
    bytes = decodeBase64(value);
  } catch (e) {
    throw invalidFormat(format, "Invalid character found");
  }
  var array = new Uint8Array(bytes.length);
  for (var i = 0; i < bytes.length; i++) {
    array[i] = bytes.charCodeAt(i);
  }
  return array;
}
var DataURLParts = (
  /** @class */
  /* @__PURE__ */ function() {
    function DataURLParts2(dataURL) {
      this.base64 = false;
      this.contentType = null;
      var matches = dataURL.match(/^data:([^,]+)?,/);
      if (matches === null) {
        throw invalidFormat(StringFormat.DATA_URL, "Must be formatted 'data:[<mediatype>][;base64],<data>");
      }
      var middle = matches[1] || null;
      if (middle != null) {
        this.base64 = endsWith(middle, ";base64");
        this.contentType = this.base64 ? middle.substring(0, middle.length - ";base64".length) : middle;
      }
      this.rest = dataURL.substring(dataURL.indexOf(",") + 1);
    }
    return DataURLParts2;
  }()
);
function dataURLBytes_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  if (parts.base64) {
    return base64Bytes_(StringFormat.BASE64, parts.rest);
  } else {
    return percentEncodedBytes_(parts.rest);
  }
}
function dataURLContentType_(dataUrl) {
  var parts = new DataURLParts(dataUrl);
  return parts.contentType;
}
function endsWith(s, end) {
  var longEnough = s.length >= end.length;
  if (!longEnough) {
    return false;
  }
  return s.substring(s.length - end.length) === end;
}
var TaskEvent = {
  /**
   * For this event,
   * <ul>
   *   <li>The `next` function is triggered on progress updates and when the
   *       task is paused/resumed with an `UploadTaskSnapshot` as the first
   *       argument.</li>
   *   <li>The `error` function is triggered if the upload is canceled or fails
   *       for another reason.</li>
   *   <li>The `complete` function is triggered if the upload completes
   *       successfully.</li>
   * </ul>
   */
  STATE_CHANGED: "state_changed"
};
var TaskState = {
  /** The task is currently transferring data. */
  RUNNING: "running",
  /** The task was paused by the user. */
  PAUSED: "paused",
  /** The task completed successfully. */
  SUCCESS: "success",
  /** The task was canceled. */
  CANCELED: "canceled",
  /** The task failed with an error. */
  ERROR: "error"
};
function taskStateFromInternalTaskState(state) {
  switch (state) {
    case "running":
    case "pausing":
    case "canceling":
      return TaskState.RUNNING;
    case "paused":
      return TaskState.PAUSED;
    case "success":
      return TaskState.SUCCESS;
    case "canceled":
      return TaskState.CANCELED;
    case "error":
      return TaskState.ERROR;
    default:
      return TaskState.ERROR;
  }
}
var ErrorCode;
(function(ErrorCode2) {
  ErrorCode2[ErrorCode2["NO_ERROR"] = 0] = "NO_ERROR";
  ErrorCode2[ErrorCode2["NETWORK_ERROR"] = 1] = "NETWORK_ERROR";
  ErrorCode2[ErrorCode2["ABORT"] = 2] = "ABORT";
})(ErrorCode || (ErrorCode = {}));
var XhrConnection = (
  /** @class */
  function() {
    function XhrConnection2() {
      var _this = this;
      this.sent_ = false;
      this.xhr_ = new XMLHttpRequest();
      this.errorCode_ = ErrorCode.NO_ERROR;
      this.sendPromise_ = new Promise(function(resolve) {
        _this.xhr_.addEventListener("abort", function() {
          _this.errorCode_ = ErrorCode.ABORT;
          resolve();
        });
        _this.xhr_.addEventListener("error", function() {
          _this.errorCode_ = ErrorCode.NETWORK_ERROR;
          resolve();
        });
        _this.xhr_.addEventListener("load", function() {
          resolve();
        });
      });
    }
    XhrConnection2.prototype.send = function(url, method, body, headers) {
      if (this.sent_) {
        throw internalError("cannot .send() more than once");
      }
      this.sent_ = true;
      this.xhr_.open(method, url, true);
      if (headers !== void 0) {
        for (var key in headers) {
          if (headers.hasOwnProperty(key)) {
            this.xhr_.setRequestHeader(key, headers[key].toString());
          }
        }
      }
      if (body !== void 0) {
        this.xhr_.send(body);
      } else {
        this.xhr_.send();
      }
      return this.sendPromise_;
    };
    XhrConnection2.prototype.getErrorCode = function() {
      if (!this.sent_) {
        throw internalError("cannot .getErrorCode() before sending");
      }
      return this.errorCode_;
    };
    XhrConnection2.prototype.getStatus = function() {
      if (!this.sent_) {
        throw internalError("cannot .getStatus() before sending");
      }
      try {
        return this.xhr_.status;
      } catch (e) {
        return -1;
      }
    };
    XhrConnection2.prototype.getResponseText = function() {
      if (!this.sent_) {
        throw internalError("cannot .getResponseText() before sending");
      }
      return this.xhr_.responseText;
    };
    XhrConnection2.prototype.abort = function() {
      this.xhr_.abort();
    };
    XhrConnection2.prototype.getResponseHeader = function(header) {
      return this.xhr_.getResponseHeader(header);
    };
    XhrConnection2.prototype.addUploadProgressListener = function(listener) {
      if (this.xhr_.upload != null) {
        this.xhr_.upload.addEventListener("progress", listener);
      }
    };
    XhrConnection2.prototype.removeUploadProgressListener = function(listener) {
      if (this.xhr_.upload != null) {
        this.xhr_.upload.removeEventListener("progress", listener);
      }
    };
    return XhrConnection2;
  }()
);
function newConnection() {
  return new XhrConnection();
}
var ConnectionPool = (
  /** @class */
  function() {
    function ConnectionPool2() {
    }
    ConnectionPool2.prototype.createConnection = function() {
      return newConnection();
    };
    return ConnectionPool2;
  }()
);
var Location = (
  /** @class */
  function() {
    function Location2(bucket, path) {
      this.bucket = bucket;
      this.path_ = path;
    }
    Object.defineProperty(Location2.prototype, "path", {
      get: function() {
        return this.path_;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Location2.prototype, "isRoot", {
      get: function() {
        return this.path.length === 0;
      },
      enumerable: false,
      configurable: true
    });
    Location2.prototype.fullServerUrl = function() {
      var encode2 = encodeURIComponent;
      return "/b/" + encode2(this.bucket) + "/o/" + encode2(this.path);
    };
    Location2.prototype.bucketOnlyServerUrl = function() {
      var encode2 = encodeURIComponent;
      return "/b/" + encode2(this.bucket) + "/o";
    };
    Location2.makeFromBucketSpec = function(bucketString, host) {
      var bucketLocation;
      try {
        bucketLocation = Location2.makeFromUrl(bucketString, host);
      } catch (e) {
        return new Location2(bucketString, "");
      }
      if (bucketLocation.path === "") {
        return bucketLocation;
      } else {
        throw invalidDefaultBucket(bucketString);
      }
    };
    Location2.makeFromUrl = function(url, host) {
      var location2 = null;
      var bucketDomain = "([A-Za-z0-9.\\-_]+)";
      function gsModify(loc) {
        if (loc.path.charAt(loc.path.length - 1) === "/") {
          loc.path_ = loc.path_.slice(0, -1);
        }
      }
      var gsPath = "(/(.*))?$";
      var gsRegex = new RegExp("^gs://" + bucketDomain + gsPath, "i");
      var gsIndices = { bucket: 1, path: 3 };
      function httpModify(loc) {
        loc.path_ = decodeURIComponent(loc.path);
      }
      var version10 = "v[A-Za-z0-9_]+";
      var firebaseStorageHost = host.replace(/[.]/g, "\\.");
      var firebaseStoragePath = "(/([^?#]*).*)?$";
      var firebaseStorageRegExp = new RegExp("^https?://" + firebaseStorageHost + "/" + version10 + "/b/" + bucketDomain + "/o" + firebaseStoragePath, "i");
      var firebaseStorageIndices = { bucket: 1, path: 3 };
      var cloudStorageHost = host === DEFAULT_HOST ? "(?:storage.googleapis.com|storage.cloud.google.com)" : host;
      var cloudStoragePath = "([^?#]*)";
      var cloudStorageRegExp = new RegExp("^https?://" + cloudStorageHost + "/" + bucketDomain + "/" + cloudStoragePath, "i");
      var cloudStorageIndices = { bucket: 1, path: 2 };
      var groups = [
        { regex: gsRegex, indices: gsIndices, postModify: gsModify },
        {
          regex: firebaseStorageRegExp,
          indices: firebaseStorageIndices,
          postModify: httpModify
        },
        {
          regex: cloudStorageRegExp,
          indices: cloudStorageIndices,
          postModify: httpModify
        }
      ];
      for (var i = 0; i < groups.length; i++) {
        var group = groups[i];
        var captures = group.regex.exec(url);
        if (captures) {
          var bucketValue = captures[group.indices.bucket];
          var pathValue = captures[group.indices.path];
          if (!pathValue) {
            pathValue = "";
          }
          location2 = new Location2(bucketValue, pathValue);
          group.postModify(location2);
          break;
        }
      }
      if (location2 == null) {
        throw invalidUrl(url);
      }
      return location2;
    };
    return Location2;
  }()
);
var FailRequest = (
  /** @class */
  function() {
    function FailRequest2(error2) {
      this.promise_ = Promise.reject(error2);
    }
    FailRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    FailRequest2.prototype.cancel = function(_appDelete) {
    };
    return FailRequest2;
  }()
);
function start(f, callback, timeout) {
  var waitSeconds = 1;
  var timeoutId = null;
  var hitTimeout = false;
  var cancelState = 0;
  function canceled2() {
    return cancelState === 2;
  }
  var triggeredCallback = false;
  function triggerCallback() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    if (!triggeredCallback) {
      triggeredCallback = true;
      callback.apply(null, args);
    }
  }
  function callWithDelay(millis) {
    timeoutId = setTimeout(function() {
      timeoutId = null;
      f(handler, canceled2());
    }, millis);
  }
  function handler(success) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
      args[_i - 1] = arguments[_i];
    }
    if (triggeredCallback) {
      return;
    }
    if (success) {
      triggerCallback.call.apply(triggerCallback, __spreadArray([null, success], args));
      return;
    }
    var mustStop = canceled2() || hitTimeout;
    if (mustStop) {
      triggerCallback.call.apply(triggerCallback, __spreadArray([null, success], args));
      return;
    }
    if (waitSeconds < 64) {
      waitSeconds *= 2;
    }
    var waitMillis;
    if (cancelState === 1) {
      cancelState = 2;
      waitMillis = 0;
    } else {
      waitMillis = (waitSeconds + Math.random()) * 1e3;
    }
    callWithDelay(waitMillis);
  }
  var stopped = false;
  function stop2(wasTimeout) {
    if (stopped) {
      return;
    }
    stopped = true;
    if (triggeredCallback) {
      return;
    }
    if (timeoutId !== null) {
      if (!wasTimeout) {
        cancelState = 2;
      }
      clearTimeout(timeoutId);
      callWithDelay(0);
    } else {
      if (!wasTimeout) {
        cancelState = 1;
      }
    }
  }
  callWithDelay(0);
  setTimeout(function() {
    hitTimeout = true;
    stop2(true);
  }, timeout);
  return stop2;
}
function stop(id) {
  id(false);
}
function isJustDef(p) {
  return p !== void 0;
}
function isFunction(p) {
  return typeof p === "function";
}
function isNonArrayObject(p) {
  return typeof p === "object" && !Array.isArray(p);
}
function isString(p) {
  return typeof p === "string" || p instanceof String;
}
function isNativeBlob(p) {
  return isNativeBlobDefined() && p instanceof Blob;
}
function isNativeBlobDefined() {
  return typeof Blob !== "undefined";
}
function validateNumber(argument, minValue, maxValue, value) {
  if (value < minValue) {
    throw invalidArgument("Invalid value for '" + argument + "'. Expected " + minValue + " or greater.");
  }
  if (value > maxValue) {
    throw invalidArgument("Invalid value for '" + argument + "'. Expected " + maxValue + " or less.");
  }
}
function makeUrl(urlPart, host) {
  var protocolMatch = host.match(/^(\w+):\/\/.+/);
  var protocol = protocolMatch === null || protocolMatch === void 0 ? void 0 : protocolMatch[1];
  var origin = host;
  if (protocol == null) {
    origin = "https://" + host;
  }
  return origin + "/v0" + urlPart;
}
function makeQueryString(params) {
  var encode2 = encodeURIComponent;
  var queryPart = "?";
  for (var key in params) {
    if (params.hasOwnProperty(key)) {
      var nextPart = encode2(key) + "=" + encode2(params[key]);
      queryPart = queryPart + nextPart + "&";
    }
  }
  queryPart = queryPart.slice(0, -1);
  return queryPart;
}
var NetworkRequest = (
  /** @class */
  function() {
    function NetworkRequest2(url, method, headers, body, successCodes, additionalRetryCodes, callback, errorCallback, timeout, progressCallback, pool) {
      var _this = this;
      this.pendingConnection_ = null;
      this.backoffId_ = null;
      this.canceled_ = false;
      this.appDelete_ = false;
      this.url_ = url;
      this.method_ = method;
      this.headers_ = headers;
      this.body_ = body;
      this.successCodes_ = successCodes.slice();
      this.additionalRetryCodes_ = additionalRetryCodes.slice();
      this.callback_ = callback;
      this.errorCallback_ = errorCallback;
      this.progressCallback_ = progressCallback;
      this.timeout_ = timeout;
      this.pool_ = pool;
      this.promise_ = new Promise(function(resolve, reject) {
        _this.resolve_ = resolve;
        _this.reject_ = reject;
        _this.start_();
      });
    }
    NetworkRequest2.prototype.start_ = function() {
      var self2 = this;
      function doTheRequest(backoffCallback, canceled2) {
        if (canceled2) {
          backoffCallback(false, new RequestEndStatus(false, null, true));
          return;
        }
        var connection = self2.pool_.createConnection();
        self2.pendingConnection_ = connection;
        function progressListener(progressEvent) {
          var loaded = progressEvent.loaded;
          var total = progressEvent.lengthComputable ? progressEvent.total : -1;
          if (self2.progressCallback_ !== null) {
            self2.progressCallback_(loaded, total);
          }
        }
        if (self2.progressCallback_ !== null) {
          connection.addUploadProgressListener(progressListener);
        }
        connection.send(self2.url_, self2.method_, self2.body_, self2.headers_).then(function() {
          if (self2.progressCallback_ !== null) {
            connection.removeUploadProgressListener(progressListener);
          }
          self2.pendingConnection_ = null;
          var hitServer = connection.getErrorCode() === ErrorCode.NO_ERROR;
          var status = connection.getStatus();
          if (!hitServer || self2.isRetryStatusCode_(status)) {
            var wasCanceled = connection.getErrorCode() === ErrorCode.ABORT;
            backoffCallback(false, new RequestEndStatus(false, null, wasCanceled));
            return;
          }
          var successCode = self2.successCodes_.indexOf(status) !== -1;
          backoffCallback(true, new RequestEndStatus(successCode, connection));
        });
      }
      function backoffDone(requestWentThrough, status) {
        var resolve = self2.resolve_;
        var reject = self2.reject_;
        var connection = status.connection;
        if (status.wasSuccessCode) {
          try {
            var result = self2.callback_(connection, connection.getResponseText());
            if (isJustDef(result)) {
              resolve(result);
            } else {
              resolve();
            }
          } catch (e) {
            reject(e);
          }
        } else {
          if (connection !== null) {
            var err = unknown();
            err.serverResponse = connection.getResponseText();
            if (self2.errorCallback_) {
              reject(self2.errorCallback_(connection, err));
            } else {
              reject(err);
            }
          } else {
            if (status.canceled) {
              var err = self2.appDelete_ ? appDeleted() : canceled();
              reject(err);
            } else {
              var err = retryLimitExceeded();
              reject(err);
            }
          }
        }
      }
      if (this.canceled_) {
        backoffDone(false, new RequestEndStatus(false, null, true));
      } else {
        this.backoffId_ = start(doTheRequest, backoffDone, this.timeout_);
      }
    };
    NetworkRequest2.prototype.getPromise = function() {
      return this.promise_;
    };
    NetworkRequest2.prototype.cancel = function(appDelete) {
      this.canceled_ = true;
      this.appDelete_ = appDelete || false;
      if (this.backoffId_ !== null) {
        stop(this.backoffId_);
      }
      if (this.pendingConnection_ !== null) {
        this.pendingConnection_.abort();
      }
    };
    NetworkRequest2.prototype.isRetryStatusCode_ = function(status) {
      var isFiveHundredCode = status >= 500 && status < 600;
      var extraRetryCodes = [
        // Request Timeout: web server didn't receive full request in time.
        408,
        // Too Many Requests: you're getting rate-limited, basically.
        429
      ];
      var isExtraRetryCode = extraRetryCodes.indexOf(status) !== -1;
      var isRequestSpecificRetryCode = this.additionalRetryCodes_.indexOf(status) !== -1;
      return isFiveHundredCode || isExtraRetryCode || isRequestSpecificRetryCode;
    };
    return NetworkRequest2;
  }()
);
var RequestEndStatus = (
  /** @class */
  /* @__PURE__ */ function() {
    function RequestEndStatus2(wasSuccessCode, connection, canceled2) {
      this.wasSuccessCode = wasSuccessCode;
      this.connection = connection;
      this.canceled = !!canceled2;
    }
    return RequestEndStatus2;
  }()
);
function addAuthHeader_(headers, authToken) {
  if (authToken !== null && authToken.length > 0) {
    headers["Authorization"] = "Firebase " + authToken;
  }
}
function addVersionHeader_(headers, firebaseVersion) {
  headers["X-Firebase-Storage-Version"] = "webjs/" + (firebaseVersion !== null && firebaseVersion !== void 0 ? firebaseVersion : "AppManager");
}
function addGmpidHeader_(headers, appId) {
  if (appId) {
    headers["X-Firebase-GMPID"] = appId;
  }
}
function addAppCheckHeader_(headers, appCheckToken) {
  if (appCheckToken !== null) {
    headers["X-Firebase-AppCheck"] = appCheckToken;
  }
}
function makeRequest(requestInfo, appId, authToken, appCheckToken, pool, firebaseVersion) {
  var queryPart = makeQueryString(requestInfo.urlParams);
  var url = requestInfo.url + queryPart;
  var headers = Object.assign({}, requestInfo.headers);
  addGmpidHeader_(headers, appId);
  addAuthHeader_(headers, authToken);
  addVersionHeader_(headers, firebaseVersion);
  addAppCheckHeader_(headers, appCheckToken);
  return new NetworkRequest(url, requestInfo.method, headers, requestInfo.body, requestInfo.successCodes, requestInfo.additionalRetryCodes, requestInfo.handler, requestInfo.errorHandler, requestInfo.timeout, requestInfo.progressCallback, pool);
}
function getBlobBuilder() {
  if (typeof BlobBuilder !== "undefined") {
    return BlobBuilder;
  } else if (typeof WebKitBlobBuilder !== "undefined") {
    return WebKitBlobBuilder;
  } else {
    return void 0;
  }
}
function getBlob() {
  var args = [];
  for (var _i = 0; _i < arguments.length; _i++) {
    args[_i] = arguments[_i];
  }
  var BlobBuilder2 = getBlobBuilder();
  if (BlobBuilder2 !== void 0) {
    var bb = new BlobBuilder2();
    for (var i = 0; i < args.length; i++) {
      bb.append(args[i]);
    }
    return bb.getBlob();
  } else {
    if (isNativeBlobDefined()) {
      return new Blob(args);
    } else {
      throw new FirebaseStorageError("unsupported-environment", "This browser doesn't seem to support creating Blobs");
    }
  }
}
function sliceBlob(blob, start2, end) {
  if (blob.webkitSlice) {
    return blob.webkitSlice(start2, end);
  } else if (blob.mozSlice) {
    return blob.mozSlice(start2, end);
  } else if (blob.slice) {
    return blob.slice(start2, end);
  }
  return null;
}
var FbsBlob = (
  /** @class */
  function() {
    function FbsBlob2(data, elideCopy) {
      var size = 0;
      var blobType = "";
      if (isNativeBlob(data)) {
        this.data_ = data;
        size = data.size;
        blobType = data.type;
      } else if (data instanceof ArrayBuffer) {
        if (elideCopy) {
          this.data_ = new Uint8Array(data);
        } else {
          this.data_ = new Uint8Array(data.byteLength);
          this.data_.set(new Uint8Array(data));
        }
        size = this.data_.length;
      } else if (data instanceof Uint8Array) {
        if (elideCopy) {
          this.data_ = data;
        } else {
          this.data_ = new Uint8Array(data.length);
          this.data_.set(data);
        }
        size = data.length;
      }
      this.size_ = size;
      this.type_ = blobType;
    }
    FbsBlob2.prototype.size = function() {
      return this.size_;
    };
    FbsBlob2.prototype.type = function() {
      return this.type_;
    };
    FbsBlob2.prototype.slice = function(startByte, endByte) {
      if (isNativeBlob(this.data_)) {
        var realBlob = this.data_;
        var sliced = sliceBlob(realBlob, startByte, endByte);
        if (sliced === null) {
          return null;
        }
        return new FbsBlob2(sliced);
      } else {
        var slice = new Uint8Array(this.data_.buffer, startByte, endByte - startByte);
        return new FbsBlob2(slice, true);
      }
    };
    FbsBlob2.getBlob = function() {
      var args = [];
      for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
      }
      if (isNativeBlobDefined()) {
        var blobby = args.map(function(val) {
          if (val instanceof FbsBlob2) {
            return val.data_;
          } else {
            return val;
          }
        });
        return new FbsBlob2(getBlob.apply(null, blobby));
      } else {
        var uint8Arrays = args.map(function(val) {
          if (isString(val)) {
            return dataFromString(StringFormat.RAW, val).data;
          } else {
            return val.data_;
          }
        });
        var finalLength_1 = 0;
        uint8Arrays.forEach(function(array) {
          finalLength_1 += array.byteLength;
        });
        var merged_1 = new Uint8Array(finalLength_1);
        var index_1 = 0;
        uint8Arrays.forEach(function(array) {
          for (var i = 0; i < array.length; i++) {
            merged_1[index_1++] = array[i];
          }
        });
        return new FbsBlob2(merged_1, true);
      }
    };
    FbsBlob2.prototype.uploadData = function() {
      return this.data_;
    };
    return FbsBlob2;
  }()
);
function jsonObjectOrNull(s) {
  var obj;
  try {
    obj = JSON.parse(s);
  } catch (e) {
    return null;
  }
  if (isNonArrayObject(obj)) {
    return obj;
  } else {
    return null;
  }
}
function parent(path) {
  if (path.length === 0) {
    return null;
  }
  var index = path.lastIndexOf("/");
  if (index === -1) {
    return "";
  }
  var newPath = path.slice(0, index);
  return newPath;
}
function child2(path, childPath) {
  var canonicalChildPath = childPath.split("/").filter(function(component) {
    return component.length > 0;
  }).join("/");
  if (path.length === 0) {
    return canonicalChildPath;
  } else {
    return path + "/" + canonicalChildPath;
  }
}
function lastComponent(path) {
  var index = path.lastIndexOf("/", path.length - 2);
  if (index === -1) {
    return path;
  } else {
    return path.slice(index + 1);
  }
}
function noXform_(metadata, value) {
  return value;
}
var Mapping = (
  /** @class */
  /* @__PURE__ */ function() {
    function Mapping2(server, local, writable, xform) {
      this.server = server;
      this.local = local || server;
      this.writable = !!writable;
      this.xform = xform || noXform_;
    }
    return Mapping2;
  }()
);
var mappings_ = null;
function xformPath(fullPath) {
  if (!isString(fullPath) || fullPath.length < 2) {
    return fullPath;
  } else {
    return lastComponent(fullPath);
  }
}
function getMappings() {
  if (mappings_) {
    return mappings_;
  }
  var mappings = [];
  mappings.push(new Mapping("bucket"));
  mappings.push(new Mapping("generation"));
  mappings.push(new Mapping("metageneration"));
  mappings.push(new Mapping("name", "fullPath", true));
  function mappingsXformPath(_metadata, fullPath) {
    return xformPath(fullPath);
  }
  var nameMapping = new Mapping("name");
  nameMapping.xform = mappingsXformPath;
  mappings.push(nameMapping);
  function xformSize(_metadata, size) {
    if (size !== void 0) {
      return Number(size);
    } else {
      return size;
    }
  }
  var sizeMapping = new Mapping("size");
  sizeMapping.xform = xformSize;
  mappings.push(sizeMapping);
  mappings.push(new Mapping("timeCreated"));
  mappings.push(new Mapping("updated"));
  mappings.push(new Mapping("md5Hash", null, true));
  mappings.push(new Mapping("cacheControl", null, true));
  mappings.push(new Mapping("contentDisposition", null, true));
  mappings.push(new Mapping("contentEncoding", null, true));
  mappings.push(new Mapping("contentLanguage", null, true));
  mappings.push(new Mapping("contentType", null, true));
  mappings.push(new Mapping("metadata", "customMetadata", true));
  mappings_ = mappings;
  return mappings_;
}
function addRef(metadata, service) {
  function generateRef() {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var loc = new Location(bucket, path);
    return service._makeStorageReference(loc);
  }
  Object.defineProperty(metadata, "ref", { get: generateRef });
}
function fromResource(service, resource, mappings) {
  var metadata = {};
  metadata["type"] = "file";
  var len = mappings.length;
  for (var i = 0; i < len; i++) {
    var mapping = mappings[i];
    metadata[mapping.local] = mapping.xform(metadata, resource[mapping.server]);
  }
  addRef(metadata, service);
  return metadata;
}
function fromResourceString(service, resourceString, mappings) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromResource(service, resource, mappings);
}
function downloadUrlFromResourceString(metadata, resourceString, host) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  if (!isString(obj["downloadTokens"])) {
    return null;
  }
  var tokens = obj["downloadTokens"];
  if (tokens.length === 0) {
    return null;
  }
  var encode2 = encodeURIComponent;
  var tokensList = tokens.split(",");
  var urls = tokensList.map(function(token) {
    var bucket = metadata["bucket"];
    var path = metadata["fullPath"];
    var urlPart = "/b/" + encode2(bucket) + "/o/" + encode2(path);
    var base = makeUrl(urlPart, host);
    var queryString = makeQueryString({
      alt: "media",
      token
    });
    return base + queryString;
  });
  return urls[0];
}
function toResourceString(metadata, mappings) {
  var resource = {};
  var len = mappings.length;
  for (var i = 0; i < len; i++) {
    var mapping = mappings[i];
    if (mapping.writable) {
      resource[mapping.server] = metadata[mapping.local];
    }
  }
  return JSON.stringify(resource);
}
var PREFIXES_KEY = "prefixes";
var ITEMS_KEY = "items";
function fromBackendResponse(service, bucket, resource) {
  var listResult = {
    prefixes: [],
    items: [],
    nextPageToken: resource["nextPageToken"]
  };
  if (resource[PREFIXES_KEY]) {
    for (var _i = 0, _a7 = resource[PREFIXES_KEY]; _i < _a7.length; _i++) {
      var path = _a7[_i];
      var pathWithoutTrailingSlash = path.replace(/\/$/, "");
      var reference = service._makeStorageReference(new Location(bucket, pathWithoutTrailingSlash));
      listResult.prefixes.push(reference);
    }
  }
  if (resource[ITEMS_KEY]) {
    for (var _b = 0, _c = resource[ITEMS_KEY]; _b < _c.length; _b++) {
      var item = _c[_b];
      var reference = service._makeStorageReference(new Location(bucket, item["name"]));
      listResult.items.push(reference);
    }
  }
  return listResult;
}
function fromResponseString(service, bucket, resourceString) {
  var obj = jsonObjectOrNull(resourceString);
  if (obj === null) {
    return null;
  }
  var resource = obj;
  return fromBackendResponse(service, bucket, resource);
}
var RequestInfo = (
  /** @class */
  /* @__PURE__ */ function() {
    function RequestInfo2(url, method, handler, timeout) {
      this.url = url;
      this.method = method;
      this.handler = handler;
      this.timeout = timeout;
      this.urlParams = {};
      this.headers = {};
      this.body = null;
      this.errorHandler = null;
      this.progressCallback = null;
      this.successCodes = [200];
      this.additionalRetryCodes = [];
    }
    return RequestInfo2;
  }()
);
function handlerCheck(cndn) {
  if (!cndn) {
    throw unknown();
  }
}
function metadataHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return metadata;
  }
  return handler;
}
function listHandler(service, bucket) {
  function handler(xhr, text) {
    var listResult = fromResponseString(service, bucket, text);
    handlerCheck(listResult !== null);
    return listResult;
  }
  return handler;
}
function downloadUrlHandler(service, mappings) {
  function handler(xhr, text) {
    var metadata = fromResourceString(service, text, mappings);
    handlerCheck(metadata !== null);
    return downloadUrlFromResourceString(metadata, text, service.host);
  }
  return handler;
}
function sharedErrorHandler(location2) {
  function errorHandler(xhr, err) {
    var newErr;
    if (xhr.getStatus() === 401) {
      if (
        // This exact message string is the only consistent part of the
        // server's error response that identifies it as an App Check error.
        xhr.getResponseText().includes("Firebase App Check token is invalid")
      ) {
        newErr = unauthorizedApp();
      } else {
        newErr = unauthenticated();
      }
    } else {
      if (xhr.getStatus() === 402) {
        newErr = quotaExceeded(location2.bucket);
      } else {
        if (xhr.getStatus() === 403) {
          newErr = unauthorized(location2.path);
        } else {
          newErr = err;
        }
      }
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function objectErrorHandler(location2) {
  var shared = sharedErrorHandler(location2);
  function errorHandler(xhr, err) {
    var newErr = shared(xhr, err);
    if (xhr.getStatus() === 404) {
      newErr = objectNotFound(location2.path);
    }
    newErr.serverResponse = err.serverResponse;
    return newErr;
  }
  return errorHandler;
}
function getMetadata$2(service, location2, mappings) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart, service.host);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function list$2(service, location2, delimiter, pageToken, maxResults) {
  var urlParams = {};
  if (location2.isRoot) {
    urlParams["prefix"] = "";
  } else {
    urlParams["prefix"] = location2.path + "/";
  }
  if (delimiter && delimiter.length > 0) {
    urlParams["delimiter"] = delimiter;
  }
  if (pageToken) {
    urlParams["pageToken"] = pageToken;
  }
  if (maxResults) {
    urlParams["maxResults"] = maxResults;
  }
  var urlPart = location2.bucketOnlyServerUrl();
  var url = makeUrl(urlPart, service.host);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, listHandler(service, location2.bucket), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
function getDownloadUrl(service, location2, mappings) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart, service.host);
  var method = "GET";
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, downloadUrlHandler(service, mappings), timeout);
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function updateMetadata$2(service, location2, metadata, mappings) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart, service.host);
  var method = "PATCH";
  var body = toResourceString(metadata, mappings);
  var headers = { "Content-Type": "application/json; charset=utf-8" };
  var timeout = service.maxOperationRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function deleteObject$2(service, location2) {
  var urlPart = location2.fullServerUrl();
  var url = makeUrl(urlPart, service.host);
  var method = "DELETE";
  var timeout = service.maxOperationRetryTime;
  function handler(_xhr, _text) {
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.successCodes = [200, 204];
  requestInfo.errorHandler = objectErrorHandler(location2);
  return requestInfo;
}
function determineContentType_(metadata, blob) {
  return metadata && metadata["contentType"] || blob && blob.type() || "application/octet-stream";
}
function metadataForUpload_(location2, blob, metadata) {
  var metadataClone = Object.assign({}, metadata);
  metadataClone["fullPath"] = location2.path;
  metadataClone["size"] = blob.size();
  if (!metadataClone["contentType"]) {
    metadataClone["contentType"] = determineContentType_(null, blob);
  }
  return metadataClone;
}
function multipartUpload(service, location2, mappings, blob, metadata) {
  var urlPart = location2.bucketOnlyServerUrl();
  var headers = {
    "X-Goog-Upload-Protocol": "multipart"
  };
  function genBoundary() {
    var str = "";
    for (var i = 0; i < 2; i++) {
      str = str + Math.random().toString().slice(2);
    }
    return str;
  }
  var boundary = genBoundary();
  headers["Content-Type"] = "multipart/related; boundary=" + boundary;
  var metadata_ = metadataForUpload_(location2, blob, metadata);
  var metadataString = toResourceString(metadata_, mappings);
  var preBlobPart = "--" + boundary + "\r\nContent-Type: application/json; charset=utf-8\r\n\r\n" + metadataString + "\r\n--" + boundary + "\r\nContent-Type: " + metadata_["contentType"] + "\r\n\r\n";
  var postBlobPart = "\r\n--" + boundary + "--";
  var body = FbsBlob.getBlob(preBlobPart, blob, postBlobPart);
  if (body === null) {
    throw cannotSliceBlob();
  }
  var urlParams = { name: metadata_["fullPath"] };
  var url = makeUrl(urlPart, service.host);
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, metadataHandler(service, mappings), timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
var ResumableUploadStatus = (
  /** @class */
  /* @__PURE__ */ function() {
    function ResumableUploadStatus2(current, total, finalized, metadata) {
      this.current = current;
      this.total = total;
      this.finalized = !!finalized;
      this.metadata = metadata || null;
    }
    return ResumableUploadStatus2;
  }()
);
function checkResumeHeader_(xhr, allowed) {
  var status = null;
  try {
    status = xhr.getResponseHeader("X-Goog-Upload-Status");
  } catch (e) {
    handlerCheck(false);
  }
  var allowedStatus = allowed || ["active"];
  handlerCheck(!!status && allowedStatus.indexOf(status) !== -1);
  return status;
}
function createResumableUpload(service, location2, mappings, blob, metadata) {
  var urlPart = location2.bucketOnlyServerUrl();
  var metadataForUpload = metadataForUpload_(location2, blob, metadata);
  var urlParams = { name: metadataForUpload["fullPath"] };
  var url = makeUrl(urlPart, service.host);
  var method = "POST";
  var headers = {
    "X-Goog-Upload-Protocol": "resumable",
    "X-Goog-Upload-Command": "start",
    "X-Goog-Upload-Header-Content-Length": "" + blob.size(),
    "X-Goog-Upload-Header-Content-Type": metadataForUpload["contentType"],
    "Content-Type": "application/json; charset=utf-8"
  };
  var body = toResourceString(metadataForUpload, mappings);
  var timeout = service.maxUploadRetryTime;
  function handler(xhr) {
    checkResumeHeader_(xhr);
    var url2;
    try {
      url2 = xhr.getResponseHeader("X-Goog-Upload-URL");
    } catch (e) {
      handlerCheck(false);
    }
    handlerCheck(isString(url2));
    return url2;
  }
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.urlParams = urlParams;
  requestInfo.headers = headers;
  requestInfo.body = body;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
function getResumableUploadStatus(service, location2, url, blob) {
  var headers = { "X-Goog-Upload-Command": "query" };
  function handler(xhr) {
    var status = checkResumeHeader_(xhr, ["active", "final"]);
    var sizeString = null;
    try {
      sizeString = xhr.getResponseHeader("X-Goog-Upload-Size-Received");
    } catch (e) {
      handlerCheck(false);
    }
    if (!sizeString) {
      handlerCheck(false);
    }
    var size = Number(sizeString);
    handlerCheck(!isNaN(size));
    return new ResumableUploadStatus(size, blob.size(), status === "final");
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
var RESUMABLE_UPLOAD_CHUNK_SIZE = 256 * 1024;
function continueResumableUpload(location2, service, url, blob, chunkSize, mappings, status, progressCallback) {
  var status_ = new ResumableUploadStatus(0, 0);
  if (status) {
    status_.current = status.current;
    status_.total = status.total;
  } else {
    status_.current = 0;
    status_.total = blob.size();
  }
  if (blob.size() !== status_.total) {
    throw serverFileWrongSize();
  }
  var bytesLeft = status_.total - status_.current;
  var bytesToUpload = bytesLeft;
  if (chunkSize > 0) {
    bytesToUpload = Math.min(bytesToUpload, chunkSize);
  }
  var startByte = status_.current;
  var endByte = startByte + bytesToUpload;
  var uploadCommand = bytesToUpload === bytesLeft ? "upload, finalize" : "upload";
  var headers = {
    "X-Goog-Upload-Command": uploadCommand,
    "X-Goog-Upload-Offset": "" + status_.current
  };
  var body = blob.slice(startByte, endByte);
  if (body === null) {
    throw cannotSliceBlob();
  }
  function handler(xhr, text) {
    var uploadStatus = checkResumeHeader_(xhr, ["active", "final"]);
    var newCurrent = status_.current + bytesToUpload;
    var size = blob.size();
    var metadata;
    if (uploadStatus === "final") {
      metadata = metadataHandler(service, mappings)(xhr, text);
    } else {
      metadata = null;
    }
    return new ResumableUploadStatus(newCurrent, size, uploadStatus === "final", metadata);
  }
  var method = "POST";
  var timeout = service.maxUploadRetryTime;
  var requestInfo = new RequestInfo(url, method, handler, timeout);
  requestInfo.headers = headers;
  requestInfo.body = body.uploadData();
  requestInfo.progressCallback = progressCallback || null;
  requestInfo.errorHandler = sharedErrorHandler(location2);
  return requestInfo;
}
var Observer = (
  /** @class */
  /* @__PURE__ */ function() {
    function Observer2(nextOrObserver, error2, complete) {
      var asFunctions = isFunction(nextOrObserver) || error2 != null || complete != null;
      if (asFunctions) {
        this.next = nextOrObserver;
        this.error = error2;
        this.complete = complete;
      } else {
        var observer = nextOrObserver;
        this.next = observer.next;
        this.error = observer.error;
        this.complete = observer.complete;
      }
    }
    return Observer2;
  }()
);
function async(f) {
  return function() {
    var argsToForward = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      argsToForward[_i] = arguments[_i];
    }
    Promise.resolve().then(function() {
      return f.apply(void 0, argsToForward);
    });
  };
}
var UploadTask = (
  /** @class */
  function() {
    function UploadTask2(ref3, blob, metadata) {
      var _this = this;
      if (metadata === void 0) {
        metadata = null;
      }
      this._transferred = 0;
      this._needToFetchStatus = false;
      this._needToFetchMetadata = false;
      this._observers = [];
      this._error = void 0;
      this._uploadUrl = void 0;
      this._request = void 0;
      this._chunkMultiplier = 1;
      this._resolve = void 0;
      this._reject = void 0;
      this._ref = ref3;
      this._blob = blob;
      this._metadata = metadata;
      this._mappings = getMappings();
      this._resumable = this._shouldDoResumable(this._blob);
      this._state = "running";
      this._errorHandler = function(error2) {
        _this._request = void 0;
        _this._chunkMultiplier = 1;
        if (error2._codeEquals(
          "canceled"
          /* CANCELED */
        )) {
          _this._needToFetchStatus = true;
          _this.completeTransitions_();
        } else {
          _this._error = error2;
          _this._transition(
            "error"
            /* ERROR */
          );
        }
      };
      this._metadataErrorHandler = function(error2) {
        _this._request = void 0;
        if (error2._codeEquals(
          "canceled"
          /* CANCELED */
        )) {
          _this.completeTransitions_();
        } else {
          _this._error = error2;
          _this._transition(
            "error"
            /* ERROR */
          );
        }
      };
      this._promise = new Promise(function(resolve, reject) {
        _this._resolve = resolve;
        _this._reject = reject;
        _this._start();
      });
      this._promise.then(null, function() {
      });
    }
    UploadTask2.prototype._makeProgressCallback = function() {
      var _this = this;
      var sizeBefore = this._transferred;
      return function(loaded) {
        return _this._updateProgress(sizeBefore + loaded);
      };
    };
    UploadTask2.prototype._shouldDoResumable = function(blob) {
      return blob.size() > 256 * 1024;
    };
    UploadTask2.prototype._start = function() {
      if (this._state !== "running") {
        return;
      }
      if (this._request !== void 0) {
        return;
      }
      if (this._resumable) {
        if (this._uploadUrl === void 0) {
          this._createResumable();
        } else {
          if (this._needToFetchStatus) {
            this._fetchStatus();
          } else {
            if (this._needToFetchMetadata) {
              this._fetchMetadata();
            } else {
              this._continueUpload();
            }
          }
        }
      } else {
        this._oneShotUpload();
      }
    };
    UploadTask2.prototype._resolveToken = function(callback) {
      var _this = this;
      Promise.all([
        this._ref.storage._getAuthToken(),
        this._ref.storage._getAppCheckToken()
      ]).then(function(_a7) {
        var authToken = _a7[0], appCheckToken = _a7[1];
        switch (_this._state) {
          case "running":
            callback(authToken, appCheckToken);
            break;
          case "canceling":
            _this._transition(
              "canceled"
              /* CANCELED */
            );
            break;
          case "pausing":
            _this._transition(
              "paused"
              /* PAUSED */
            );
            break;
        }
      });
    };
    UploadTask2.prototype._createResumable = function() {
      var _this = this;
      this._resolveToken(function(authToken, appCheckToken) {
        var requestInfo = createResumableUpload(_this._ref.storage, _this._ref._location, _this._mappings, _this._blob, _this._metadata);
        var createRequest = _this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
        _this._request = createRequest;
        createRequest.getPromise().then(function(url) {
          _this._request = void 0;
          _this._uploadUrl = url;
          _this._needToFetchStatus = false;
          _this.completeTransitions_();
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._fetchStatus = function() {
      var _this = this;
      var url = this._uploadUrl;
      this._resolveToken(function(authToken, appCheckToken) {
        var requestInfo = getResumableUploadStatus(_this._ref.storage, _this._ref._location, url, _this._blob);
        var statusRequest = _this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
        _this._request = statusRequest;
        statusRequest.getPromise().then(function(status) {
          status = status;
          _this._request = void 0;
          _this._updateProgress(status.current);
          _this._needToFetchStatus = false;
          if (status.finalized) {
            _this._needToFetchMetadata = true;
          }
          _this.completeTransitions_();
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._continueUpload = function() {
      var _this = this;
      var chunkSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
      var status = new ResumableUploadStatus(this._transferred, this._blob.size());
      var url = this._uploadUrl;
      this._resolveToken(function(authToken, appCheckToken) {
        var requestInfo;
        try {
          requestInfo = continueResumableUpload(_this._ref._location, _this._ref.storage, url, _this._blob, chunkSize, _this._mappings, status, _this._makeProgressCallback());
        } catch (e) {
          _this._error = e;
          _this._transition(
            "error"
            /* ERROR */
          );
          return;
        }
        var uploadRequest = _this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
        _this._request = uploadRequest;
        uploadRequest.getPromise().then(function(newStatus) {
          _this._increaseMultiplier();
          _this._request = void 0;
          _this._updateProgress(newStatus.current);
          if (newStatus.finalized) {
            _this._metadata = newStatus.metadata;
            _this._transition(
              "success"
              /* SUCCESS */
            );
          } else {
            _this.completeTransitions_();
          }
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._increaseMultiplier = function() {
      var currentSize = RESUMABLE_UPLOAD_CHUNK_SIZE * this._chunkMultiplier;
      if (currentSize < 32 * 1024 * 1024) {
        this._chunkMultiplier *= 2;
      }
    };
    UploadTask2.prototype._fetchMetadata = function() {
      var _this = this;
      this._resolveToken(function(authToken, appCheckToken) {
        var requestInfo = getMetadata$2(_this._ref.storage, _this._ref._location, _this._mappings);
        var metadataRequest = _this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
        _this._request = metadataRequest;
        metadataRequest.getPromise().then(function(metadata) {
          _this._request = void 0;
          _this._metadata = metadata;
          _this._transition(
            "success"
            /* SUCCESS */
          );
        }, _this._metadataErrorHandler);
      });
    };
    UploadTask2.prototype._oneShotUpload = function() {
      var _this = this;
      this._resolveToken(function(authToken, appCheckToken) {
        var requestInfo = multipartUpload(_this._ref.storage, _this._ref._location, _this._mappings, _this._blob, _this._metadata);
        var multipartRequest = _this._ref.storage._makeRequest(requestInfo, authToken, appCheckToken);
        _this._request = multipartRequest;
        multipartRequest.getPromise().then(function(metadata) {
          _this._request = void 0;
          _this._metadata = metadata;
          _this._updateProgress(_this._blob.size());
          _this._transition(
            "success"
            /* SUCCESS */
          );
        }, _this._errorHandler);
      });
    };
    UploadTask2.prototype._updateProgress = function(transferred) {
      var old = this._transferred;
      this._transferred = transferred;
      if (this._transferred !== old) {
        this._notifyObservers();
      }
    };
    UploadTask2.prototype._transition = function(state) {
      if (this._state === state) {
        return;
      }
      switch (state) {
        case "canceling":
          this._state = state;
          if (this._request !== void 0) {
            this._request.cancel();
          }
          break;
        case "pausing":
          this._state = state;
          if (this._request !== void 0) {
            this._request.cancel();
          }
          break;
        case "running":
          var wasPaused = this._state === "paused";
          this._state = state;
          if (wasPaused) {
            this._notifyObservers();
            this._start();
          }
          break;
        case "paused":
          this._state = state;
          this._notifyObservers();
          break;
        case "canceled":
          this._error = canceled();
          this._state = state;
          this._notifyObservers();
          break;
        case "error":
          this._state = state;
          this._notifyObservers();
          break;
        case "success":
          this._state = state;
          this._notifyObservers();
          break;
      }
    };
    UploadTask2.prototype.completeTransitions_ = function() {
      switch (this._state) {
        case "pausing":
          this._transition(
            "paused"
            /* PAUSED */
          );
          break;
        case "canceling":
          this._transition(
            "canceled"
            /* CANCELED */
          );
          break;
        case "running":
          this._start();
          break;
      }
    };
    Object.defineProperty(UploadTask2.prototype, "snapshot", {
      /**
       * A snapshot of the current task state.
       */
      get: function() {
        var externalState = taskStateFromInternalTaskState(this._state);
        return {
          bytesTransferred: this._transferred,
          totalBytes: this._blob.size(),
          state: externalState,
          metadata: this._metadata,
          task: this,
          ref: this._ref
        };
      },
      enumerable: false,
      configurable: true
    });
    UploadTask2.prototype.on = function(type, nextOrObserver, error2, completed) {
      var _this = this;
      var observer = new Observer(nextOrObserver, error2, completed);
      this._addObserver(observer);
      return function() {
        _this._removeObserver(observer);
      };
    };
    UploadTask2.prototype.then = function(onFulfilled, onRejected) {
      return this._promise.then(onFulfilled, onRejected);
    };
    UploadTask2.prototype.catch = function(onRejected) {
      return this.then(null, onRejected);
    };
    UploadTask2.prototype._addObserver = function(observer) {
      this._observers.push(observer);
      this._notifyObserver(observer);
    };
    UploadTask2.prototype._removeObserver = function(observer) {
      var i = this._observers.indexOf(observer);
      if (i !== -1) {
        this._observers.splice(i, 1);
      }
    };
    UploadTask2.prototype._notifyObservers = function() {
      var _this = this;
      this._finishPromise();
      var observers = this._observers.slice();
      observers.forEach(function(observer) {
        _this._notifyObserver(observer);
      });
    };
    UploadTask2.prototype._finishPromise = function() {
      if (this._resolve !== void 0) {
        var triggered = true;
        switch (taskStateFromInternalTaskState(this._state)) {
          case TaskState.SUCCESS:
            async(this._resolve.bind(null, this.snapshot))();
            break;
          case TaskState.CANCELED:
          case TaskState.ERROR:
            var toCall = this._reject;
            async(toCall.bind(null, this._error))();
            break;
          default:
            triggered = false;
            break;
        }
        if (triggered) {
          this._resolve = void 0;
          this._reject = void 0;
        }
      }
    };
    UploadTask2.prototype._notifyObserver = function(observer) {
      var externalState = taskStateFromInternalTaskState(this._state);
      switch (externalState) {
        case TaskState.RUNNING:
        case TaskState.PAUSED:
          if (observer.next) {
            async(observer.next.bind(observer, this.snapshot))();
          }
          break;
        case TaskState.SUCCESS:
          if (observer.complete) {
            async(observer.complete.bind(observer))();
          }
          break;
        case TaskState.CANCELED:
        case TaskState.ERROR:
          if (observer.error) {
            async(observer.error.bind(observer, this._error))();
          }
          break;
        default:
          if (observer.error) {
            async(observer.error.bind(observer, this._error))();
          }
      }
    };
    UploadTask2.prototype.resume = function() {
      var valid = this._state === "paused" || this._state === "pausing";
      if (valid) {
        this._transition(
          "running"
          /* RUNNING */
        );
      }
      return valid;
    };
    UploadTask2.prototype.pause = function() {
      var valid = this._state === "running";
      if (valid) {
        this._transition(
          "pausing"
          /* PAUSING */
        );
      }
      return valid;
    };
    UploadTask2.prototype.cancel = function() {
      var valid = this._state === "running" || this._state === "pausing";
      if (valid) {
        this._transition(
          "canceling"
          /* CANCELING */
        );
      }
      return valid;
    };
    return UploadTask2;
  }()
);
var Reference2 = (
  /** @class */
  function() {
    function Reference3(_service, location2) {
      this._service = _service;
      if (location2 instanceof Location) {
        this._location = location2;
      } else {
        this._location = Location.makeFromUrl(location2, _service.host);
      }
    }
    Reference3.prototype.toString = function() {
      return "gs://" + this._location.bucket + "/" + this._location.path;
    };
    Reference3.prototype._newRef = function(service, location2) {
      return new Reference3(service, location2);
    };
    Object.defineProperty(Reference3.prototype, "root", {
      /**
       * A reference to the root of this object's bucket.
       */
      get: function() {
        var location2 = new Location(this._location.bucket, "");
        return this._newRef(this._service, location2);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "bucket", {
      /**
       * The name of the bucket containing this reference's object.
       */
      get: function() {
        return this._location.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "fullPath", {
      /**
       * The full path of this object.
       */
      get: function() {
        return this._location.path;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "name", {
      /**
       * The short name of this object, which is the last component of the full path.
       * For example, if fullPath is 'full/path/image.png', name is 'image.png'.
       */
      get: function() {
        return lastComponent(this._location.path);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "storage", {
      /**
       * The `StorageService` instance this `StorageReference` is associated with.
       */
      get: function() {
        return this._service;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(Reference3.prototype, "parent", {
      /**
       * A `StorageReference` pointing to the parent location of this `StorageReference`, or null if
       * this reference is the root.
       */
      get: function() {
        var newPath = parent(this._location.path);
        if (newPath === null) {
          return null;
        }
        var location2 = new Location(this._location.bucket, newPath);
        return new Reference3(this._service, location2);
      },
      enumerable: false,
      configurable: true
    });
    Reference3.prototype._throwIfRoot = function(name10) {
      if (this._location.path === "") {
        throw invalidRootOperation(name10);
      }
    };
    return Reference3;
  }()
);
function uploadBytesResumable$1(ref3, data, metadata) {
  ref3._throwIfRoot("uploadBytesResumable");
  return new UploadTask(ref3, new FbsBlob(data), metadata);
}
function listAll$1(ref3) {
  var accumulator = {
    prefixes: [],
    items: []
  };
  return listAllHelper(ref3, accumulator).then(function() {
    return accumulator;
  });
}
function listAllHelper(ref3, accumulator, pageToken) {
  return __awaiter(this, void 0, void 0, function() {
    var opt, nextPage;
    var _a7, _b;
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          opt = {
            // maxResults is 1000 by default.
            pageToken
          };
          return [4, list$1(ref3, opt)];
        case 1:
          nextPage = _c.sent();
          (_a7 = accumulator.prefixes).push.apply(_a7, nextPage.prefixes);
          (_b = accumulator.items).push.apply(_b, nextPage.items);
          if (!(nextPage.nextPageToken != null)) return [3, 3];
          return [4, listAllHelper(ref3, accumulator, nextPage.nextPageToken)];
        case 2:
          _c.sent();
          _c.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function list$1(ref3, options) {
  return __awaiter(this, void 0, void 0, function() {
    var op, requestInfo;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (options != null) {
            if (typeof options.maxResults === "number") {
              validateNumber(
                "options.maxResults",
                /* minValue= */
                1,
                /* maxValue= */
                1e3,
                options.maxResults
              );
            }
          }
          op = options || {};
          requestInfo = list$2(
            ref3.storage,
            ref3._location,
            /*delimiter= */
            "/",
            op.pageToken,
            op.maxResults
          );
          return [4, ref3.storage.makeRequestWithTokens(requestInfo)];
        case 1:
          return [2, _a7.sent().getPromise()];
      }
    });
  });
}
function getMetadata$1(ref3) {
  return __awaiter(this, void 0, void 0, function() {
    var requestInfo;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          ref3._throwIfRoot("getMetadata");
          requestInfo = getMetadata$2(ref3.storage, ref3._location, getMappings());
          return [4, ref3.storage.makeRequestWithTokens(requestInfo)];
        case 1:
          return [2, _a7.sent().getPromise()];
      }
    });
  });
}
function updateMetadata$1(ref3, metadata) {
  return __awaiter(this, void 0, void 0, function() {
    var requestInfo;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          ref3._throwIfRoot("updateMetadata");
          requestInfo = updateMetadata$2(ref3.storage, ref3._location, metadata, getMappings());
          return [4, ref3.storage.makeRequestWithTokens(requestInfo)];
        case 1:
          return [2, _a7.sent().getPromise()];
      }
    });
  });
}
function getDownloadURL$1(ref3) {
  return __awaiter(this, void 0, void 0, function() {
    var requestInfo;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          ref3._throwIfRoot("getDownloadURL");
          requestInfo = getDownloadUrl(ref3.storage, ref3._location, getMappings());
          return [4, ref3.storage.makeRequestWithTokens(requestInfo)];
        case 1:
          return [2, _a7.sent().getPromise().then(function(url) {
            if (url === null) {
              throw noDownloadURL();
            }
            return url;
          })];
      }
    });
  });
}
function deleteObject$1(ref3) {
  return __awaiter(this, void 0, void 0, function() {
    var requestInfo;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          ref3._throwIfRoot("deleteObject");
          requestInfo = deleteObject$2(ref3.storage, ref3._location);
          return [4, ref3.storage.makeRequestWithTokens(requestInfo)];
        case 1:
          return [2, _a7.sent().getPromise()];
      }
    });
  });
}
function _getChild$1(ref3, childPath) {
  var newPath = child2(ref3._location.path, childPath);
  var location2 = new Location(ref3._location.bucket, newPath);
  return new Reference2(ref3.storage, location2);
}
function isUrl(path) {
  return /^[A-Za-z]+:\/\//.test(path);
}
function refFromURL2(service, url) {
  return new Reference2(service, url);
}
function refFromPath(ref3, path) {
  if (ref3 instanceof FirebaseStorageImpl) {
    var service = ref3;
    if (service._bucket == null) {
      throw noDefaultBucket();
    }
    var reference = new Reference2(service, service._bucket);
    if (path != null) {
      return refFromPath(reference, path);
    } else {
      return reference;
    }
  } else {
    if (path !== void 0) {
      return _getChild$1(ref3, path);
    } else {
      return ref3;
    }
  }
}
function ref$1(serviceOrRef, pathOrUrl) {
  if (pathOrUrl && isUrl(pathOrUrl)) {
    if (serviceOrRef instanceof FirebaseStorageImpl) {
      return refFromURL2(serviceOrRef, pathOrUrl);
    } else {
      throw invalidArgument("To use ref(service, url), the first argument must be a Storage instance.");
    }
  } else {
    return refFromPath(serviceOrRef, pathOrUrl);
  }
}
function extractBucket(host, config) {
  var bucketString = config === null || config === void 0 ? void 0 : config[CONFIG_STORAGE_BUCKET_KEY];
  if (bucketString == null) {
    return null;
  }
  return Location.makeFromBucketSpec(bucketString, host);
}
function connectStorageEmulator$1(storage, host, port, options) {
  if (options === void 0) {
    options = {};
  }
  storage.host = "http://" + host + ":" + port;
  var mockUserToken = options.mockUserToken;
  if (mockUserToken) {
    storage._overrideAuthToken = typeof mockUserToken === "string" ? mockUserToken : createMockUserToken(mockUserToken, storage.app.options.projectId);
  }
}
var FirebaseStorageImpl = (
  /** @class */
  function() {
    function FirebaseStorageImpl2(app, _authProvider, _appCheckProvider, _pool, _url, _firebaseVersion) {
      this.app = app;
      this._authProvider = _authProvider;
      this._appCheckProvider = _appCheckProvider;
      this._pool = _pool;
      this._url = _url;
      this._firebaseVersion = _firebaseVersion;
      this._bucket = null;
      this._host = DEFAULT_HOST;
      this._appId = null;
      this._deleted = false;
      this._maxOperationRetryTime = DEFAULT_MAX_OPERATION_RETRY_TIME;
      this._maxUploadRetryTime = DEFAULT_MAX_UPLOAD_RETRY_TIME;
      this._requests = /* @__PURE__ */ new Set();
      if (_url != null) {
        this._bucket = Location.makeFromBucketSpec(_url, this._host);
      } else {
        this._bucket = extractBucket(this._host, this.app.options);
      }
    }
    Object.defineProperty(FirebaseStorageImpl2.prototype, "host", {
      get: function() {
        return this._host;
      },
      /**
       * Set host string for this service.
       * @param host - host string in the form of host, host:port,
       * or protocol://host:port
       */
      set: function(host) {
        this._host = host;
        if (this._url != null) {
          this._bucket = Location.makeFromBucketSpec(this._url, host);
        } else {
          this._bucket = extractBucket(host, this.app.options);
        }
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageImpl2.prototype, "maxUploadRetryTime", {
      /**
       * The maximum time to retry uploads in milliseconds.
       */
      get: function() {
        return this._maxUploadRetryTime;
      },
      set: function(time) {
        validateNumber(
          "time",
          /* minValue=*/
          0,
          /* maxValue= */
          Number.POSITIVE_INFINITY,
          time
        );
        this._maxUploadRetryTime = time;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(FirebaseStorageImpl2.prototype, "maxOperationRetryTime", {
      /**
       * The maximum time to retry operations other than uploads or downloads in
       * milliseconds.
       */
      get: function() {
        return this._maxOperationRetryTime;
      },
      set: function(time) {
        validateNumber(
          "time",
          /* minValue=*/
          0,
          /* maxValue= */
          Number.POSITIVE_INFINITY,
          time
        );
        this._maxOperationRetryTime = time;
      },
      enumerable: false,
      configurable: true
    });
    FirebaseStorageImpl2.prototype._getAuthToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var auth, tokenData;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (this._overrideAuthToken) {
                return [2, this._overrideAuthToken];
              }
              auth = this._authProvider.getImmediate({ optional: true });
              if (!auth) return [3, 2];
              return [4, auth.getToken()];
            case 1:
              tokenData = _a7.sent();
              if (tokenData !== null) {
                return [2, tokenData.accessToken];
              }
              _a7.label = 2;
            case 2:
              return [2, null];
          }
        });
      });
    };
    FirebaseStorageImpl2.prototype._getAppCheckToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var appCheck, result;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              appCheck = this._appCheckProvider.getImmediate({ optional: true });
              if (!appCheck) return [3, 2];
              return [4, appCheck.getToken()];
            case 1:
              result = _a7.sent();
              return [2, result.token];
            case 2:
              return [2, null];
          }
        });
      });
    };
    FirebaseStorageImpl2.prototype._delete = function() {
      if (!this._deleted) {
        this._deleted = true;
        this._requests.forEach(function(request) {
          return request.cancel();
        });
        this._requests.clear();
      }
      return Promise.resolve();
    };
    FirebaseStorageImpl2.prototype._makeStorageReference = function(loc) {
      return new Reference2(this, loc);
    };
    FirebaseStorageImpl2.prototype._makeRequest = function(requestInfo, authToken, appCheckToken) {
      var _this = this;
      if (!this._deleted) {
        var request_1 = makeRequest(requestInfo, this._appId, authToken, appCheckToken, this._pool, this._firebaseVersion);
        this._requests.add(request_1);
        request_1.getPromise().then(function() {
          return _this._requests.delete(request_1);
        }, function() {
          return _this._requests.delete(request_1);
        });
        return request_1;
      } else {
        return new FailRequest(appDeleted());
      }
    };
    FirebaseStorageImpl2.prototype.makeRequestWithTokens = function(requestInfo) {
      return __awaiter(this, void 0, void 0, function() {
        var _a7, authToken, appCheckToken;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this._getAuthToken(),
                this._getAppCheckToken()
              ])];
            case 1:
              _a7 = _b.sent(), authToken = _a7[0], appCheckToken = _a7[1];
              return [2, this._makeRequest(requestInfo, authToken, appCheckToken)];
          }
        });
      });
    };
    return FirebaseStorageImpl2;
  }()
);
function uploadBytesResumable(ref3, data, metadata) {
  ref3 = getModularInstance(ref3);
  return uploadBytesResumable$1(ref3, data, metadata);
}
function getMetadata(ref3) {
  ref3 = getModularInstance(ref3);
  return getMetadata$1(ref3);
}
function updateMetadata(ref3, metadata) {
  ref3 = getModularInstance(ref3);
  return updateMetadata$1(ref3, metadata);
}
function list(ref3, options) {
  ref3 = getModularInstance(ref3);
  return list$1(ref3, options);
}
function listAll(ref3) {
  ref3 = getModularInstance(ref3);
  return listAll$1(ref3);
}
function getDownloadURL(ref3) {
  ref3 = getModularInstance(ref3);
  return getDownloadURL$1(ref3);
}
function deleteObject(ref3) {
  ref3 = getModularInstance(ref3);
  return deleteObject$1(ref3);
}
function ref2(serviceOrRef, pathOrUrl) {
  serviceOrRef = getModularInstance(serviceOrRef);
  return ref$1(serviceOrRef, pathOrUrl);
}
function _getChild(ref3, childPath) {
  return _getChild$1(ref3, childPath);
}
function connectStorageEmulator(storage, host, port, options) {
  if (options === void 0) {
    options = {};
  }
  connectStorageEmulator$1(storage, host, port, options);
}
var UploadTaskSnapshotCompat = (
  /** @class */
  function() {
    function UploadTaskSnapshotCompat2(_delegate, task, ref3) {
      this._delegate = _delegate;
      this.task = task;
      this.ref = ref3;
    }
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "bytesTransferred", {
      get: function() {
        return this._delegate.bytesTransferred;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "metadata", {
      get: function() {
        return this._delegate.metadata;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "state", {
      get: function() {
        return this._delegate.state;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(UploadTaskSnapshotCompat2.prototype, "totalBytes", {
      get: function() {
        return this._delegate.totalBytes;
      },
      enumerable: false,
      configurable: true
    });
    return UploadTaskSnapshotCompat2;
  }()
);
var UploadTaskCompat = (
  /** @class */
  function() {
    function UploadTaskCompat2(_delegate, _ref) {
      this._delegate = _delegate;
      this._ref = _ref;
      this.cancel = this._delegate.cancel.bind(this._delegate);
      this.catch = this._delegate.catch.bind(this._delegate);
      this.pause = this._delegate.pause.bind(this._delegate);
      this.resume = this._delegate.resume.bind(this._delegate);
    }
    Object.defineProperty(UploadTaskCompat2.prototype, "snapshot", {
      get: function() {
        return new UploadTaskSnapshotCompat(this._delegate.snapshot, this, this._ref);
      },
      enumerable: false,
      configurable: true
    });
    UploadTaskCompat2.prototype.then = function(onFulfilled, onRejected) {
      var _this = this;
      return this._delegate.then(function(snapshot) {
        if (onFulfilled) {
          return onFulfilled(new UploadTaskSnapshotCompat(snapshot, _this, _this._ref));
        }
      }, onRejected);
    };
    UploadTaskCompat2.prototype.on = function(type, nextOrObserver, error2, completed) {
      var _this = this;
      var wrappedNextOrObserver = void 0;
      if (!!nextOrObserver) {
        if (typeof nextOrObserver === "function") {
          wrappedNextOrObserver = function(taskSnapshot) {
            return nextOrObserver(new UploadTaskSnapshotCompat(taskSnapshot, _this, _this._ref));
          };
        } else {
          wrappedNextOrObserver = {
            next: !!nextOrObserver.next ? function(taskSnapshot) {
              return nextOrObserver.next(new UploadTaskSnapshotCompat(taskSnapshot, _this, _this._ref));
            } : void 0,
            complete: nextOrObserver.complete || void 0,
            error: nextOrObserver.error || void 0
          };
        }
      }
      return this._delegate.on(type, wrappedNextOrObserver, error2 || void 0, completed || void 0);
    };
    return UploadTaskCompat2;
  }()
);
var ListResultCompat = (
  /** @class */
  function() {
    function ListResultCompat2(_delegate, _service) {
      this._delegate = _delegate;
      this._service = _service;
    }
    Object.defineProperty(ListResultCompat2.prototype, "prefixes", {
      get: function() {
        var _this = this;
        return this._delegate.prefixes.map(function(ref3) {
          return new ReferenceCompat(ref3, _this._service);
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListResultCompat2.prototype, "items", {
      get: function() {
        var _this = this;
        return this._delegate.items.map(function(ref3) {
          return new ReferenceCompat(ref3, _this._service);
        });
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ListResultCompat2.prototype, "nextPageToken", {
      get: function() {
        return this._delegate.nextPageToken || null;
      },
      enumerable: false,
      configurable: true
    });
    return ListResultCompat2;
  }()
);
var ReferenceCompat = (
  /** @class */
  function() {
    function ReferenceCompat2(_delegate, storage) {
      this._delegate = _delegate;
      this.storage = storage;
    }
    Object.defineProperty(ReferenceCompat2.prototype, "name", {
      get: function() {
        return this._delegate.name;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "bucket", {
      get: function() {
        return this._delegate.bucket;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "fullPath", {
      get: function() {
        return this._delegate.fullPath;
      },
      enumerable: false,
      configurable: true
    });
    ReferenceCompat2.prototype.toString = function() {
      return this._delegate.toString();
    };
    ReferenceCompat2.prototype.child = function(childPath) {
      var reference = _getChild(this._delegate, childPath);
      return new ReferenceCompat2(reference, this.storage);
    };
    Object.defineProperty(ReferenceCompat2.prototype, "root", {
      get: function() {
        return new ReferenceCompat2(this._delegate.root, this.storage);
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(ReferenceCompat2.prototype, "parent", {
      /**
       * @returns A reference to the parent of the
       * current object, or null if the current object is the root.
       */
      get: function() {
        var reference = this._delegate.parent;
        if (reference == null) {
          return null;
        }
        return new ReferenceCompat2(reference, this.storage);
      },
      enumerable: false,
      configurable: true
    });
    ReferenceCompat2.prototype.put = function(data, metadata) {
      this._throwIfRoot("put");
      return new UploadTaskCompat(uploadBytesResumable(this._delegate, data, metadata), this);
    };
    ReferenceCompat2.prototype.putString = function(value, format, metadata) {
      if (format === void 0) {
        format = StringFormat.RAW;
      }
      this._throwIfRoot("putString");
      var data = dataFromString(format, value);
      var metadataClone = __assign({}, metadata);
      if (metadataClone["contentType"] == null && data.contentType != null) {
        metadataClone["contentType"] = data.contentType;
      }
      return new UploadTaskCompat(new UploadTask(this._delegate, new FbsBlob(data.data, true), metadataClone), this);
    };
    ReferenceCompat2.prototype.listAll = function() {
      var _this = this;
      return listAll(this._delegate).then(function(r) {
        return new ListResultCompat(r, _this.storage);
      });
    };
    ReferenceCompat2.prototype.list = function(options) {
      var _this = this;
      return list(this._delegate, options || void 0).then(function(r) {
        return new ListResultCompat(r, _this.storage);
      });
    };
    ReferenceCompat2.prototype.getMetadata = function() {
      return getMetadata(this._delegate);
    };
    ReferenceCompat2.prototype.updateMetadata = function(metadata) {
      return updateMetadata(this._delegate, metadata);
    };
    ReferenceCompat2.prototype.getDownloadURL = function() {
      return getDownloadURL(this._delegate);
    };
    ReferenceCompat2.prototype.delete = function() {
      this._throwIfRoot("delete");
      return deleteObject(this._delegate);
    };
    ReferenceCompat2.prototype._throwIfRoot = function(name10) {
      if (this._delegate._location.path === "") {
        throw invalidRootOperation(name10);
      }
    };
    return ReferenceCompat2;
  }()
);
var StorageServiceCompat = (
  /** @class */
  function() {
    function StorageServiceCompat2(app, _delegate) {
      this.app = app;
      this._delegate = _delegate;
    }
    Object.defineProperty(StorageServiceCompat2.prototype, "maxOperationRetryTime", {
      get: function() {
        return this._delegate.maxOperationRetryTime;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(StorageServiceCompat2.prototype, "maxUploadRetryTime", {
      get: function() {
        return this._delegate.maxUploadRetryTime;
      },
      enumerable: false,
      configurable: true
    });
    StorageServiceCompat2.prototype.ref = function(path) {
      if (isUrl(path)) {
        throw invalidArgument("ref() expected a child path but got a URL, use refFromURL instead.");
      }
      return new ReferenceCompat(ref2(this._delegate, path), this);
    };
    StorageServiceCompat2.prototype.refFromURL = function(url) {
      if (!isUrl(url)) {
        throw invalidArgument("refFromURL() expected a full URL but got a child path, use ref() instead.");
      }
      try {
        Location.makeFromUrl(url, this._delegate.host);
      } catch (e) {
        throw invalidArgument("refFromUrl() expected a valid full URL but got an invalid one.");
      }
      return new ReferenceCompat(ref2(this._delegate, url), this);
    };
    StorageServiceCompat2.prototype.setMaxUploadRetryTime = function(time) {
      this._delegate.maxUploadRetryTime = time;
    };
    StorageServiceCompat2.prototype.setMaxOperationRetryTime = function(time) {
      this._delegate.maxOperationRetryTime = time;
    };
    StorageServiceCompat2.prototype.useEmulator = function(host, port, options) {
      if (options === void 0) {
        options = {};
      }
      connectStorageEmulator(this._delegate, host, port, options);
    };
    return StorageServiceCompat2;
  }()
);
var name4 = "@firebase/storage";
var version4 = "0.7.1";
var STORAGE_TYPE = "storage";
function factory(container, _a7) {
  var url = _a7.instanceIdentifier;
  var app = container.getProvider("app").getImmediate();
  var authProvider = container.getProvider("auth-internal");
  var appCheckProvider = container.getProvider("app-check-internal");
  var storageServiceCompat = new StorageServiceCompat(app, new FirebaseStorageImpl(app, authProvider, appCheckProvider, new ConnectionPool(), url, index_esm_default.SDK_VERSION));
  return storageServiceCompat;
}
function registerStorage(instance) {
  var namespaceExports = {
    // no-inline
    TaskState,
    TaskEvent,
    StringFormat,
    Storage: FirebaseStorageImpl,
    Reference: ReferenceCompat
  };
  instance.INTERNAL.registerComponent(new Component(
    STORAGE_TYPE,
    factory,
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps(namespaceExports).setMultipleInstances(true));
  instance.registerVersion(name4, version4);
}
registerStorage(index_esm_default);

// node_modules/@firebase/performance/dist/index.esm.js
var name5 = "@firebase/performance";
var version5 = "0.4.18";
var SDK_VERSION2 = version5;
var TRACE_START_MARK_PREFIX = "FB-PERF-TRACE-START";
var TRACE_STOP_MARK_PREFIX = "FB-PERF-TRACE-STOP";
var TRACE_MEASURE_PREFIX = "FB-PERF-TRACE-MEASURE";
var OOB_TRACE_PAGE_LOAD_PREFIX = "_wt_";
var FIRST_PAINT_COUNTER_NAME = "_fp";
var FIRST_CONTENTFUL_PAINT_COUNTER_NAME = "_fcp";
var FIRST_INPUT_DELAY_COUNTER_NAME = "_fid";
var CONFIG_LOCAL_STORAGE_KEY = "@firebase/performance/config";
var CONFIG_EXPIRY_LOCAL_STORAGE_KEY = "@firebase/performance/configexpire";
var SERVICE2 = "performance";
var SERVICE_NAME2 = "Performance";
var _a3;
var ERROR_DESCRIPTION_MAP2 = (_a3 = {}, _a3[
  "trace started"
  /* TRACE_STARTED_BEFORE */
] = "Trace {$traceName} was started before.", _a3[
  "trace stopped"
  /* TRACE_STOPPED_BEFORE */
] = "Trace {$traceName} is not running.", _a3[
  "nonpositive trace startTime"
  /* NONPOSITIVE_TRACE_START_TIME */
] = "Trace {$traceName} startTime should be positive.", _a3[
  "nonpositive trace duration"
  /* NONPOSITIVE_TRACE_DURATION */
] = "Trace {$traceName} duration should be positive.", _a3[
  "no window"
  /* NO_WINDOW */
] = "Window is not available.", _a3[
  "no app id"
  /* NO_APP_ID */
] = "App id is not available.", _a3[
  "no project id"
  /* NO_PROJECT_ID */
] = "Project id is not available.", _a3[
  "no api key"
  /* NO_API_KEY */
] = "Api key is not available.", _a3[
  "invalid cc log"
  /* INVALID_CC_LOG */
] = "Attempted to queue invalid cc event", _a3[
  "FB not default"
  /* FB_NOT_DEFAULT */
] = "Performance can only start when Firebase app instance is the default one.", _a3[
  "RC response not ok"
  /* RC_NOT_OK */
] = "RC response is not ok", _a3[
  "invalid attribute name"
  /* INVALID_ATTRIBUTE_NAME */
] = "Attribute name {$attributeName} is invalid.", _a3[
  "invalid attribute value"
  /* INVALID_ATTRIBUTE_VALUE */
] = "Attribute value {$attributeValue} is invalid.", _a3[
  "invalid custom metric name"
  /* INVALID_CUSTOM_METRIC_NAME */
] = "Custom metric name {$customMetricName} is invalid", _a3[
  "invalid String merger input"
  /* INVALID_STRING_MERGER_PARAMETER */
] = "Input for String merger is invalid, contact support team to resolve.", _a3);
var ERROR_FACTORY3 = new ErrorFactory(SERVICE2, SERVICE_NAME2, ERROR_DESCRIPTION_MAP2);
var consoleLogger = new Logger(SERVICE_NAME2);
consoleLogger.logLevel = LogLevel.INFO;
var apiInstance;
var windowInstance;
var Api = (
  /** @class */
  function() {
    function Api2(window2) {
      this.window = window2;
      if (!window2) {
        throw ERROR_FACTORY3.create(
          "no window"
          /* NO_WINDOW */
        );
      }
      this.performance = window2.performance;
      this.PerformanceObserver = window2.PerformanceObserver;
      this.windowLocation = window2.location;
      this.navigator = window2.navigator;
      this.document = window2.document;
      if (this.navigator && this.navigator.cookieEnabled) {
        this.localStorage = window2.localStorage;
      }
      if (window2.perfMetrics && window2.perfMetrics.onFirstInputDelay) {
        this.onFirstInputDelay = window2.perfMetrics.onFirstInputDelay;
      }
    }
    Api2.prototype.getUrl = function() {
      return this.windowLocation.href.split("?")[0];
    };
    Api2.prototype.mark = function(name10) {
      if (!this.performance || !this.performance.mark) {
        return;
      }
      this.performance.mark(name10);
    };
    Api2.prototype.measure = function(measureName, mark1, mark2) {
      if (!this.performance || !this.performance.measure) {
        return;
      }
      this.performance.measure(measureName, mark1, mark2);
    };
    Api2.prototype.getEntriesByType = function(type) {
      if (!this.performance || !this.performance.getEntriesByType) {
        return [];
      }
      return this.performance.getEntriesByType(type);
    };
    Api2.prototype.getEntriesByName = function(name10) {
      if (!this.performance || !this.performance.getEntriesByName) {
        return [];
      }
      return this.performance.getEntriesByName(name10);
    };
    Api2.prototype.getTimeOrigin = function() {
      return this.performance && (this.performance.timeOrigin || this.performance.timing.navigationStart);
    };
    Api2.prototype.requiredApisAvailable = function() {
      if (!fetch || !Promise || !this.navigator || !this.navigator.cookieEnabled) {
        consoleLogger.info("Firebase Performance cannot start if browser does not support fetch and Promise or cookie is disabled.");
        return false;
      }
      if (!isIndexedDBAvailable()) {
        consoleLogger.info("IndexedDB is not supported by current browswer");
        return false;
      }
      return true;
    };
    Api2.prototype.setupObserver = function(entryType, callback) {
      if (!this.PerformanceObserver) {
        return;
      }
      var observer = new this.PerformanceObserver(function(list2) {
        for (var _i = 0, _a7 = list2.getEntries(); _i < _a7.length; _i++) {
          var entry = _a7[_i];
          callback(entry);
        }
      });
      observer.observe({ entryTypes: [entryType] });
    };
    Api2.getInstance = function() {
      if (apiInstance === void 0) {
        apiInstance = new Api2(windowInstance);
      }
      return apiInstance;
    };
    return Api2;
  }()
);
function setupApi(window2) {
  windowInstance = window2;
}
function mergeStrings(part1, part2) {
  var sizeDiff = part1.length - part2.length;
  if (sizeDiff < 0 || sizeDiff > 1) {
    throw ERROR_FACTORY3.create(
      "invalid String merger input"
      /* INVALID_STRING_MERGER_PARAMETER */
    );
  }
  var resultArray = [];
  for (var i = 0; i < part1.length; i++) {
    resultArray.push(part1.charAt(i));
    if (part2.length > i) {
      resultArray.push(part2.charAt(i));
    }
  }
  return resultArray.join("");
}
var settingsServiceInstance;
var SettingsService = (
  /** @class */
  function() {
    function SettingsService2() {
      this.instrumentationEnabled = true;
      this.dataCollectionEnabled = true;
      this.loggingEnabled = false;
      this.tracesSamplingRate = 1;
      this.networkRequestsSamplingRate = 1;
      this.logEndPointUrl = "https://firebaselogging.googleapis.com/v0cc/log?format=json_proto";
      this.flTransportEndpointUrl = mergeStrings("hts/frbslgigp.ogepscmv/ieo/eaylg", "tp:/ieaeogn-agolai.o/1frlglgc/o");
      this.transportKey = mergeStrings("AzSC8r6ReiGqFMyfvgow", "Iayx0u-XT3vksVM-pIV");
      this.logSource = 462;
      this.logTraceAfterSampling = false;
      this.logNetworkAfterSampling = false;
      this.configTimeToLive = 12;
    }
    SettingsService2.prototype.getAppId = function() {
      var appId = this.firebaseAppInstance && this.firebaseAppInstance.options && this.firebaseAppInstance.options.appId;
      if (!appId) {
        throw ERROR_FACTORY3.create(
          "no app id"
          /* NO_APP_ID */
        );
      }
      return appId;
    };
    SettingsService2.prototype.getProjectId = function() {
      var projectId = this.firebaseAppInstance && this.firebaseAppInstance.options && this.firebaseAppInstance.options.projectId;
      if (!projectId) {
        throw ERROR_FACTORY3.create(
          "no project id"
          /* NO_PROJECT_ID */
        );
      }
      return projectId;
    };
    SettingsService2.prototype.getApiKey = function() {
      var apiKey = this.firebaseAppInstance && this.firebaseAppInstance.options && this.firebaseAppInstance.options.apiKey;
      if (!apiKey) {
        throw ERROR_FACTORY3.create(
          "no api key"
          /* NO_API_KEY */
        );
      }
      return apiKey;
    };
    SettingsService2.prototype.getFlTransportFullUrl = function() {
      return this.flTransportEndpointUrl.concat("?key=", this.transportKey);
    };
    SettingsService2.getInstance = function() {
      if (settingsServiceInstance === void 0) {
        settingsServiceInstance = new SettingsService2();
      }
      return settingsServiceInstance;
    };
    return SettingsService2;
  }()
);
var iid;
function getIidPromise() {
  var iidPromise = SettingsService.getInstance().installationsService.getId();
  iidPromise.then(function(iidVal) {
    iid = iidVal;
  });
  return iidPromise;
}
function getIid() {
  return iid;
}
function getAuthTokenPromise() {
  var authTokenPromise = SettingsService.getInstance().installationsService.getToken();
  authTokenPromise.then(function(authTokenVal) {
  });
  return authTokenPromise;
}
var VisibilityState;
(function(VisibilityState2) {
  VisibilityState2[VisibilityState2["UNKNOWN"] = 0] = "UNKNOWN";
  VisibilityState2[VisibilityState2["VISIBLE"] = 1] = "VISIBLE";
  VisibilityState2[VisibilityState2["HIDDEN"] = 2] = "HIDDEN";
})(VisibilityState || (VisibilityState = {}));
var RESERVED_ATTRIBUTE_PREFIXES = ["firebase_", "google_", "ga_"];
var ATTRIBUTE_FORMAT_REGEX = new RegExp("^[a-zA-Z]\\w*$");
var MAX_ATTRIBUTE_NAME_LENGTH = 40;
var MAX_ATTRIBUTE_VALUE_LENGTH = 100;
function getServiceWorkerStatus() {
  var navigator2 = Api.getInstance().navigator;
  if ("serviceWorker" in navigator2) {
    if (navigator2.serviceWorker.controller) {
      return 2;
    } else {
      return 3;
    }
  } else {
    return 1;
  }
}
function getVisibilityState() {
  var document2 = Api.getInstance().document;
  var visibilityState = document2.visibilityState;
  switch (visibilityState) {
    case "visible":
      return VisibilityState.VISIBLE;
    case "hidden":
      return VisibilityState.HIDDEN;
    default:
      return VisibilityState.UNKNOWN;
  }
}
function getEffectiveConnectionType() {
  var navigator2 = Api.getInstance().navigator;
  var navigatorConnection = navigator2.connection;
  var effectiveType = navigatorConnection && navigatorConnection.effectiveType;
  switch (effectiveType) {
    case "slow-2g":
      return 1;
    case "2g":
      return 2;
    case "3g":
      return 3;
    case "4g":
      return 4;
    default:
      return 0;
  }
}
function isValidCustomAttributeName(name10) {
  if (name10.length === 0 || name10.length > MAX_ATTRIBUTE_NAME_LENGTH) {
    return false;
  }
  var matchesReservedPrefix = RESERVED_ATTRIBUTE_PREFIXES.some(function(prefix) {
    return name10.startsWith(prefix);
  });
  return !matchesReservedPrefix && !!name10.match(ATTRIBUTE_FORMAT_REGEX);
}
function isValidCustomAttributeValue(value) {
  return value.length !== 0 && value.length <= MAX_ATTRIBUTE_VALUE_LENGTH;
}
var REMOTE_CONFIG_SDK_VERSION = "0.0.1";
var DEFAULT_CONFIGS = {
  loggingEnabled: true
};
var FIS_AUTH_PREFIX = "FIREBASE_INSTALLATIONS_AUTH";
function getConfig(iid2) {
  var config = getStoredConfig();
  if (config) {
    processConfig(config);
    return Promise.resolve();
  }
  return getRemoteConfig(iid2).then(processConfig).then(
    function(config2) {
      return storeConfig(config2);
    },
    /** Do nothing for error, use defaults set in settings service. */
    function() {
    }
  );
}
function getStoredConfig() {
  var localStorage = Api.getInstance().localStorage;
  if (!localStorage) {
    return;
  }
  var expiryString = localStorage.getItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY);
  if (!expiryString || !configValid(expiryString)) {
    return;
  }
  var configStringified = localStorage.getItem(CONFIG_LOCAL_STORAGE_KEY);
  if (!configStringified) {
    return;
  }
  try {
    var configResponse = JSON.parse(configStringified);
    return configResponse;
  } catch (_a7) {
    return;
  }
}
function storeConfig(config) {
  var localStorage = Api.getInstance().localStorage;
  if (!config || !localStorage) {
    return;
  }
  localStorage.setItem(CONFIG_LOCAL_STORAGE_KEY, JSON.stringify(config));
  localStorage.setItem(CONFIG_EXPIRY_LOCAL_STORAGE_KEY, String(Date.now() + SettingsService.getInstance().configTimeToLive * 60 * 60 * 1e3));
}
var COULD_NOT_GET_CONFIG_MSG = "Could not fetch config, will use default configs";
function getRemoteConfig(iid2) {
  return getAuthTokenPromise().then(function(authToken) {
    var projectId = SettingsService.getInstance().getProjectId();
    var configEndPoint = "https://firebaseremoteconfig.googleapis.com/v1/projects/" + projectId + "/namespaces/fireperf:fetch?key=" + SettingsService.getInstance().getApiKey();
    var request = new Request(configEndPoint, {
      method: "POST",
      headers: { Authorization: FIS_AUTH_PREFIX + " " + authToken },
      /* eslint-disable camelcase */
      body: JSON.stringify({
        app_instance_id: iid2,
        app_instance_id_token: authToken,
        app_id: SettingsService.getInstance().getAppId(),
        app_version: SDK_VERSION2,
        sdk_version: REMOTE_CONFIG_SDK_VERSION
      })
      /* eslint-enable camelcase */
    });
    return fetch(request).then(function(response) {
      if (response.ok) {
        return response.json();
      }
      throw ERROR_FACTORY3.create(
        "RC response not ok"
        /* RC_NOT_OK */
      );
    });
  }).catch(function() {
    consoleLogger.info(COULD_NOT_GET_CONFIG_MSG);
    return void 0;
  });
}
function processConfig(config) {
  if (!config) {
    return config;
  }
  var settingsServiceInstance2 = SettingsService.getInstance();
  var entries = config.entries || {};
  if (entries.fpr_enabled !== void 0) {
    settingsServiceInstance2.loggingEnabled = String(entries.fpr_enabled) === "true";
  } else {
    settingsServiceInstance2.loggingEnabled = DEFAULT_CONFIGS.loggingEnabled;
  }
  if (entries.fpr_log_source) {
    settingsServiceInstance2.logSource = Number(entries.fpr_log_source);
  }
  if (entries.fpr_log_endpoint_url) {
    settingsServiceInstance2.logEndPointUrl = entries.fpr_log_endpoint_url;
  }
  if (entries.fpr_log_transport_key) {
    settingsServiceInstance2.transportKey = entries.fpr_log_transport_key;
  }
  if (entries.fpr_vc_network_request_sampling_rate !== void 0) {
    settingsServiceInstance2.networkRequestsSamplingRate = Number(entries.fpr_vc_network_request_sampling_rate);
  }
  if (entries.fpr_vc_trace_sampling_rate !== void 0) {
    settingsServiceInstance2.tracesSamplingRate = Number(entries.fpr_vc_trace_sampling_rate);
  }
  settingsServiceInstance2.logTraceAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.tracesSamplingRate);
  settingsServiceInstance2.logNetworkAfterSampling = shouldLogAfterSampling(settingsServiceInstance2.networkRequestsSamplingRate);
  return config;
}
function configValid(expiry) {
  return Number(expiry) > Date.now();
}
function shouldLogAfterSampling(samplingRate) {
  return Math.random() <= samplingRate;
}
var initializationStatus = 1;
var initializationPromise;
function getInitializationPromise() {
  initializationStatus = 2;
  initializationPromise = initializationPromise || initializePerf();
  return initializationPromise;
}
function isPerfInitialized() {
  return initializationStatus === 3;
}
function initializePerf() {
  return getDocumentReadyComplete().then(function() {
    return getIidPromise();
  }).then(function(iid2) {
    return getConfig(iid2);
  }).then(function() {
    return changeInitializationStatus();
  }, function() {
    return changeInitializationStatus();
  });
}
function getDocumentReadyComplete() {
  var document2 = Api.getInstance().document;
  return new Promise(function(resolve) {
    if (document2 && document2.readyState !== "complete") {
      var handler_1 = function() {
        if (document2.readyState === "complete") {
          document2.removeEventListener("readystatechange", handler_1);
          resolve();
        }
      };
      document2.addEventListener("readystatechange", handler_1);
    } else {
      resolve();
    }
  });
}
function changeInitializationStatus() {
  initializationStatus = 3;
}
var DEFAULT_SEND_INTERVAL_MS = 10 * 1e3;
var INITIAL_SEND_TIME_DELAY_MS = 5.5 * 1e3;
var DEFAULT_REMAINING_TRIES = 3;
var MAX_EVENT_COUNT_PER_REQUEST = 1e3;
var remainingTries = DEFAULT_REMAINING_TRIES;
var queue = [];
var isTransportSetup = false;
function setupTransportService() {
  if (!isTransportSetup) {
    processQueue(INITIAL_SEND_TIME_DELAY_MS);
    isTransportSetup = true;
  }
}
function processQueue(timeOffset) {
  setTimeout(function() {
    if (remainingTries === 0) {
      return;
    }
    if (!queue.length) {
      return processQueue(DEFAULT_SEND_INTERVAL_MS);
    }
    dispatchQueueEvents();
  }, timeOffset);
}
function dispatchQueueEvents() {
  var staged = queue.splice(0, MAX_EVENT_COUNT_PER_REQUEST);
  var log_event = staged.map(function(evt) {
    return {
      source_extension_json_proto3: evt.message,
      event_time_ms: String(evt.eventTime)
    };
  });
  var data = {
    request_time_ms: String(Date.now()),
    client_info: {
      client_type: 1,
      js_client_info: {}
    },
    log_source: SettingsService.getInstance().logSource,
    log_event
  };
  sendEventsToFl(data, staged).catch(function() {
    queue = __spreadArray(__spreadArray([], staged), queue);
    remainingTries--;
    consoleLogger.info("Tries left: " + remainingTries + ".");
    processQueue(DEFAULT_SEND_INTERVAL_MS);
  });
}
function sendEventsToFl(data, staged) {
  return postToFlEndpoint(data).then(function(res) {
    if (!res.ok) {
      consoleLogger.info("Call to Firebase backend failed.");
    }
    return res.json();
  }).then(function(res) {
    var transportWait = Number(res.nextRequestWaitMillis);
    var requestOffset = DEFAULT_SEND_INTERVAL_MS;
    if (!isNaN(transportWait)) {
      requestOffset = Math.max(transportWait, requestOffset);
    }
    var logResponseDetails = res.logResponseDetails;
    if (Array.isArray(logResponseDetails) && logResponseDetails.length > 0 && logResponseDetails[0].responseAction === "RETRY_REQUEST_LATER") {
      queue = __spreadArray(__spreadArray([], staged), queue);
      consoleLogger.info("Retry transport request later.");
    }
    remainingTries = DEFAULT_REMAINING_TRIES;
    processQueue(requestOffset);
  });
}
function postToFlEndpoint(data) {
  var flTransportFullUrl = SettingsService.getInstance().getFlTransportFullUrl();
  return fetch(flTransportFullUrl, {
    method: "POST",
    body: JSON.stringify(data)
  });
}
function addToQueue(evt) {
  if (!evt.eventTime || !evt.message) {
    throw ERROR_FACTORY3.create(
      "invalid cc log"
      /* INVALID_CC_LOG */
    );
  }
  queue = __spreadArray(__spreadArray([], queue), [evt]);
}
function transportHandler(serializer2) {
  return function() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      args[_i] = arguments[_i];
    }
    var message = serializer2.apply(void 0, args);
    addToQueue({
      message,
      eventTime: Date.now()
    });
  };
}
var logger2;
function sendLog(resource, resourceType) {
  if (!logger2) {
    logger2 = transportHandler(serializer);
  }
  logger2(resource, resourceType);
}
function logTrace(trace) {
  var settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled && trace.isAuto) {
    return;
  }
  if (!settingsService.dataCollectionEnabled && !trace.isAuto) {
    return;
  }
  if (!Api.getInstance().requiredApisAvailable()) {
    return;
  }
  if (trace.isAuto && getVisibilityState() !== VisibilityState.VISIBLE) {
    return;
  }
  if (isPerfInitialized()) {
    sendTraceLog(trace);
  } else {
    getInitializationPromise().then(function() {
      return sendTraceLog(trace);
    }, function() {
      return sendTraceLog(trace);
    });
  }
}
function sendTraceLog(trace) {
  if (!getIid()) {
    return;
  }
  var settingsService = SettingsService.getInstance();
  if (!settingsService.loggingEnabled || !settingsService.logTraceAfterSampling) {
    return;
  }
  setTimeout(function() {
    return sendLog(
      trace,
      1
      /* Trace */
    );
  }, 0);
}
function logNetworkRequest(networkRequest) {
  var settingsService = SettingsService.getInstance();
  if (!settingsService.instrumentationEnabled) {
    return;
  }
  var networkRequestUrl = networkRequest.url;
  var logEndpointUrl = settingsService.logEndPointUrl.split("?")[0];
  var flEndpointUrl = settingsService.flTransportEndpointUrl.split("?")[0];
  if (networkRequestUrl === logEndpointUrl || networkRequestUrl === flEndpointUrl) {
    return;
  }
  if (!settingsService.loggingEnabled || !settingsService.logNetworkAfterSampling) {
    return;
  }
  setTimeout(function() {
    return sendLog(
      networkRequest,
      0
      /* NetworkRequest */
    );
  }, 0);
}
function serializer(resource, resourceType) {
  if (resourceType === 0) {
    return serializeNetworkRequest(resource);
  }
  return serializeTrace(resource);
}
function serializeNetworkRequest(networkRequest) {
  var networkRequestMetric = {
    url: networkRequest.url,
    http_method: networkRequest.httpMethod || 0,
    http_response_code: 200,
    response_payload_bytes: networkRequest.responsePayloadBytes,
    client_start_time_us: networkRequest.startTimeUs,
    time_to_response_initiated_us: networkRequest.timeToResponseInitiatedUs,
    time_to_response_completed_us: networkRequest.timeToResponseCompletedUs
  };
  var perfMetric = {
    application_info: getApplicationInfo(),
    network_request_metric: networkRequestMetric
  };
  return JSON.stringify(perfMetric);
}
function serializeTrace(trace) {
  var traceMetric = {
    name: trace.name,
    is_auto: trace.isAuto,
    client_start_time_us: trace.startTimeUs,
    duration_us: trace.durationUs
  };
  if (Object.keys(trace.counters).length !== 0) {
    traceMetric.counters = trace.counters;
  }
  var customAttributes = trace.getAttributes();
  if (Object.keys(customAttributes).length !== 0) {
    traceMetric.custom_attributes = customAttributes;
  }
  var perfMetric = {
    application_info: getApplicationInfo(),
    trace_metric: traceMetric
  };
  return JSON.stringify(perfMetric);
}
function getApplicationInfo() {
  return {
    google_app_id: SettingsService.getInstance().getAppId(),
    app_instance_id: getIid(),
    web_app_info: {
      sdk_version: SDK_VERSION2,
      page_url: Api.getInstance().getUrl(),
      service_worker_status: getServiceWorkerStatus(),
      visibility_state: getVisibilityState(),
      effective_connection_type: getEffectiveConnectionType()
    },
    application_process_state: 0
  };
}
var MAX_METRIC_NAME_LENGTH = 100;
var RESERVED_AUTO_PREFIX = "_";
var oobMetrics = [
  FIRST_PAINT_COUNTER_NAME,
  FIRST_CONTENTFUL_PAINT_COUNTER_NAME,
  FIRST_INPUT_DELAY_COUNTER_NAME
];
function isValidMetricName(name10, traceName) {
  if (name10.length === 0 || name10.length > MAX_METRIC_NAME_LENGTH) {
    return false;
  }
  return traceName && traceName.startsWith(OOB_TRACE_PAGE_LOAD_PREFIX) && oobMetrics.indexOf(name10) > -1 || !name10.startsWith(RESERVED_AUTO_PREFIX);
}
function convertMetricValueToInteger(providedValue) {
  var valueAsInteger = Math.floor(providedValue);
  if (valueAsInteger < providedValue) {
    consoleLogger.info("Metric value should be an Integer, setting the value as : " + valueAsInteger + ".");
  }
  return valueAsInteger;
}
var Trace = (
  /** @class */
  function() {
    function Trace2(name10, isAuto, traceMeasureName) {
      if (isAuto === void 0) {
        isAuto = false;
      }
      this.name = name10;
      this.isAuto = isAuto;
      this.state = 1;
      this.customAttributes = {};
      this.counters = {};
      this.api = Api.getInstance();
      this.randomId = Math.floor(Math.random() * 1e6);
      if (!this.isAuto) {
        this.traceStartMark = TRACE_START_MARK_PREFIX + "-" + this.randomId + "-" + this.name;
        this.traceStopMark = TRACE_STOP_MARK_PREFIX + "-" + this.randomId + "-" + this.name;
        this.traceMeasure = traceMeasureName || TRACE_MEASURE_PREFIX + "-" + this.randomId + "-" + this.name;
        if (traceMeasureName) {
          this.calculateTraceMetrics();
        }
      }
    }
    Trace2.prototype.start = function() {
      if (this.state !== 1) {
        throw ERROR_FACTORY3.create("trace started", {
          traceName: this.name
        });
      }
      this.api.mark(this.traceStartMark);
      this.state = 2;
    };
    Trace2.prototype.stop = function() {
      if (this.state !== 2) {
        throw ERROR_FACTORY3.create("trace stopped", {
          traceName: this.name
        });
      }
      this.state = 3;
      this.api.mark(this.traceStopMark);
      this.api.measure(this.traceMeasure, this.traceStartMark, this.traceStopMark);
      this.calculateTraceMetrics();
      logTrace(this);
    };
    Trace2.prototype.record = function(startTime, duration, options) {
      if (startTime <= 0) {
        throw ERROR_FACTORY3.create("nonpositive trace startTime", {
          traceName: this.name
        });
      }
      if (duration <= 0) {
        throw ERROR_FACTORY3.create("nonpositive trace duration", {
          traceName: this.name
        });
      }
      this.durationUs = Math.floor(duration * 1e3);
      this.startTimeUs = Math.floor(startTime * 1e3);
      if (options && options.attributes) {
        this.customAttributes = __assign({}, options.attributes);
      }
      if (options && options.metrics) {
        for (var _i = 0, _a7 = Object.keys(options.metrics); _i < _a7.length; _i++) {
          var metric = _a7[_i];
          if (!isNaN(Number(options.metrics[metric]))) {
            this.counters[metric] = Number(Math.floor(options.metrics[metric]));
          }
        }
      }
      logTrace(this);
    };
    Trace2.prototype.incrementMetric = function(counter, numAsInteger) {
      if (numAsInteger === void 0) {
        numAsInteger = 1;
      }
      if (this.counters[counter] === void 0) {
        this.putMetric(counter, numAsInteger);
      } else {
        this.putMetric(counter, this.counters[counter] + numAsInteger);
      }
    };
    Trace2.prototype.putMetric = function(counter, numAsInteger) {
      if (isValidMetricName(counter, this.name)) {
        this.counters[counter] = convertMetricValueToInteger(numAsInteger);
      } else {
        throw ERROR_FACTORY3.create("invalid custom metric name", {
          customMetricName: counter
        });
      }
    };
    Trace2.prototype.getMetric = function(counter) {
      return this.counters[counter] || 0;
    };
    Trace2.prototype.putAttribute = function(attr, value) {
      var isValidName = isValidCustomAttributeName(attr);
      var isValidValue = isValidCustomAttributeValue(value);
      if (isValidName && isValidValue) {
        this.customAttributes[attr] = value;
        return;
      }
      if (!isValidName) {
        throw ERROR_FACTORY3.create("invalid attribute name", {
          attributeName: attr
        });
      }
      if (!isValidValue) {
        throw ERROR_FACTORY3.create("invalid attribute value", {
          attributeValue: value
        });
      }
    };
    Trace2.prototype.getAttribute = function(attr) {
      return this.customAttributes[attr];
    };
    Trace2.prototype.removeAttribute = function(attr) {
      if (this.customAttributes[attr] === void 0) {
        return;
      }
      delete this.customAttributes[attr];
    };
    Trace2.prototype.getAttributes = function() {
      return __assign({}, this.customAttributes);
    };
    Trace2.prototype.setStartTime = function(startTime) {
      this.startTimeUs = startTime;
    };
    Trace2.prototype.setDuration = function(duration) {
      this.durationUs = duration;
    };
    Trace2.prototype.calculateTraceMetrics = function() {
      var perfMeasureEntries = this.api.getEntriesByName(this.traceMeasure);
      var perfMeasureEntry = perfMeasureEntries && perfMeasureEntries[0];
      if (perfMeasureEntry) {
        this.durationUs = Math.floor(perfMeasureEntry.duration * 1e3);
        this.startTimeUs = Math.floor((perfMeasureEntry.startTime + this.api.getTimeOrigin()) * 1e3);
      }
    };
    Trace2.createOobTrace = function(navigationTimings, paintTimings, firstInputDelay) {
      var route = Api.getInstance().getUrl();
      if (!route) {
        return;
      }
      var trace = new Trace2(OOB_TRACE_PAGE_LOAD_PREFIX + route, true);
      var timeOriginUs = Math.floor(Api.getInstance().getTimeOrigin() * 1e3);
      trace.setStartTime(timeOriginUs);
      if (navigationTimings && navigationTimings[0]) {
        trace.setDuration(Math.floor(navigationTimings[0].duration * 1e3));
        trace.putMetric("domInteractive", Math.floor(navigationTimings[0].domInteractive * 1e3));
        trace.putMetric("domContentLoadedEventEnd", Math.floor(navigationTimings[0].domContentLoadedEventEnd * 1e3));
        trace.putMetric("loadEventEnd", Math.floor(navigationTimings[0].loadEventEnd * 1e3));
      }
      var FIRST_PAINT = "first-paint";
      var FIRST_CONTENTFUL_PAINT = "first-contentful-paint";
      if (paintTimings) {
        var firstPaint = paintTimings.find(function(paintObject) {
          return paintObject.name === FIRST_PAINT;
        });
        if (firstPaint && firstPaint.startTime) {
          trace.putMetric(FIRST_PAINT_COUNTER_NAME, Math.floor(firstPaint.startTime * 1e3));
        }
        var firstContentfulPaint = paintTimings.find(function(paintObject) {
          return paintObject.name === FIRST_CONTENTFUL_PAINT;
        });
        if (firstContentfulPaint && firstContentfulPaint.startTime) {
          trace.putMetric(FIRST_CONTENTFUL_PAINT_COUNTER_NAME, Math.floor(firstContentfulPaint.startTime * 1e3));
        }
        if (firstInputDelay) {
          trace.putMetric(FIRST_INPUT_DELAY_COUNTER_NAME, Math.floor(firstInputDelay * 1e3));
        }
      }
      logTrace(trace);
    };
    Trace2.createUserTimingTrace = function(measureName) {
      var trace = new Trace2(measureName, false, measureName);
      logTrace(trace);
    };
    return Trace2;
  }()
);
function createNetworkRequestEntry(entry) {
  var performanceEntry = entry;
  if (!performanceEntry || performanceEntry.responseStart === void 0) {
    return;
  }
  var timeOrigin = Api.getInstance().getTimeOrigin();
  var startTimeUs = Math.floor((performanceEntry.startTime + timeOrigin) * 1e3);
  var timeToResponseInitiatedUs = performanceEntry.responseStart ? Math.floor((performanceEntry.responseStart - performanceEntry.startTime) * 1e3) : void 0;
  var timeToResponseCompletedUs = Math.floor((performanceEntry.responseEnd - performanceEntry.startTime) * 1e3);
  var url = performanceEntry.name && performanceEntry.name.split("?")[0];
  var networkRequest = {
    url,
    responsePayloadBytes: performanceEntry.transferSize,
    startTimeUs,
    timeToResponseInitiatedUs,
    timeToResponseCompletedUs
  };
  logNetworkRequest(networkRequest);
}
var FID_WAIT_TIME_MS = 5e3;
function setupOobResources() {
  if (!getIid()) {
    return;
  }
  setTimeout(function() {
    return setupOobTraces();
  }, 0);
  setTimeout(function() {
    return setupNetworkRequests();
  }, 0);
  setTimeout(function() {
    return setupUserTimingTraces();
  }, 0);
}
function setupNetworkRequests() {
  var api = Api.getInstance();
  var resources = api.getEntriesByType("resource");
  for (var _i = 0, resources_1 = resources; _i < resources_1.length; _i++) {
    var resource = resources_1[_i];
    createNetworkRequestEntry(resource);
  }
  api.setupObserver("resource", createNetworkRequestEntry);
}
function setupOobTraces() {
  var api = Api.getInstance();
  var navigationTimings = api.getEntriesByType("navigation");
  var paintTimings = api.getEntriesByType("paint");
  if (api.onFirstInputDelay) {
    var timeoutId_1 = setTimeout(function() {
      Trace.createOobTrace(navigationTimings, paintTimings);
      timeoutId_1 = void 0;
    }, FID_WAIT_TIME_MS);
    api.onFirstInputDelay(function(fid) {
      if (timeoutId_1) {
        clearTimeout(timeoutId_1);
        Trace.createOobTrace(navigationTimings, paintTimings, fid);
      }
    });
  } else {
    Trace.createOobTrace(navigationTimings, paintTimings);
  }
}
function setupUserTimingTraces() {
  var api = Api.getInstance();
  var measures = api.getEntriesByType("measure");
  for (var _i = 0, measures_1 = measures; _i < measures_1.length; _i++) {
    var measure = measures_1[_i];
    createUserTimingTrace(measure);
  }
  api.setupObserver("measure", createUserTimingTrace);
}
function createUserTimingTrace(measure) {
  var measureName = measure.name;
  if (measureName.substring(0, TRACE_MEASURE_PREFIX.length) === TRACE_MEASURE_PREFIX) {
    return;
  }
  Trace.createUserTimingTrace(measureName);
}
var PerformanceController = (
  /** @class */
  function() {
    function PerformanceController2(app) {
      this.app = app;
      if (Api.getInstance().requiredApisAvailable()) {
        validateIndexedDBOpenable().then(function(isAvailable) {
          if (isAvailable) {
            setupTransportService();
            getInitializationPromise().then(setupOobResources, setupOobResources);
          }
        }).catch(function(error2) {
          consoleLogger.info("Environment doesn't support IndexedDB: " + error2);
        });
      }
    }
    PerformanceController2.prototype.trace = function(name10) {
      return new Trace(name10);
    };
    Object.defineProperty(PerformanceController2.prototype, "instrumentationEnabled", {
      get: function() {
        return SettingsService.getInstance().instrumentationEnabled;
      },
      set: function(val) {
        SettingsService.getInstance().instrumentationEnabled = val;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(PerformanceController2.prototype, "dataCollectionEnabled", {
      get: function() {
        return SettingsService.getInstance().dataCollectionEnabled;
      },
      set: function(val) {
        SettingsService.getInstance().dataCollectionEnabled = val;
      },
      enumerable: false,
      configurable: true
    });
    return PerformanceController2;
  }()
);
var DEFAULT_ENTRY_NAME = "[DEFAULT]";
function registerPerformance(instance) {
  var factoryMethod2 = function(app, installations) {
    if (app.name !== DEFAULT_ENTRY_NAME) {
      throw ERROR_FACTORY3.create(
        "FB not default"
        /* FB_NOT_DEFAULT */
      );
    }
    if (typeof window === "undefined") {
      throw ERROR_FACTORY3.create(
        "no window"
        /* NO_WINDOW */
      );
    }
    setupApi(window);
    SettingsService.getInstance().firebaseAppInstance = app;
    SettingsService.getInstance().installationsService = installations;
    return new PerformanceController(app);
  };
  instance.INTERNAL.registerComponent(new Component(
    "performance",
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var installations = container.getProvider("installations").getImmediate();
      return factoryMethod2(app, installations);
    },
    "PUBLIC"
    /* PUBLIC */
  ));
  instance.registerVersion(name5, version5);
}
registerPerformance(index_esm_default);

// node_modules/@firebase/analytics/dist/index.esm.js
var GA_FID_KEY = "firebase_id";
var ORIGIN_KEY = "origin";
var FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DYNAMIC_CONFIG_URL = "https://firebase.googleapis.com/v1alpha/projects/-/apps/{app-id}/webConfig";
var GTAG_URL = "https://www.googletagmanager.com/gtag/js";
var GtagCommand;
(function(GtagCommand2) {
  GtagCommand2["EVENT"] = "event";
  GtagCommand2["SET"] = "set";
  GtagCommand2["CONFIG"] = "config";
})(GtagCommand || (GtagCommand = {}));
var EventName;
(function(EventName2) {
  EventName2["ADD_SHIPPING_INFO"] = "add_shipping_info";
  EventName2["ADD_PAYMENT_INFO"] = "add_payment_info";
  EventName2["ADD_TO_CART"] = "add_to_cart";
  EventName2["ADD_TO_WISHLIST"] = "add_to_wishlist";
  EventName2["BEGIN_CHECKOUT"] = "begin_checkout";
  EventName2["CHECKOUT_PROGRESS"] = "checkout_progress";
  EventName2["EXCEPTION"] = "exception";
  EventName2["GENERATE_LEAD"] = "generate_lead";
  EventName2["LOGIN"] = "login";
  EventName2["PAGE_VIEW"] = "page_view";
  EventName2["PURCHASE"] = "purchase";
  EventName2["REFUND"] = "refund";
  EventName2["REMOVE_FROM_CART"] = "remove_from_cart";
  EventName2["SCREEN_VIEW"] = "screen_view";
  EventName2["SEARCH"] = "search";
  EventName2["SELECT_CONTENT"] = "select_content";
  EventName2["SELECT_ITEM"] = "select_item";
  EventName2["SELECT_PROMOTION"] = "select_promotion";
  EventName2["SET_CHECKOUT_OPTION"] = "set_checkout_option";
  EventName2["SHARE"] = "share";
  EventName2["SIGN_UP"] = "sign_up";
  EventName2["TIMING_COMPLETE"] = "timing_complete";
  EventName2["VIEW_CART"] = "view_cart";
  EventName2["VIEW_ITEM"] = "view_item";
  EventName2["VIEW_ITEM_LIST"] = "view_item_list";
  EventName2["VIEW_PROMOTION"] = "view_promotion";
  EventName2["VIEW_SEARCH_RESULTS"] = "view_search_results";
})(EventName || (EventName = {}));
function logEvent(gtagFunction, initializationPromise2, eventName, eventParams, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId, params;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (!(options && options.global)) return [3, 1];
          gtagFunction(GtagCommand.EVENT, eventName, eventParams);
          return [
            2
            /*return*/
          ];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _a7.sent();
          params = __assign(__assign({}, eventParams), { "send_to": measurementId });
          gtagFunction(GtagCommand.EVENT, eventName, params);
          _a7.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setCurrentScreen(gtagFunction, initializationPromise2, screenName, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (!(options && options.global)) return [3, 1];
          gtagFunction(GtagCommand.SET, { "screen_name": screenName });
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _a7.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "screen_name": screenName
          });
          _a7.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setUserId(gtagFunction, initializationPromise2, id, options) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (!(options && options.global)) return [3, 1];
          gtagFunction(GtagCommand.SET, { "user_id": id });
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _a7.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "user_id": id
          });
          _a7.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setUserProperties(gtagFunction, initializationPromise2, properties, options) {
  return __awaiter(this, void 0, void 0, function() {
    var flatProperties, _i, _a7, key, measurementId;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          if (!(options && options.global)) return [3, 1];
          flatProperties = {};
          for (_i = 0, _a7 = Object.keys(properties); _i < _a7.length; _i++) {
            key = _a7[_i];
            flatProperties["user_properties." + key] = properties[key];
          }
          gtagFunction(GtagCommand.SET, flatProperties);
          return [2, Promise.resolve()];
        case 1:
          return [4, initializationPromise2];
        case 2:
          measurementId = _b.sent();
          gtagFunction(GtagCommand.CONFIG, measurementId, {
            update: true,
            "user_properties": properties
          });
          _b.label = 3;
        case 3:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setAnalyticsCollectionEnabled(initializationPromise2, enabled) {
  return __awaiter(this, void 0, void 0, function() {
    var measurementId;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, initializationPromise2];
        case 1:
          measurementId = _a7.sent();
          window["ga-disable-" + measurementId] = !enabled;
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
var logger3 = new Logger("@firebase/analytics");
function insertScriptTag(dataLayerName2, measurementId) {
  var script = document.createElement("script");
  script.src = GTAG_URL + "?l=" + dataLayerName2 + "&id=" + measurementId;
  script.async = true;
  document.head.appendChild(script);
}
function getOrCreateDataLayer(dataLayerName2) {
  var dataLayer = [];
  if (Array.isArray(window[dataLayerName2])) {
    dataLayer = window[dataLayerName2];
  } else {
    window[dataLayerName2] = dataLayer;
  }
  return dataLayer;
}
function gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, measurementId, gtagParams) {
  return __awaiter(this, void 0, void 0, function() {
    var correspondingAppId, dynamicConfigResults, foundConfig, e_1;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          correspondingAppId = measurementIdToAppId2[measurementId];
          _a7.label = 1;
        case 1:
          _a7.trys.push([1, 7, , 8]);
          if (!correspondingAppId) return [3, 3];
          return [4, initializationPromisesMap2[correspondingAppId]];
        case 2:
          _a7.sent();
          return [3, 6];
        case 3:
          return [4, Promise.all(dynamicConfigPromisesList2)];
        case 4:
          dynamicConfigResults = _a7.sent();
          foundConfig = dynamicConfigResults.find(function(config) {
            return config.measurementId === measurementId;
          });
          if (!foundConfig) return [3, 6];
          return [4, initializationPromisesMap2[foundConfig.appId]];
        case 5:
          _a7.sent();
          _a7.label = 6;
        case 6:
          return [3, 8];
        case 7:
          e_1 = _a7.sent();
          logger3.error(e_1);
          return [3, 8];
        case 8:
          gtagCore(GtagCommand.CONFIG, measurementId, gtagParams);
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementId, gtagParams) {
  return __awaiter(this, void 0, void 0, function() {
    var initializationPromisesToWaitFor, gaSendToList, dynamicConfigResults, _loop_1, _i, gaSendToList_1, sendToId, state_1, e_2;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          _a7.trys.push([0, 4, , 5]);
          initializationPromisesToWaitFor = [];
          if (!(gtagParams && gtagParams["send_to"])) return [3, 2];
          gaSendToList = gtagParams["send_to"];
          if (!Array.isArray(gaSendToList)) {
            gaSendToList = [gaSendToList];
          }
          return [4, Promise.all(dynamicConfigPromisesList2)];
        case 1:
          dynamicConfigResults = _a7.sent();
          _loop_1 = function(sendToId2) {
            var foundConfig = dynamicConfigResults.find(function(config) {
              return config.measurementId === sendToId2;
            });
            var initializationPromise2 = foundConfig && initializationPromisesMap2[foundConfig.appId];
            if (initializationPromise2) {
              initializationPromisesToWaitFor.push(initializationPromise2);
            } else {
              initializationPromisesToWaitFor = [];
              return "break";
            }
          };
          for (_i = 0, gaSendToList_1 = gaSendToList; _i < gaSendToList_1.length; _i++) {
            sendToId = gaSendToList_1[_i];
            state_1 = _loop_1(sendToId);
            if (state_1 === "break")
              break;
          }
          _a7.label = 2;
        case 2:
          if (initializationPromisesToWaitFor.length === 0) {
            initializationPromisesToWaitFor = Object.values(initializationPromisesMap2);
          }
          return [4, Promise.all(initializationPromisesToWaitFor)];
        case 3:
          _a7.sent();
          gtagCore(GtagCommand.EVENT, measurementId, gtagParams || {});
          return [3, 5];
        case 4:
          e_2 = _a7.sent();
          logger3.error(e_2);
          return [3, 5];
        case 5:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2) {
  function gtagWrapper(command, idOrNameOrParams, gtagParams) {
    return __awaiter(this, void 0, void 0, function() {
      var e_3;
      return __generator(this, function(_a7) {
        switch (_a7.label) {
          case 0:
            _a7.trys.push([0, 6, , 7]);
            if (!(command === GtagCommand.EVENT)) return [3, 2];
            return [4, gtagOnEvent(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, idOrNameOrParams, gtagParams)];
          case 1:
            _a7.sent();
            return [3, 5];
          case 2:
            if (!(command === GtagCommand.CONFIG)) return [3, 4];
            return [4, gtagOnConfig(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, idOrNameOrParams, gtagParams)];
          case 3:
            _a7.sent();
            return [3, 5];
          case 4:
            gtagCore(GtagCommand.SET, idOrNameOrParams);
            _a7.label = 5;
          case 5:
            return [3, 7];
          case 6:
            e_3 = _a7.sent();
            logger3.error(e_3);
            return [3, 7];
          case 7:
            return [
              2
              /*return*/
            ];
        }
      });
    });
  }
  return gtagWrapper;
}
function wrapOrCreateGtag(initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2, dataLayerName2, gtagFunctionName) {
  var gtagCore = function() {
    var _args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      _args[_i] = arguments[_i];
    }
    window[dataLayerName2].push(arguments);
  };
  if (window[gtagFunctionName] && typeof window[gtagFunctionName] === "function") {
    gtagCore = window[gtagFunctionName];
  }
  window[gtagFunctionName] = wrapGtag(gtagCore, initializationPromisesMap2, dynamicConfigPromisesList2, measurementIdToAppId2);
  return {
    gtagCore,
    wrappedGtag: window[gtagFunctionName]
  };
}
function findGtagScriptOnPage() {
  var scriptTags = window.document.getElementsByTagName("script");
  for (var _i = 0, _a7 = Object.values(scriptTags); _i < _a7.length; _i++) {
    var tag = _a7[_i];
    if (tag.src && tag.src.includes(GTAG_URL)) {
      return tag;
    }
  }
  return null;
}
var _a4;
var ERRORS = (_a4 = {}, _a4[
  "already-exists"
  /* ALREADY_EXISTS */
] = "A Firebase Analytics instance with the appId {$id}  already exists. Only one Firebase Analytics instance can be created for each appId.", _a4[
  "already-initialized"
  /* ALREADY_INITIALIZED */
] = "Firebase Analytics has already been initialized.settings() must be called before initializing any Analytics instanceor it will have no effect.", _a4[
  "interop-component-reg-failed"
  /* INTEROP_COMPONENT_REG_FAILED */
] = "Firebase Analytics Interop Component failed to instantiate: {$reason}", _a4[
  "invalid-analytics-context"
  /* INVALID_ANALYTICS_CONTEXT */
] = "Firebase Analytics is not supported in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", _a4[
  "indexeddb-unavailable"
  /* INDEXEDDB_UNAVAILABLE */
] = "IndexedDB unavailable or restricted in this environment. Wrap initialization of analytics in analytics.isSupported() to prevent initialization in unsupported environments. Details: {$errorInfo}", _a4[
  "fetch-throttle"
  /* FETCH_THROTTLE */
] = "The config fetch request timed out while in an exponential backoff state. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.", _a4[
  "config-fetch-failed"
  /* CONFIG_FETCH_FAILED */
] = "Dynamic config fetch failed: [{$httpStatus}] {$responseMessage}", _a4[
  "no-api-key"
  /* NO_API_KEY */
] = 'The "apiKey" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid API key.', _a4[
  "no-app-id"
  /* NO_APP_ID */
] = 'The "appId" field is empty in the local Firebase config. Firebase Analytics requires this field tocontain a valid app ID.', _a4);
var ERROR_FACTORY4 = new ErrorFactory("analytics", "Analytics", ERRORS);
var LONG_RETRY_FACTOR = 30;
var BASE_INTERVAL_MILLIS = 1e3;
var RetryData = (
  /** @class */
  function() {
    function RetryData2(throttleMetadata, intervalMillis) {
      if (throttleMetadata === void 0) {
        throttleMetadata = {};
      }
      if (intervalMillis === void 0) {
        intervalMillis = BASE_INTERVAL_MILLIS;
      }
      this.throttleMetadata = throttleMetadata;
      this.intervalMillis = intervalMillis;
    }
    RetryData2.prototype.getThrottleMetadata = function(appId) {
      return this.throttleMetadata[appId];
    };
    RetryData2.prototype.setThrottleMetadata = function(appId, metadata) {
      this.throttleMetadata[appId] = metadata;
    };
    RetryData2.prototype.deleteThrottleMetadata = function(appId) {
      delete this.throttleMetadata[appId];
    };
    return RetryData2;
  }()
);
var defaultRetryData = new RetryData();
function getHeaders3(apiKey) {
  return new Headers({
    Accept: "application/json",
    "x-goog-api-key": apiKey
  });
}
function fetchDynamicConfig(appFields) {
  var _a7;
  return __awaiter(this, void 0, void 0, function() {
    var appId, apiKey, request, appUrl, response, errorMessage, jsonResponse;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          appId = appFields.appId, apiKey = appFields.apiKey;
          request = {
            method: "GET",
            headers: getHeaders3(apiKey)
          };
          appUrl = DYNAMIC_CONFIG_URL.replace("{app-id}", appId);
          return [4, fetch(appUrl, request)];
        case 1:
          response = _b.sent();
          if (!(response.status !== 200 && response.status !== 304)) return [3, 6];
          errorMessage = "";
          _b.label = 2;
        case 2:
          _b.trys.push([2, 4, , 5]);
          return [4, response.json()];
        case 3:
          jsonResponse = _b.sent();
          if ((_a7 = jsonResponse.error) === null || _a7 === void 0 ? void 0 : _a7.message) {
            errorMessage = jsonResponse.error.message;
          }
          return [3, 5];
        case 4:
          _b.sent();
          return [3, 5];
        case 5:
          throw ERROR_FACTORY4.create("config-fetch-failed", {
            httpStatus: response.status,
            responseMessage: errorMessage
          });
        case 6:
          return [2, response.json()];
      }
    });
  });
}
function fetchDynamicConfigWithRetry(app, retryData, timeoutMillis) {
  if (retryData === void 0) {
    retryData = defaultRetryData;
  }
  return __awaiter(this, void 0, void 0, function() {
    var _a7, appId, apiKey, measurementId, throttleMetadata, signal;
    var _this = this;
    return __generator(this, function(_b) {
      _a7 = app.options, appId = _a7.appId, apiKey = _a7.apiKey, measurementId = _a7.measurementId;
      if (!appId) {
        throw ERROR_FACTORY4.create(
          "no-app-id"
          /* NO_APP_ID */
        );
      }
      if (!apiKey) {
        if (measurementId) {
          return [2, {
            measurementId,
            appId
          }];
        }
        throw ERROR_FACTORY4.create(
          "no-api-key"
          /* NO_API_KEY */
        );
      }
      throttleMetadata = retryData.getThrottleMetadata(appId) || {
        backoffCount: 0,
        throttleEndTimeMillis: Date.now()
      };
      signal = new AnalyticsAbortSignal();
      setTimeout(function() {
        return __awaiter(_this, void 0, void 0, function() {
          return __generator(this, function(_a8) {
            signal.abort();
            return [
              2
              /*return*/
            ];
          });
        });
      }, timeoutMillis !== void 0 ? timeoutMillis : FETCH_TIMEOUT_MILLIS);
      return [2, attemptFetchDynamicConfigWithRetry({ appId, apiKey, measurementId }, throttleMetadata, signal, retryData)];
    });
  });
}
function attemptFetchDynamicConfigWithRetry(appFields, _a7, signal, retryData) {
  var throttleEndTimeMillis = _a7.throttleEndTimeMillis, backoffCount = _a7.backoffCount;
  if (retryData === void 0) {
    retryData = defaultRetryData;
  }
  return __awaiter(this, void 0, void 0, function() {
    var appId, measurementId, e_1, response, e_2, backoffMillis, throttleMetadata;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          appId = appFields.appId, measurementId = appFields.measurementId;
          _b.label = 1;
        case 1:
          _b.trys.push([1, 3, , 4]);
          return [4, setAbortableTimeout(signal, throttleEndTimeMillis)];
        case 2:
          _b.sent();
          return [3, 4];
        case 3:
          e_1 = _b.sent();
          if (measurementId) {
            logger3.warn("Timed out fetching this Firebase app's measurement ID from the server." + (" Falling back to the measurement ID " + measurementId) + (' provided in the "measurementId" field in the local Firebase config. [' + e_1.message + "]"));
            return [2, { appId, measurementId }];
          }
          throw e_1;
        case 4:
          _b.trys.push([4, 6, , 7]);
          return [4, fetchDynamicConfig(appFields)];
        case 5:
          response = _b.sent();
          retryData.deleteThrottleMetadata(appId);
          return [2, response];
        case 6:
          e_2 = _b.sent();
          if (!isRetriableError(e_2)) {
            retryData.deleteThrottleMetadata(appId);
            if (measurementId) {
              logger3.warn("Failed to fetch this Firebase app's measurement ID from the server." + (" Falling back to the measurement ID " + measurementId) + (' provided in the "measurementId" field in the local Firebase config. [' + e_2.message + "]"));
              return [2, { appId, measurementId }];
            } else {
              throw e_2;
            }
          }
          backoffMillis = Number(e_2.customData.httpStatus) === 503 ? calculateBackoffMillis(backoffCount, retryData.intervalMillis, LONG_RETRY_FACTOR) : calculateBackoffMillis(backoffCount, retryData.intervalMillis);
          throttleMetadata = {
            throttleEndTimeMillis: Date.now() + backoffMillis,
            backoffCount: backoffCount + 1
          };
          retryData.setThrottleMetadata(appId, throttleMetadata);
          logger3.debug("Calling attemptFetch again in " + backoffMillis + " millis");
          return [2, attemptFetchDynamicConfigWithRetry(appFields, throttleMetadata, signal, retryData)];
        case 7:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}
function setAbortableTimeout(signal, throttleEndTimeMillis) {
  return new Promise(function(resolve, reject) {
    var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    var timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(function() {
      clearTimeout(timeout);
      reject(ERROR_FACTORY4.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  var httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var AnalyticsAbortSignal = (
  /** @class */
  function() {
    function AnalyticsAbortSignal2() {
      this.listeners = [];
    }
    AnalyticsAbortSignal2.prototype.addEventListener = function(listener) {
      this.listeners.push(listener);
    };
    AnalyticsAbortSignal2.prototype.abort = function() {
      this.listeners.forEach(function(listener) {
        return listener();
      });
    };
    return AnalyticsAbortSignal2;
  }()
);
function validateIndexedDB() {
  return __awaiter(this, void 0, void 0, function() {
    var e_1;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (!!isIndexedDBAvailable()) return [3, 1];
          logger3.warn(ERROR_FACTORY4.create("indexeddb-unavailable", {
            errorInfo: "IndexedDB is not available in this environment."
          }).message);
          return [2, false];
        case 1:
          _a7.trys.push([1, 3, , 4]);
          return [4, validateIndexedDBOpenable()];
        case 2:
          _a7.sent();
          return [3, 4];
        case 3:
          e_1 = _a7.sent();
          logger3.warn(ERROR_FACTORY4.create("indexeddb-unavailable", {
            errorInfo: e_1
          }).message);
          return [2, false];
        case 4:
          return [2, true];
      }
    });
  });
}
function initializeIds(app, dynamicConfigPromisesList2, measurementIdToAppId2, installations, gtagCore, dataLayerName2) {
  return __awaiter(this, void 0, void 0, function() {
    var dynamicConfigPromise, fidPromise, _a7, dynamicConfig, fid, configProperties;
    var _b;
    return __generator(this, function(_c) {
      switch (_c.label) {
        case 0:
          dynamicConfigPromise = fetchDynamicConfigWithRetry(app);
          dynamicConfigPromise.then(function(config) {
            measurementIdToAppId2[config.measurementId] = config.appId;
            if (app.options.measurementId && config.measurementId !== app.options.measurementId) {
              logger3.warn("The measurement ID in the local Firebase config (" + app.options.measurementId + ")" + (" does not match the measurement ID fetched from the server (" + config.measurementId + ").") + " To ensure analytics events are always sent to the correct Analytics property, update the measurement ID field in the local config or remove it from the local config.");
            }
          }).catch(function(e) {
            return logger3.error(e);
          });
          dynamicConfigPromisesList2.push(dynamicConfigPromise);
          fidPromise = validateIndexedDB().then(function(envIsValid) {
            if (envIsValid) {
              return installations.getId();
            } else {
              return void 0;
            }
          });
          return [4, Promise.all([
            dynamicConfigPromise,
            fidPromise
          ])];
        case 1:
          _a7 = _c.sent(), dynamicConfig = _a7[0], fid = _a7[1];
          if (!findGtagScriptOnPage()) {
            insertScriptTag(dataLayerName2, dynamicConfig.measurementId);
          }
          gtagCore("js", /* @__PURE__ */ new Date());
          configProperties = (_b = {}, // guard against developers accidentally setting properties with prefix `firebase_`
          _b[ORIGIN_KEY] = "firebase", _b.update = true, _b);
          if (fid != null) {
            configProperties[GA_FID_KEY] = fid;
          }
          gtagCore(GtagCommand.CONFIG, dynamicConfig.measurementId, configProperties);
          return [2, dynamicConfig.measurementId];
      }
    });
  });
}
var initializationPromisesMap = {};
var dynamicConfigPromisesList = [];
var measurementIdToAppId = {};
var dataLayerName = "dataLayer";
var gtagName = "gtag";
var gtagCoreFunction;
var wrappedGtagFunction;
var globalInitDone = false;
function settings(options) {
  if (globalInitDone) {
    throw ERROR_FACTORY4.create(
      "already-initialized"
      /* ALREADY_INITIALIZED */
    );
  }
  if (options.dataLayerName) {
    dataLayerName = options.dataLayerName;
  }
  if (options.gtagName) {
    gtagName = options.gtagName;
  }
}
function warnOnBrowserContextMismatch() {
  var mismatchedEnvMessages = [];
  if (isBrowserExtension()) {
    mismatchedEnvMessages.push("This is a browser extension environment.");
  }
  if (!areCookiesEnabled()) {
    mismatchedEnvMessages.push("Cookies are not available.");
  }
  if (mismatchedEnvMessages.length > 0) {
    var details = mismatchedEnvMessages.map(function(message, index) {
      return "(" + (index + 1) + ") " + message;
    }).join(" ");
    var err = ERROR_FACTORY4.create("invalid-analytics-context", {
      errorInfo: details
    });
    logger3.warn(err.message);
  }
}
function factory2(app, installations) {
  warnOnBrowserContextMismatch();
  var appId = app.options.appId;
  if (!appId) {
    throw ERROR_FACTORY4.create(
      "no-app-id"
      /* NO_APP_ID */
    );
  }
  if (!app.options.apiKey) {
    if (app.options.measurementId) {
      logger3.warn('The "apiKey" field is empty in the local Firebase config. This is needed to fetch the latest' + (" measurement ID for this Firebase app. Falling back to the measurement ID " + app.options.measurementId) + ' provided in the "measurementId" field in the local Firebase config.');
    } else {
      throw ERROR_FACTORY4.create(
        "no-api-key"
        /* NO_API_KEY */
      );
    }
  }
  if (initializationPromisesMap[appId] != null) {
    throw ERROR_FACTORY4.create("already-exists", {
      id: appId
    });
  }
  if (!globalInitDone) {
    getOrCreateDataLayer(dataLayerName);
    var _a7 = wrapOrCreateGtag(initializationPromisesMap, dynamicConfigPromisesList, measurementIdToAppId, dataLayerName, gtagName), wrappedGtag = _a7.wrappedGtag, gtagCore = _a7.gtagCore;
    wrappedGtagFunction = wrappedGtag;
    gtagCoreFunction = gtagCore;
    globalInitDone = true;
  }
  initializationPromisesMap[appId] = initializeIds(app, dynamicConfigPromisesList, measurementIdToAppId, installations, gtagCoreFunction, dataLayerName);
  var analyticsInstance = {
    app,
    // Public methods return void for API simplicity and to better match gtag,
    // while internal implementations return promises.
    logEvent: function(eventName, eventParams, options) {
      logEvent(wrappedGtagFunction, initializationPromisesMap[appId], eventName, eventParams, options).catch(function(e) {
        return logger3.error(e);
      });
    },
    setCurrentScreen: function(screenName, options) {
      setCurrentScreen(wrappedGtagFunction, initializationPromisesMap[appId], screenName, options).catch(function(e) {
        return logger3.error(e);
      });
    },
    setUserId: function(id, options) {
      setUserId(wrappedGtagFunction, initializationPromisesMap[appId], id, options).catch(function(e) {
        return logger3.error(e);
      });
    },
    setUserProperties: function(properties, options) {
      setUserProperties(wrappedGtagFunction, initializationPromisesMap[appId], properties, options).catch(function(e) {
        return logger3.error(e);
      });
    },
    setAnalyticsCollectionEnabled: function(enabled) {
      setAnalyticsCollectionEnabled(initializationPromisesMap[appId], enabled).catch(function(e) {
        return logger3.error(e);
      });
    },
    INTERNAL: {
      delete: function() {
        delete initializationPromisesMap[appId];
        return Promise.resolve();
      }
    }
  };
  return analyticsInstance;
}
var name6 = "@firebase/analytics";
var version6 = "0.6.18";
var ANALYTICS_TYPE = "analytics";
function registerAnalytics(instance) {
  instance.INTERNAL.registerComponent(new Component(
    ANALYTICS_TYPE,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var installations = container.getProvider("installations").getImmediate();
      return factory2(app, installations);
    },
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps({
    settings,
    EventName,
    isSupported: isSupported2
  }));
  instance.INTERNAL.registerComponent(new Component(
    "analytics-internal",
    internalFactory2,
    "PRIVATE"
    /* PRIVATE */
  ));
  instance.registerVersion(name6, version6);
  function internalFactory2(container) {
    try {
      var analytics = container.getProvider(ANALYTICS_TYPE).getImmediate();
      return {
        logEvent: analytics.logEvent
      };
    } catch (e) {
      throw ERROR_FACTORY4.create("interop-component-reg-failed", {
        reason: e
      });
    }
  }
}
registerAnalytics(index_esm_default);
function isSupported2() {
  return __awaiter(this, void 0, void 0, function() {
    var isDBOpenable;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (isBrowserExtension()) {
            return [2, false];
          }
          if (!areCookiesEnabled()) {
            return [2, false];
          }
          if (!isIndexedDBAvailable()) {
            return [2, false];
          }
          _a7.label = 1;
        case 1:
          _a7.trys.push([1, 3, , 4]);
          return [4, validateIndexedDBOpenable()];
        case 2:
          isDBOpenable = _a7.sent();
          return [2, isDBOpenable];
        case 3:
          _a7.sent();
          return [2, false];
        case 4:
          return [
            2
            /*return*/
          ];
      }
    });
  });
}

// node_modules/@firebase/remote-config/dist/index.esm.js
var CachingClient = (
  /** @class */
  function() {
    function CachingClient2(client, storage, storageCache, logger5) {
      this.client = client;
      this.storage = storage;
      this.storageCache = storageCache;
      this.logger = logger5;
    }
    CachingClient2.prototype.isCachedDataFresh = function(cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis) {
      if (!lastSuccessfulFetchTimestampMillis) {
        this.logger.debug("Config fetch cache check. Cache unpopulated.");
        return false;
      }
      var cacheAgeMillis = Date.now() - lastSuccessfulFetchTimestampMillis;
      var isCachedDataFresh = cacheAgeMillis <= cacheMaxAgeMillis;
      this.logger.debug("Config fetch cache check." + (" Cache age millis: " + cacheAgeMillis + ".") + (" Cache max age millis (minimumFetchIntervalMillis setting): " + cacheMaxAgeMillis + ".") + (" Is cache hit: " + isCachedDataFresh + "."));
      return isCachedDataFresh;
    };
    CachingClient2.prototype.fetch = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var _a7, lastSuccessfulFetchTimestampMillis, lastSuccessfulFetchResponse, response, storageOperations;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this.storage.getLastSuccessfulFetchTimestampMillis(),
                this.storage.getLastSuccessfulFetchResponse()
              ])];
            case 1:
              _a7 = _b.sent(), lastSuccessfulFetchTimestampMillis = _a7[0], lastSuccessfulFetchResponse = _a7[1];
              if (lastSuccessfulFetchResponse && this.isCachedDataFresh(request.cacheMaxAgeMillis, lastSuccessfulFetchTimestampMillis)) {
                return [2, lastSuccessfulFetchResponse];
              }
              request.eTag = lastSuccessfulFetchResponse && lastSuccessfulFetchResponse.eTag;
              return [4, this.client.fetch(request)];
            case 2:
              response = _b.sent();
              storageOperations = [
                // Uses write-through cache for consistency with synchronous public API.
                this.storageCache.setLastSuccessfulFetchTimestampMillis(Date.now())
              ];
              if (response.status === 200) {
                storageOperations.push(this.storage.setLastSuccessfulFetchResponse(response));
              }
              return [4, Promise.all(storageOperations)];
            case 3:
              _b.sent();
              return [2, response];
          }
        });
      });
    };
    return CachingClient2;
  }()
);
var _a5;
var ERROR_DESCRIPTION_MAP3 = (_a5 = {}, _a5[
  "registration-window"
  /* REGISTRATION_WINDOW */
] = "Undefined window object. This SDK only supports usage in a browser environment.", _a5[
  "registration-project-id"
  /* REGISTRATION_PROJECT_ID */
] = "Undefined project identifier. Check Firebase app initialization.", _a5[
  "registration-api-key"
  /* REGISTRATION_API_KEY */
] = "Undefined API key. Check Firebase app initialization.", _a5[
  "registration-app-id"
  /* REGISTRATION_APP_ID */
] = "Undefined app identifier. Check Firebase app initialization.", _a5[
  "storage-open"
  /* STORAGE_OPEN */
] = "Error thrown when opening storage. Original error: {$originalErrorMessage}.", _a5[
  "storage-get"
  /* STORAGE_GET */
] = "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", _a5[
  "storage-set"
  /* STORAGE_SET */
] = "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", _a5[
  "storage-delete"
  /* STORAGE_DELETE */
] = "Error thrown when deleting from storage. Original error: {$originalErrorMessage}.", _a5[
  "fetch-client-network"
  /* FETCH_NETWORK */
] = "Fetch client failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", _a5[
  "fetch-timeout"
  /* FETCH_TIMEOUT */
] = 'The config fetch request timed out.  Configure timeout using "fetchTimeoutMillis" SDK setting.', _a5[
  "fetch-throttle"
  /* FETCH_THROTTLE */
] = 'The config fetch request timed out while in an exponential backoff state. Configure timeout using "fetchTimeoutMillis" SDK setting. Unix timestamp in milliseconds when fetch request throttling ends: {$throttleEndTimeMillis}.', _a5[
  "fetch-client-parse"
  /* FETCH_PARSE */
] = "Fetch client could not parse response. Original error: {$originalErrorMessage}.", _a5[
  "fetch-status"
  /* FETCH_STATUS */
] = "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", _a5);
var ERROR_FACTORY5 = new ErrorFactory("remoteconfig", "Remote Config", ERROR_DESCRIPTION_MAP3);
function hasErrorCode(e, errorCode) {
  return e instanceof FirebaseError && e.code.indexOf(errorCode) !== -1;
}
function getUserLanguage(navigatorLanguage) {
  if (navigatorLanguage === void 0) {
    navigatorLanguage = navigator;
  }
  return (
    // Most reliable, but only supported in Chrome/Firefox.
    navigatorLanguage.languages && navigatorLanguage.languages[0] || // Supported in most browsers, but returns the language of the browser
    // UI, not the language set in browser settings.
    navigatorLanguage.language
  );
}
var RestClient = (
  /** @class */
  function() {
    function RestClient2(firebaseInstallations, sdkVersion, namespace, projectId, apiKey, appId) {
      this.firebaseInstallations = firebaseInstallations;
      this.sdkVersion = sdkVersion;
      this.namespace = namespace;
      this.projectId = projectId;
      this.apiKey = apiKey;
      this.appId = appId;
    }
    RestClient2.prototype.fetch = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var _a7, installationId, installationToken, urlBase, url, headers, requestBody, options, fetchPromise, timeoutPromise, response, originalError_1, errorCode, status, responseEtag, config, state, responseBody, originalError_2;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this.firebaseInstallations.getId(),
                this.firebaseInstallations.getToken()
              ])];
            case 1:
              _a7 = _b.sent(), installationId = _a7[0], installationToken = _a7[1];
              urlBase = window.FIREBASE_REMOTE_CONFIG_URL_BASE || "https://firebaseremoteconfig.googleapis.com";
              url = urlBase + "/v1/projects/" + this.projectId + "/namespaces/" + this.namespace + ":fetch?key=" + this.apiKey;
              headers = {
                "Content-Type": "application/json",
                "Content-Encoding": "gzip",
                // Deviates from pure decorator by not passing max-age header since we don't currently have
                // service behavior using that header.
                "If-None-Match": request.eTag || "*"
              };
              requestBody = {
                /* eslint-disable camelcase */
                sdk_version: this.sdkVersion,
                app_instance_id: installationId,
                app_instance_id_token: installationToken,
                app_id: this.appId,
                language_code: getUserLanguage()
                /* eslint-enable camelcase */
              };
              options = {
                method: "POST",
                headers,
                body: JSON.stringify(requestBody)
              };
              fetchPromise = fetch(url, options);
              timeoutPromise = new Promise(function(_resolve, reject) {
                request.signal.addEventListener(function() {
                  var error2 = new Error("The operation was aborted.");
                  error2.name = "AbortError";
                  reject(error2);
                });
              });
              _b.label = 2;
            case 2:
              _b.trys.push([2, 5, , 6]);
              return [4, Promise.race([fetchPromise, timeoutPromise])];
            case 3:
              _b.sent();
              return [4, fetchPromise];
            case 4:
              response = _b.sent();
              return [3, 6];
            case 5:
              originalError_1 = _b.sent();
              errorCode = "fetch-client-network";
              if (originalError_1.name === "AbortError") {
                errorCode = "fetch-timeout";
              }
              throw ERROR_FACTORY5.create(errorCode, {
                originalErrorMessage: originalError_1.message
              });
            case 6:
              status = response.status;
              responseEtag = response.headers.get("ETag") || void 0;
              if (!(response.status === 200)) return [3, 11];
              responseBody = void 0;
              _b.label = 7;
            case 7:
              _b.trys.push([7, 9, , 10]);
              return [4, response.json()];
            case 8:
              responseBody = _b.sent();
              return [3, 10];
            case 9:
              originalError_2 = _b.sent();
              throw ERROR_FACTORY5.create("fetch-client-parse", {
                originalErrorMessage: originalError_2.message
              });
            case 10:
              config = responseBody["entries"];
              state = responseBody["state"];
              _b.label = 11;
            case 11:
              if (state === "INSTANCE_STATE_UNSPECIFIED") {
                status = 500;
              } else if (state === "NO_CHANGE") {
                status = 304;
              } else if (state === "NO_TEMPLATE" || state === "EMPTY_CONFIG") {
                config = {};
              }
              if (status !== 304 && status !== 200) {
                throw ERROR_FACTORY5.create("fetch-status", {
                  httpStatus: status
                });
              }
              return [2, { status, eTag: responseEtag, config }];
          }
        });
      });
    };
    return RestClient2;
  }()
);
var RemoteConfigAbortSignal = (
  /** @class */
  function() {
    function RemoteConfigAbortSignal2() {
      this.listeners = [];
    }
    RemoteConfigAbortSignal2.prototype.addEventListener = function(listener) {
      this.listeners.push(listener);
    };
    RemoteConfigAbortSignal2.prototype.abort = function() {
      this.listeners.forEach(function(listener) {
        return listener();
      });
    };
    return RemoteConfigAbortSignal2;
  }()
);
var DEFAULT_VALUE_FOR_BOOLEAN = false;
var DEFAULT_VALUE_FOR_STRING = "";
var DEFAULT_VALUE_FOR_NUMBER = 0;
var BOOLEAN_TRUTHY_VALUES = ["1", "true", "t", "yes", "y", "on"];
var Value = (
  /** @class */
  function() {
    function Value2(_source, _value) {
      if (_value === void 0) {
        _value = DEFAULT_VALUE_FOR_STRING;
      }
      this._source = _source;
      this._value = _value;
    }
    Value2.prototype.asString = function() {
      return this._value;
    };
    Value2.prototype.asBoolean = function() {
      if (this._source === "static") {
        return DEFAULT_VALUE_FOR_BOOLEAN;
      }
      return BOOLEAN_TRUTHY_VALUES.indexOf(this._value.toLowerCase()) >= 0;
    };
    Value2.prototype.asNumber = function() {
      if (this._source === "static") {
        return DEFAULT_VALUE_FOR_NUMBER;
      }
      var num = Number(this._value);
      if (isNaN(num)) {
        num = DEFAULT_VALUE_FOR_NUMBER;
      }
      return num;
    };
    Value2.prototype.getSource = function() {
      return this._source;
    };
    return Value2;
  }()
);
var DEFAULT_FETCH_TIMEOUT_MILLIS = 60 * 1e3;
var DEFAULT_CACHE_MAX_AGE_MILLIS = 12 * 60 * 60 * 1e3;
var RemoteConfig = (
  /** @class */
  function() {
    function RemoteConfig2(app, _client, _storageCache, _storage, _logger) {
      this.app = app;
      this._client = _client;
      this._storageCache = _storageCache;
      this._storage = _storage;
      this._logger = _logger;
      this._isInitializationComplete = false;
      this.settings = {
        fetchTimeoutMillis: DEFAULT_FETCH_TIMEOUT_MILLIS,
        minimumFetchIntervalMillis: DEFAULT_CACHE_MAX_AGE_MILLIS
      };
      this.defaultConfig = {};
    }
    RemoteConfig2.prototype.setLogLevel = function(logLevel) {
      switch (logLevel) {
        case "debug":
          this._logger.logLevel = LogLevel.DEBUG;
          break;
        case "silent":
          this._logger.logLevel = LogLevel.SILENT;
          break;
        default:
          this._logger.logLevel = LogLevel.ERROR;
      }
    };
    Object.defineProperty(RemoteConfig2.prototype, "fetchTimeMillis", {
      get: function() {
        return this._storageCache.getLastSuccessfulFetchTimestampMillis() || -1;
      },
      enumerable: false,
      configurable: true
    });
    Object.defineProperty(RemoteConfig2.prototype, "lastFetchStatus", {
      get: function() {
        return this._storageCache.getLastFetchStatus() || "no-fetch-yet";
      },
      enumerable: false,
      configurable: true
    });
    RemoteConfig2.prototype.activate = function() {
      return __awaiter(this, void 0, void 0, function() {
        var _a7, lastSuccessfulFetchResponse, activeConfigEtag;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, Promise.all([
                this._storage.getLastSuccessfulFetchResponse(),
                this._storage.getActiveConfigEtag()
              ])];
            case 1:
              _a7 = _b.sent(), lastSuccessfulFetchResponse = _a7[0], activeConfigEtag = _a7[1];
              if (!lastSuccessfulFetchResponse || !lastSuccessfulFetchResponse.config || !lastSuccessfulFetchResponse.eTag || lastSuccessfulFetchResponse.eTag === activeConfigEtag) {
                return [2, false];
              }
              return [4, Promise.all([
                this._storageCache.setActiveConfig(lastSuccessfulFetchResponse.config),
                this._storage.setActiveConfigEtag(lastSuccessfulFetchResponse.eTag)
              ])];
            case 2:
              _b.sent();
              return [2, true];
          }
        });
      });
    };
    RemoteConfig2.prototype.ensureInitialized = function() {
      var _this = this;
      if (!this._initializePromise) {
        this._initializePromise = this._storageCache.loadFromStorage().then(function() {
          _this._isInitializationComplete = true;
        });
      }
      return this._initializePromise;
    };
    RemoteConfig2.prototype.fetch = function() {
      return __awaiter(this, void 0, void 0, function() {
        var abortSignal, e_1, lastFetchStatus;
        var _this = this;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              abortSignal = new RemoteConfigAbortSignal();
              setTimeout(function() {
                return __awaiter(_this, void 0, void 0, function() {
                  return __generator(this, function(_a8) {
                    abortSignal.abort();
                    return [
                      2
                      /*return*/
                    ];
                  });
                });
              }, this.settings.fetchTimeoutMillis);
              _a7.label = 1;
            case 1:
              _a7.trys.push([1, 4, , 6]);
              return [4, this._client.fetch({
                cacheMaxAgeMillis: this.settings.minimumFetchIntervalMillis,
                signal: abortSignal
              })];
            case 2:
              _a7.sent();
              return [4, this._storageCache.setLastFetchStatus("success")];
            case 3:
              _a7.sent();
              return [3, 6];
            case 4:
              e_1 = _a7.sent();
              lastFetchStatus = hasErrorCode(
                e_1,
                "fetch-throttle"
                /* FETCH_THROTTLE */
              ) ? "throttle" : "failure";
              return [4, this._storageCache.setLastFetchStatus(lastFetchStatus)];
            case 5:
              _a7.sent();
              throw e_1;
            case 6:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    RemoteConfig2.prototype.fetchAndActivate = function() {
      return __awaiter(this, void 0, void 0, function() {
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              return [4, this.fetch()];
            case 1:
              _a7.sent();
              return [2, this.activate()];
          }
        });
      });
    };
    RemoteConfig2.prototype.getAll = function() {
      var _this = this;
      return getAllKeys(this._storageCache.getActiveConfig(), this.defaultConfig).reduce(function(allConfigs, key) {
        allConfigs[key] = _this.getValue(key);
        return allConfigs;
      }, {});
    };
    RemoteConfig2.prototype.getBoolean = function(key) {
      return this.getValue(key).asBoolean();
    };
    RemoteConfig2.prototype.getNumber = function(key) {
      return this.getValue(key).asNumber();
    };
    RemoteConfig2.prototype.getString = function(key) {
      return this.getValue(key).asString();
    };
    RemoteConfig2.prototype.getValue = function(key) {
      if (!this._isInitializationComplete) {
        this._logger.debug('A value was requested for key "' + key + '" before SDK initialization completed. Await on ensureInitialized if the intent was to get a previously activated value.');
      }
      var activeConfig = this._storageCache.getActiveConfig();
      if (activeConfig && activeConfig[key] !== void 0) {
        return new Value("remote", activeConfig[key]);
      } else if (this.defaultConfig && this.defaultConfig[key] !== void 0) {
        return new Value("default", String(this.defaultConfig[key]));
      }
      this._logger.debug('Returning static value for key "' + key + '". Define a default or remote value if this is unintentional.');
      return new Value("static");
    };
    return RemoteConfig2;
  }()
);
function getAllKeys(obj1, obj2) {
  if (obj1 === void 0) {
    obj1 = {};
  }
  if (obj2 === void 0) {
    obj2 = {};
  }
  return Object.keys(__assign(__assign({}, obj1), obj2));
}
function toFirebaseError(event, errorCode) {
  var originalError = event.target.error || void 0;
  return ERROR_FACTORY5.create(errorCode, {
    originalErrorMessage: originalError && originalError.message
  });
}
var APP_NAMESPACE_STORE = "app_namespace_store";
var DB_NAME = "firebase_remote_config";
var DB_VERSION = 1;
function openDatabase() {
  return new Promise(function(resolve, reject) {
    var request = indexedDB.open(DB_NAME, DB_VERSION);
    request.onerror = function(event) {
      reject(toFirebaseError(
        event,
        "storage-open"
        /* STORAGE_OPEN */
      ));
    };
    request.onsuccess = function(event) {
      resolve(event.target.result);
    };
    request.onupgradeneeded = function(event) {
      var db = event.target.result;
      switch (event.oldVersion) {
        case 0:
          db.createObjectStore(APP_NAMESPACE_STORE, {
            keyPath: "compositeKey"
          });
      }
    };
  });
}
var Storage = (
  /** @class */
  function() {
    function Storage2(appId, appName, namespace, openDbPromise) {
      if (openDbPromise === void 0) {
        openDbPromise = openDatabase();
      }
      this.appId = appId;
      this.appName = appName;
      this.namespace = namespace;
      this.openDbPromise = openDbPromise;
    }
    Storage2.prototype.getLastFetchStatus = function() {
      return this.get("last_fetch_status");
    };
    Storage2.prototype.setLastFetchStatus = function(status) {
      return this.set("last_fetch_status", status);
    };
    Storage2.prototype.getLastSuccessfulFetchTimestampMillis = function() {
      return this.get("last_successful_fetch_timestamp_millis");
    };
    Storage2.prototype.setLastSuccessfulFetchTimestampMillis = function(timestamp) {
      return this.set("last_successful_fetch_timestamp_millis", timestamp);
    };
    Storage2.prototype.getLastSuccessfulFetchResponse = function() {
      return this.get("last_successful_fetch_response");
    };
    Storage2.prototype.setLastSuccessfulFetchResponse = function(response) {
      return this.set("last_successful_fetch_response", response);
    };
    Storage2.prototype.getActiveConfig = function() {
      return this.get("active_config");
    };
    Storage2.prototype.setActiveConfig = function(config) {
      return this.set("active_config", config);
    };
    Storage2.prototype.getActiveConfigEtag = function() {
      return this.get("active_config_etag");
    };
    Storage2.prototype.setActiveConfigEtag = function(etag) {
      return this.set("active_config_etag", etag);
    };
    Storage2.prototype.getThrottleMetadata = function() {
      return this.get("throttle_metadata");
    };
    Storage2.prototype.setThrottleMetadata = function(metadata) {
      return this.set("throttle_metadata", metadata);
    };
    Storage2.prototype.deleteThrottleMetadata = function() {
      return this.delete("throttle_metadata");
    };
    Storage2.prototype.get = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var db;
        var _this = this;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              return [4, this.openDbPromise];
            case 1:
              db = _a7.sent();
              return [2, new Promise(function(resolve, reject) {
                var transaction = db.transaction([APP_NAMESPACE_STORE], "readonly");
                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
                var compositeKey = _this.createCompositeKey(key);
                try {
                  var request = objectStore.get(compositeKey);
                  request.onerror = function(event) {
                    reject(toFirebaseError(
                      event,
                      "storage-get"
                      /* STORAGE_GET */
                    ));
                  };
                  request.onsuccess = function(event) {
                    var result = event.target.result;
                    if (result) {
                      resolve(result.value);
                    } else {
                      resolve(void 0);
                    }
                  };
                } catch (e) {
                  reject(ERROR_FACTORY5.create("storage-get", {
                    originalErrorMessage: e && e.message
                  }));
                }
              })];
          }
        });
      });
    };
    Storage2.prototype.set = function(key, value) {
      return __awaiter(this, void 0, void 0, function() {
        var db;
        var _this = this;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              return [4, this.openDbPromise];
            case 1:
              db = _a7.sent();
              return [2, new Promise(function(resolve, reject) {
                var transaction = db.transaction([APP_NAMESPACE_STORE], "readwrite");
                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
                var compositeKey = _this.createCompositeKey(key);
                try {
                  var request = objectStore.put({
                    compositeKey,
                    value
                  });
                  request.onerror = function(event) {
                    reject(toFirebaseError(
                      event,
                      "storage-set"
                      /* STORAGE_SET */
                    ));
                  };
                  request.onsuccess = function() {
                    resolve();
                  };
                } catch (e) {
                  reject(ERROR_FACTORY5.create("storage-set", {
                    originalErrorMessage: e && e.message
                  }));
                }
              })];
          }
        });
      });
    };
    Storage2.prototype.delete = function(key) {
      return __awaiter(this, void 0, void 0, function() {
        var db;
        var _this = this;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              return [4, this.openDbPromise];
            case 1:
              db = _a7.sent();
              return [2, new Promise(function(resolve, reject) {
                var transaction = db.transaction([APP_NAMESPACE_STORE], "readwrite");
                var objectStore = transaction.objectStore(APP_NAMESPACE_STORE);
                var compositeKey = _this.createCompositeKey(key);
                try {
                  var request = objectStore.delete(compositeKey);
                  request.onerror = function(event) {
                    reject(toFirebaseError(
                      event,
                      "storage-delete"
                      /* STORAGE_DELETE */
                    ));
                  };
                  request.onsuccess = function() {
                    resolve();
                  };
                } catch (e) {
                  reject(ERROR_FACTORY5.create("storage-delete", {
                    originalErrorMessage: e && e.message
                  }));
                }
              })];
          }
        });
      });
    };
    Storage2.prototype.createCompositeKey = function(key) {
      return [this.appId, this.appName, this.namespace, key].join();
    };
    return Storage2;
  }()
);
var StorageCache = (
  /** @class */
  function() {
    function StorageCache2(storage) {
      this.storage = storage;
    }
    StorageCache2.prototype.getLastFetchStatus = function() {
      return this.lastFetchStatus;
    };
    StorageCache2.prototype.getLastSuccessfulFetchTimestampMillis = function() {
      return this.lastSuccessfulFetchTimestampMillis;
    };
    StorageCache2.prototype.getActiveConfig = function() {
      return this.activeConfig;
    };
    StorageCache2.prototype.loadFromStorage = function() {
      return __awaiter(this, void 0, void 0, function() {
        var lastFetchStatusPromise, lastSuccessfulFetchTimestampMillisPromise, activeConfigPromise, lastFetchStatus, lastSuccessfulFetchTimestampMillis, activeConfig;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              lastFetchStatusPromise = this.storage.getLastFetchStatus();
              lastSuccessfulFetchTimestampMillisPromise = this.storage.getLastSuccessfulFetchTimestampMillis();
              activeConfigPromise = this.storage.getActiveConfig();
              return [4, lastFetchStatusPromise];
            case 1:
              lastFetchStatus = _a7.sent();
              if (lastFetchStatus) {
                this.lastFetchStatus = lastFetchStatus;
              }
              return [4, lastSuccessfulFetchTimestampMillisPromise];
            case 2:
              lastSuccessfulFetchTimestampMillis = _a7.sent();
              if (lastSuccessfulFetchTimestampMillis) {
                this.lastSuccessfulFetchTimestampMillis = lastSuccessfulFetchTimestampMillis;
              }
              return [4, activeConfigPromise];
            case 3:
              activeConfig = _a7.sent();
              if (activeConfig) {
                this.activeConfig = activeConfig;
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    StorageCache2.prototype.setLastFetchStatus = function(status) {
      this.lastFetchStatus = status;
      return this.storage.setLastFetchStatus(status);
    };
    StorageCache2.prototype.setLastSuccessfulFetchTimestampMillis = function(timestampMillis) {
      this.lastSuccessfulFetchTimestampMillis = timestampMillis;
      return this.storage.setLastSuccessfulFetchTimestampMillis(timestampMillis);
    };
    StorageCache2.prototype.setActiveConfig = function(activeConfig) {
      this.activeConfig = activeConfig;
      return this.storage.setActiveConfig(activeConfig);
    };
    return StorageCache2;
  }()
);
function setAbortableTimeout2(signal, throttleEndTimeMillis) {
  return new Promise(function(resolve, reject) {
    var backoffMillis = Math.max(throttleEndTimeMillis - Date.now(), 0);
    var timeout = setTimeout(resolve, backoffMillis);
    signal.addEventListener(function() {
      clearTimeout(timeout);
      reject(ERROR_FACTORY5.create("fetch-throttle", {
        throttleEndTimeMillis
      }));
    });
  });
}
function isRetriableError2(e) {
  if (!(e instanceof FirebaseError) || !e.customData) {
    return false;
  }
  var httpStatus = Number(e.customData["httpStatus"]);
  return httpStatus === 429 || httpStatus === 500 || httpStatus === 503 || httpStatus === 504;
}
var RetryingClient = (
  /** @class */
  function() {
    function RetryingClient2(client, storage) {
      this.client = client;
      this.storage = storage;
    }
    RetryingClient2.prototype.fetch = function(request) {
      return __awaiter(this, void 0, void 0, function() {
        var throttleMetadata;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              return [4, this.storage.getThrottleMetadata()];
            case 1:
              throttleMetadata = _a7.sent() || {
                backoffCount: 0,
                throttleEndTimeMillis: Date.now()
              };
              return [2, this.attemptFetch(request, throttleMetadata)];
          }
        });
      });
    };
    RetryingClient2.prototype.attemptFetch = function(request, _a7) {
      var throttleEndTimeMillis = _a7.throttleEndTimeMillis, backoffCount = _a7.backoffCount;
      return __awaiter(this, void 0, void 0, function() {
        var response, e_1, throttleMetadata;
        return __generator(this, function(_b) {
          switch (_b.label) {
            case 0:
              return [4, setAbortableTimeout2(request.signal, throttleEndTimeMillis)];
            case 1:
              _b.sent();
              _b.label = 2;
            case 2:
              _b.trys.push([2, 5, , 7]);
              return [4, this.client.fetch(request)];
            case 3:
              response = _b.sent();
              return [4, this.storage.deleteThrottleMetadata()];
            case 4:
              _b.sent();
              return [2, response];
            case 5:
              e_1 = _b.sent();
              if (!isRetriableError2(e_1)) {
                throw e_1;
              }
              throttleMetadata = {
                throttleEndTimeMillis: Date.now() + calculateBackoffMillis(backoffCount),
                backoffCount: backoffCount + 1
              };
              return [4, this.storage.setThrottleMetadata(throttleMetadata)];
            case 6:
              _b.sent();
              return [2, this.attemptFetch(request, throttleMetadata)];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    return RetryingClient2;
  }()
);
var name7 = "@firebase/remote-config";
var version7 = "0.1.43";
function registerRemoteConfig(firebaseInstance) {
  firebaseInstance.INTERNAL.registerComponent(new Component(
    "remoteConfig",
    remoteConfigFactory,
    "PUBLIC"
    /* PUBLIC */
  ).setMultipleInstances(true));
  firebaseInstance.registerVersion(name7, version7);
  function remoteConfigFactory(container, _a7) {
    var namespace = _a7.instanceIdentifier;
    var app = container.getProvider("app").getImmediate();
    var installations = container.getProvider("installations").getImmediate();
    if (typeof window === "undefined") {
      throw ERROR_FACTORY5.create(
        "registration-window"
        /* REGISTRATION_WINDOW */
      );
    }
    var _b = app.options, projectId = _b.projectId, apiKey = _b.apiKey, appId = _b.appId;
    if (!projectId) {
      throw ERROR_FACTORY5.create(
        "registration-project-id"
        /* REGISTRATION_PROJECT_ID */
      );
    }
    if (!apiKey) {
      throw ERROR_FACTORY5.create(
        "registration-api-key"
        /* REGISTRATION_API_KEY */
      );
    }
    if (!appId) {
      throw ERROR_FACTORY5.create(
        "registration-app-id"
        /* REGISTRATION_APP_ID */
      );
    }
    namespace = namespace || "firebase";
    var storage = new Storage(appId, app.name, namespace);
    var storageCache = new StorageCache(storage);
    var logger5 = new Logger(name7);
    logger5.logLevel = LogLevel.ERROR;
    var restClient = new RestClient(
      installations,
      // Uses the JS SDK version, by which the RC package version can be deduced, if necessary.
      firebaseInstance.SDK_VERSION,
      namespace,
      projectId,
      apiKey,
      appId
    );
    var retryingClient = new RetryingClient(restClient, storage);
    var cachingClient = new CachingClient(retryingClient, storage, storageCache, logger5);
    var remoteConfigInstance = new RemoteConfig(app, cachingClient, storageCache, storage, logger5);
    remoteConfigInstance.ensureInitialized();
    return remoteConfigInstance;
  }
}
registerRemoteConfig(index_esm_default);

// node_modules/@firebase/app-check/dist/index.esm.js
var _a6;
var ERRORS2 = (_a6 = {}, _a6[
  "already-activated"
  /* ALREADY_ACTIVATED */
] = "You are trying to activate AppCheck for FirebaseApp {$appName}, while it is already activated. AppCheck can only be activated once.", _a6[
  "use-before-activation"
  /* USE_BEFORE_ACTIVATION */
] = "AppCheck is being used before activate() is called for FirebaseApp {$appName}. Please make sure you call activate() before instantiating other Firebase services.", _a6[
  "fetch-network-error"
  /* FETCH_NETWORK_ERROR */
] = "Fetch failed to connect to a network. Check Internet connection. Original error: {$originalErrorMessage}.", _a6[
  "fetch-parse-error"
  /* FETCH_PARSE_ERROR */
] = "Fetch client could not parse response. Original error: {$originalErrorMessage}.", _a6[
  "fetch-status-error"
  /* FETCH_STATUS_ERROR */
] = "Fetch server returned an HTTP error status. HTTP status: {$httpStatus}.", _a6[
  "storage-open"
  /* STORAGE_OPEN */
] = "Error thrown when opening storage. Original error: {$originalErrorMessage}.", _a6[
  "storage-get"
  /* STORAGE_GET */
] = "Error thrown when reading from storage. Original error: {$originalErrorMessage}.", _a6[
  "storage-set"
  /* STORAGE_WRITE */
] = "Error thrown when writing to storage. Original error: {$originalErrorMessage}.", _a6[
  "recaptcha-error"
  /* RECAPTCHA_ERROR */
] = "ReCAPTCHA error.", _a6);
var ERROR_FACTORY6 = new ErrorFactory("appCheck", "AppCheck", ERRORS2);
var APP_CHECK_STATES = /* @__PURE__ */ new Map();
var DEFAULT_STATE = {
  activated: false,
  tokenObservers: []
};
var DEBUG_STATE = {
  enabled: false
};
function getState(app) {
  return APP_CHECK_STATES.get(app) || DEFAULT_STATE;
}
function setState(app, state) {
  APP_CHECK_STATES.set(app, state);
}
function getDebugState() {
  return DEBUG_STATE;
}
var BASE_ENDPOINT = "https://content-firebaseappcheck.googleapis.com/v1beta";
var EXCHANGE_RECAPTCHA_TOKEN_METHOD = "exchangeRecaptchaToken";
var EXCHANGE_DEBUG_TOKEN_METHOD = "exchangeDebugToken";
var TOKEN_REFRESH_TIME = {
  /**
   * The offset time before token natural expiration to run the refresh.
   * This is currently 5 minutes.
   */
  OFFSET_DURATION: 5 * 60 * 1e3,
  /**
   * This is the first retrial wait after an error. This is currently
   * 30 seconds.
   */
  RETRIAL_MIN_WAIT: 30 * 1e3,
  /**
   * This is the maximum retrial wait, currently 16 minutes.
   */
  RETRIAL_MAX_WAIT: 16 * 60 * 1e3
};
var Refresher = (
  /** @class */
  function() {
    function Refresher2(operation, retryPolicy, getWaitDuration, lowerBound, upperBound) {
      this.operation = operation;
      this.retryPolicy = retryPolicy;
      this.getWaitDuration = getWaitDuration;
      this.lowerBound = lowerBound;
      this.upperBound = upperBound;
      this.pending = null;
      this.nextErrorWaitInterval = lowerBound;
      if (lowerBound > upperBound) {
        throw new Error("Proactive refresh lower bound greater than upper bound!");
      }
    }
    Refresher2.prototype.start = function() {
      this.nextErrorWaitInterval = this.lowerBound;
      this.process(true).catch(function() {
      });
    };
    Refresher2.prototype.stop = function() {
      if (this.pending) {
        this.pending.reject("cancelled");
        this.pending = null;
      }
    };
    Refresher2.prototype.isRunning = function() {
      return !!this.pending;
    };
    Refresher2.prototype.process = function(hasSucceeded) {
      return __awaiter(this, void 0, void 0, function() {
        var error_1;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              this.stop();
              _a7.label = 1;
            case 1:
              _a7.trys.push([1, 6, , 7]);
              this.pending = new Deferred();
              return [4, sleep3(this.getNextRun(hasSucceeded))];
            case 2:
              _a7.sent();
              this.pending.resolve();
              return [4, this.pending.promise];
            case 3:
              _a7.sent();
              this.pending = new Deferred();
              return [4, this.operation()];
            case 4:
              _a7.sent();
              this.pending.resolve();
              return [4, this.pending.promise];
            case 5:
              _a7.sent();
              this.process(true).catch(function() {
              });
              return [3, 7];
            case 6:
              error_1 = _a7.sent();
              if (this.retryPolicy(error_1)) {
                this.process(false).catch(function() {
                });
              } else {
                this.stop();
              }
              return [3, 7];
            case 7:
              return [
                2
                /*return*/
              ];
          }
        });
      });
    };
    Refresher2.prototype.getNextRun = function(hasSucceeded) {
      if (hasSucceeded) {
        this.nextErrorWaitInterval = this.lowerBound;
        return this.getWaitDuration();
      } else {
        var currentErrorWaitInterval = this.nextErrorWaitInterval;
        this.nextErrorWaitInterval *= 2;
        if (this.nextErrorWaitInterval > this.upperBound) {
          this.nextErrorWaitInterval = this.upperBound;
        }
        return currentErrorWaitInterval;
      }
    };
    return Refresher2;
  }()
);
function sleep3(ms) {
  return new Promise(function(resolve) {
    setTimeout(resolve, ms);
  });
}
function getRecaptcha() {
  return self.grecaptcha;
}
function ensureActivated(app) {
  if (!getState(app).activated) {
    throw ERROR_FACTORY6.create("use-before-activation", {
      appName: app.name
    });
  }
}
function uuidv4() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, function(c) {
    var r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
function formatDummyToken(tokenErrorData) {
  return base64.encodeString(
    JSON.stringify(tokenErrorData),
    /* webSafe= */
    false
  );
}
function exchangeToken(_a7, platformLoggerProvider) {
  var url = _a7.url, body = _a7.body;
  return __awaiter(this, void 0, void 0, function() {
    var headers, platformLogger, options, response, originalError_1, responseBody, originalError_2, match, timeToLiveAsNumber, now;
    return __generator(this, function(_b) {
      switch (_b.label) {
        case 0:
          headers = {
            "Content-Type": "application/json"
          };
          platformLogger = platformLoggerProvider.getImmediate({
            optional: true
          });
          if (platformLogger) {
            headers["X-Firebase-Client"] = platformLogger.getPlatformInfoString();
          }
          options = {
            method: "POST",
            body: JSON.stringify(body),
            headers
          };
          _b.label = 1;
        case 1:
          _b.trys.push([1, 3, , 4]);
          return [4, fetch(url, options)];
        case 2:
          response = _b.sent();
          return [3, 4];
        case 3:
          originalError_1 = _b.sent();
          throw ERROR_FACTORY6.create("fetch-network-error", {
            originalErrorMessage: originalError_1.message
          });
        case 4:
          if (response.status !== 200) {
            throw ERROR_FACTORY6.create("fetch-status-error", {
              httpStatus: response.status
            });
          }
          _b.label = 5;
        case 5:
          _b.trys.push([5, 7, , 8]);
          return [4, response.json()];
        case 6:
          responseBody = _b.sent();
          return [3, 8];
        case 7:
          originalError_2 = _b.sent();
          throw ERROR_FACTORY6.create("fetch-parse-error", {
            originalErrorMessage: originalError_2.message
          });
        case 8:
          match = responseBody.ttl.match(/^([\d.]+)(s)$/);
          if (!match || !match[2] || isNaN(Number(match[1]))) {
            throw ERROR_FACTORY6.create("fetch-parse-error", {
              originalErrorMessage: "ttl field (timeToLive) is not in standard Protobuf Duration " + ("format: " + responseBody.ttl)
            });
          }
          timeToLiveAsNumber = Number(match[1]) * 1e3;
          now = Date.now();
          return [2, {
            token: responseBody.attestationToken,
            expireTimeMillis: now + timeToLiveAsNumber,
            issuedAtTimeMillis: now
          }];
      }
    });
  });
}
function getExchangeRecaptchaTokenRequest(app, reCAPTCHAToken) {
  var _a7 = app.options, projectId = _a7.projectId, appId = _a7.appId, apiKey = _a7.apiKey;
  return {
    url: BASE_ENDPOINT + "/projects/" + projectId + "/apps/" + appId + ":" + EXCHANGE_RECAPTCHA_TOKEN_METHOD + "?key=" + apiKey,
    body: {
      // eslint-disable-next-line
      recaptcha_token: reCAPTCHAToken
    }
  };
}
function getExchangeDebugTokenRequest(app, debugToken) {
  var _a7 = app.options, projectId = _a7.projectId, appId = _a7.appId, apiKey = _a7.apiKey;
  return {
    url: BASE_ENDPOINT + "/projects/" + projectId + "/apps/" + appId + ":" + EXCHANGE_DEBUG_TOKEN_METHOD + "?key=" + apiKey,
    body: {
      // eslint-disable-next-line
      debug_token: debugToken
    }
  };
}
var DB_NAME2 = "firebase-app-check-database";
var DB_VERSION2 = 1;
var STORE_NAME = "firebase-app-check-store";
var DEBUG_TOKEN_KEY = "debug-token";
var dbPromise3 = null;
function getDBPromise() {
  if (dbPromise3) {
    return dbPromise3;
  }
  dbPromise3 = new Promise(function(resolve, reject) {
    try {
      var request = indexedDB.open(DB_NAME2, DB_VERSION2);
      request.onsuccess = function(event) {
        resolve(event.target.result);
      };
      request.onerror = function(event) {
        var _a7;
        reject(ERROR_FACTORY6.create("storage-open", {
          originalErrorMessage: (_a7 = event.target.error) === null || _a7 === void 0 ? void 0 : _a7.message
        }));
      };
      request.onupgradeneeded = function(event) {
        var db = event.target.result;
        switch (event.oldVersion) {
          case 0:
            db.createObjectStore(STORE_NAME, {
              keyPath: "compositeKey"
            });
        }
      };
    } catch (e) {
      reject(ERROR_FACTORY6.create("storage-open", {
        originalErrorMessage: e.message
      }));
    }
  });
  return dbPromise3;
}
function readTokenFromIndexedDB(app) {
  return read(computeKey(app));
}
function writeTokenToIndexedDB(app, token) {
  return write(computeKey(app), token);
}
function writeDebugTokenToIndexedDB(token) {
  return write(DEBUG_TOKEN_KEY, token);
}
function readDebugTokenFromIndexedDB() {
  return read(DEBUG_TOKEN_KEY);
}
function write(key, value) {
  return __awaiter(this, void 0, void 0, function() {
    var db, transaction, store, request;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getDBPromise()];
        case 1:
          db = _a7.sent();
          transaction = db.transaction(STORE_NAME, "readwrite");
          store = transaction.objectStore(STORE_NAME);
          request = store.put({
            compositeKey: key,
            value
          });
          return [2, new Promise(function(resolve, reject) {
            request.onsuccess = function(_event) {
              resolve();
            };
            transaction.onerror = function(event) {
              var _a8;
              reject(ERROR_FACTORY6.create("storage-set", {
                originalErrorMessage: (_a8 = event.target.error) === null || _a8 === void 0 ? void 0 : _a8.message
              }));
            };
          })];
      }
    });
  });
}
function read(key) {
  return __awaiter(this, void 0, void 0, function() {
    var db, transaction, store, request;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getDBPromise()];
        case 1:
          db = _a7.sent();
          transaction = db.transaction(STORE_NAME, "readonly");
          store = transaction.objectStore(STORE_NAME);
          request = store.get(key);
          return [2, new Promise(function(resolve, reject) {
            request.onsuccess = function(event) {
              var result = event.target.result;
              if (result) {
                resolve(result.value);
              } else {
                resolve(void 0);
              }
            };
            transaction.onerror = function(event) {
              var _a8;
              reject(ERROR_FACTORY6.create("storage-get", {
                originalErrorMessage: (_a8 = event.target.error) === null || _a8 === void 0 ? void 0 : _a8.message
              }));
            };
          })];
      }
    });
  });
}
function computeKey(app) {
  return app.options.appId + "-" + app.name;
}
var logger4 = new Logger("@firebase/app-check");
function readTokenFromStorage(app) {
  return __awaiter(this, void 0, void 0, function() {
    var token, e_1;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          if (!isIndexedDBAvailable()) return [3, 5];
          token = void 0;
          _a7.label = 1;
        case 1:
          _a7.trys.push([1, 3, , 4]);
          return [4, readTokenFromIndexedDB(app)];
        case 2:
          token = _a7.sent();
          return [3, 4];
        case 3:
          e_1 = _a7.sent();
          logger4.warn("Failed to read token from indexeddb. Error: " + e_1);
          return [3, 4];
        case 4:
          return [2, token];
        case 5:
          return [2, void 0];
      }
    });
  });
}
function writeTokenToStorage(app, token) {
  if (isIndexedDBAvailable()) {
    return writeTokenToIndexedDB(app, token).catch(function(e) {
      logger4.warn("Failed to write token to indexeddb. Error: " + e);
    });
  }
  return Promise.resolve();
}
function readOrCreateDebugTokenFromStorage() {
  return __awaiter(this, void 0, void 0, function() {
    var existingDebugToken, newToken;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          existingDebugToken = void 0;
          _a7.label = 1;
        case 1:
          _a7.trys.push([1, 3, , 4]);
          return [4, readDebugTokenFromIndexedDB()];
        case 2:
          existingDebugToken = _a7.sent();
          return [3, 4];
        case 3:
          _a7.sent();
          return [3, 4];
        case 4:
          if (!existingDebugToken) {
            newToken = uuidv4();
            writeDebugTokenToIndexedDB(newToken).catch(function(e) {
              return logger4.warn("Failed to persist debug token to indexeddb. Error: " + e);
            });
            console.log("AppCheck debug token: " + newToken + ". You will need to whitelist it in the Firebase console for it to work");
            return [2, newToken];
          } else {
            return [2, existingDebugToken];
          }
      }
    });
  });
}
function isDebugMode() {
  var debugState = getDebugState();
  return debugState.enabled;
}
function getDebugToken() {
  return __awaiter(this, void 0, void 0, function() {
    var state;
    return __generator(this, function(_a7) {
      state = getDebugState();
      if (state.enabled && state.token) {
        return [2, state.token.promise];
      } else {
        throw Error("\n            Can't get debug token in production mode.\n        ");
      }
    });
  });
}
function initializeDebugMode() {
  var globals = getGlobal();
  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== "string" && globals.FIREBASE_APPCHECK_DEBUG_TOKEN !== true) {
    return;
  }
  var debugState = getDebugState();
  debugState.enabled = true;
  var deferredToken = new Deferred();
  debugState.token = deferredToken;
  if (typeof globals.FIREBASE_APPCHECK_DEBUG_TOKEN === "string") {
    deferredToken.resolve(globals.FIREBASE_APPCHECK_DEBUG_TOKEN);
  } else {
    deferredToken.resolve(readOrCreateDebugTokenFromStorage());
  }
}
var defaultTokenErrorData = { error: "UNKNOWN_ERROR" };
function getToken$2(app, platformLoggerProvider, forceRefresh) {
  if (forceRefresh === void 0) {
    forceRefresh = false;
  }
  return __awaiter(this, void 0, void 0, function() {
    var state, token, error2, cachedToken, tokenFromDebugExchange, _a7, _b, _c, e_1, interopTokenResult;
    return __generator(this, function(_d) {
      switch (_d.label) {
        case 0:
          ensureActivated(app);
          state = getState(app);
          token = state.token;
          error2 = void 0;
          if (!!token) return [3, 2];
          return [4, state.cachedTokenPromise];
        case 1:
          cachedToken = _d.sent();
          if (cachedToken && isValid(cachedToken)) {
            token = cachedToken;
            setState(app, __assign(__assign({}, state), { token }));
            notifyTokenListeners(app, { token: token.token });
          }
          _d.label = 2;
        case 2:
          if (!forceRefresh && token && isValid(token)) {
            return [2, {
              token: token.token
            }];
          }
          if (!isDebugMode()) return [3, 6];
          _a7 = exchangeToken;
          _b = getExchangeDebugTokenRequest;
          _c = [app];
          return [4, getDebugToken()];
        case 3:
          return [4, _a7.apply(void 0, [_b.apply(void 0, _c.concat([_d.sent()])), platformLoggerProvider])];
        case 4:
          tokenFromDebugExchange = _d.sent();
          return [4, writeTokenToStorage(app, tokenFromDebugExchange)];
        case 5:
          _d.sent();
          setState(app, __assign(__assign({}, state), { token: tokenFromDebugExchange }));
          return [2, { token: tokenFromDebugExchange.token }];
        case 6:
          _d.trys.push([6, 8, , 9]);
          return [4, state.provider.getToken()];
        case 7:
          token = _d.sent();
          return [3, 9];
        case 8:
          e_1 = _d.sent();
          logger4.error(e_1);
          error2 = e_1;
          return [3, 9];
        case 9:
          if (!!token) return [3, 10];
          interopTokenResult = makeDummyTokenResult(error2);
          return [3, 12];
        case 10:
          interopTokenResult = {
            token: token.token
          };
          setState(app, __assign(__assign({}, state), { token }));
          return [4, writeTokenToStorage(app, token)];
        case 11:
          _d.sent();
          _d.label = 12;
        case 12:
          notifyTokenListeners(app, interopTokenResult);
          return [2, interopTokenResult];
      }
    });
  });
}
function addTokenListener(app, platformLoggerProvider, type, listener, onError) {
  var state = getState(app);
  var tokenListener = {
    next: listener,
    error: onError,
    type
  };
  var newState = __assign(__assign({}, state), { tokenObservers: __spreadArray(__spreadArray([], state.tokenObservers), [tokenListener]) });
  if (!newState.tokenRefresher) {
    var tokenRefresher = createTokenRefresher(app, platformLoggerProvider);
    newState.tokenRefresher = tokenRefresher;
  }
  if (!newState.tokenRefresher.isRunning() && state.isTokenAutoRefreshEnabled) {
    newState.tokenRefresher.start();
  }
  if (state.token && isValid(state.token)) {
    var validToken_1 = state.token;
    Promise.resolve().then(function() {
      return listener({ token: validToken_1.token });
    }).catch(function() {
    });
  } else if (state.token == null) {
    void state.cachedTokenPromise.then(function(cachedToken) {
      if (cachedToken && isValid(cachedToken)) {
        listener({ token: cachedToken.token });
      }
    }).catch(function() {
    });
  }
  setState(app, newState);
}
function removeTokenListener(app, listener) {
  var state = getState(app);
  var newObservers = state.tokenObservers.filter(function(tokenObserver) {
    return tokenObserver.next !== listener;
  });
  if (newObservers.length === 0 && state.tokenRefresher && state.tokenRefresher.isRunning()) {
    state.tokenRefresher.stop();
  }
  setState(app, __assign(__assign({}, state), { tokenObservers: newObservers }));
}
function createTokenRefresher(app, platformLoggerProvider) {
  var _this = this;
  return new Refresher(
    // Keep in mind when this fails for any reason other than the ones
    // for which we should retry, it will effectively stop the proactive refresh.
    function() {
      return __awaiter(_this, void 0, void 0, function() {
        var state, result;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              state = getState(app);
              if (!!state.token) return [3, 2];
              return [4, getToken$2(app, platformLoggerProvider)];
            case 1:
              result = _a7.sent();
              return [3, 4];
            case 2:
              return [4, getToken$2(app, platformLoggerProvider, true)];
            case 3:
              result = _a7.sent();
              _a7.label = 4;
            case 4:
              if (result.error) {
                throw result.error;
              }
              return [
                2
                /*return*/
              ];
          }
        });
      });
    },
    function() {
      return true;
    },
    function() {
      var state = getState(app);
      if (state.token) {
        var nextRefreshTimeMillis = state.token.issuedAtTimeMillis + (state.token.expireTimeMillis - state.token.issuedAtTimeMillis) * 0.5 + 5 * 60 * 1e3;
        var latestAllowableRefresh = state.token.expireTimeMillis - 5 * 60 * 1e3;
        nextRefreshTimeMillis = Math.min(nextRefreshTimeMillis, latestAllowableRefresh);
        return Math.max(0, nextRefreshTimeMillis - Date.now());
      } else {
        return 0;
      }
    },
    TOKEN_REFRESH_TIME.RETRIAL_MIN_WAIT,
    TOKEN_REFRESH_TIME.RETRIAL_MAX_WAIT
  );
}
function notifyTokenListeners(app, token) {
  var observers = getState(app).tokenObservers;
  for (var _i = 0, observers_1 = observers; _i < observers_1.length; _i++) {
    var observer = observers_1[_i];
    try {
      if (observer.type === "EXTERNAL" && token.error != null) {
        observer.error(token.error);
      } else {
        observer.next(token);
      }
    } catch (ignored) {
    }
  }
}
function isValid(token) {
  return token.expireTimeMillis - Date.now() > 0;
}
function makeDummyTokenResult(error2) {
  return {
    token: formatDummyToken(defaultTokenErrorData),
    error: error2
  };
}
var RECAPTCHA_URL = "https://www.google.com/recaptcha/api.js";
function initialize(app, siteKey) {
  var state = getState(app);
  var initialized = new Deferred();
  setState(app, __assign(__assign({}, state), { reCAPTCHAState: { initialized } }));
  var divId = "fire_app_check_" + app.name;
  var invisibleDiv = document.createElement("div");
  invisibleDiv.id = divId;
  invisibleDiv.style.display = "none";
  document.body.appendChild(invisibleDiv);
  var grecaptcha = getRecaptcha();
  if (!grecaptcha) {
    loadReCAPTCHAScript(function() {
      var grecaptcha2 = getRecaptcha();
      if (!grecaptcha2) {
        throw new Error("no recaptcha");
      }
      grecaptcha2.ready(function() {
        renderInvisibleWidget(app, siteKey, grecaptcha2, divId);
        initialized.resolve(grecaptcha2);
      });
    });
  } else {
    grecaptcha.ready(function() {
      renderInvisibleWidget(app, siteKey, grecaptcha, divId);
      initialized.resolve(grecaptcha);
    });
  }
  return initialized.promise;
}
function getToken$1(app) {
  return __awaiter(this, void 0, void 0, function() {
    var reCAPTCHAState, recaptcha;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          ensureActivated(app);
          reCAPTCHAState = getState(app).reCAPTCHAState;
          return [4, reCAPTCHAState.initialized.promise];
        case 1:
          recaptcha = _a7.sent();
          return [2, new Promise(function(resolve, _reject) {
            var reCAPTCHAState2 = getState(app).reCAPTCHAState;
            recaptcha.ready(function() {
              resolve(
                // widgetId is guaranteed to be available if reCAPTCHAState.initialized.promise resolved.
                recaptcha.execute(reCAPTCHAState2.widgetId, {
                  action: "fire_app_check"
                })
              );
            });
          })];
      }
    });
  });
}
function renderInvisibleWidget(app, siteKey, grecaptcha, container) {
  var widgetId = grecaptcha.render(container, {
    sitekey: siteKey,
    size: "invisible"
  });
  var state = getState(app);
  setState(app, __assign(__assign({}, state), { reCAPTCHAState: __assign(__assign({}, state.reCAPTCHAState), {
    // state.reCAPTCHAState is set in the initialize()
    widgetId
  }) }));
}
function loadReCAPTCHAScript(onload) {
  var script = document.createElement("script");
  script.src = "" + RECAPTCHA_URL;
  script.onload = onload;
  document.head.appendChild(script);
}
var ReCaptchaV3Provider = (
  /** @class */
  function() {
    function ReCaptchaV3Provider2(_siteKey) {
      this._siteKey = _siteKey;
    }
    ReCaptchaV3Provider2.prototype.getToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var attestedClaimsToken;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!this._app || !this._platformLoggerProvider) {
                throw ERROR_FACTORY6.create("use-before-activation", {
                  appName: ""
                });
              }
              _a7.label = 1;
            case 1:
              _a7.trys.push([1, 3, , 4]);
              return [4, getToken$1(this._app)];
            case 2:
              attestedClaimsToken = _a7.sent();
              return [3, 4];
            case 3:
              _a7.sent();
              throw ERROR_FACTORY6.create(
                "recaptcha-error"
                /* RECAPTCHA_ERROR */
              );
            case 4:
              return [2, exchangeToken(getExchangeRecaptchaTokenRequest(this._app, attestedClaimsToken), this._platformLoggerProvider)];
          }
        });
      });
    };
    ReCaptchaV3Provider2.prototype.initialize = function(app, platformLoggerProvider) {
      this._app = app;
      this._platformLoggerProvider = platformLoggerProvider;
      initialize(app, this._siteKey).catch(function() {
      });
    };
    return ReCaptchaV3Provider2;
  }()
);
var CustomProvider = (
  /** @class */
  function() {
    function CustomProvider2(_customProviderOptions) {
      this._customProviderOptions = _customProviderOptions;
    }
    CustomProvider2.prototype.getToken = function() {
      return __awaiter(this, void 0, void 0, function() {
        var customToken, issuedAtTimeSeconds, issuedAtTimeMillis;
        return __generator(this, function(_a7) {
          switch (_a7.label) {
            case 0:
              if (!this._app) {
                throw ERROR_FACTORY6.create("use-before-activation", {
                  appName: ""
                });
              }
              return [4, this._customProviderOptions.getToken()];
            case 1:
              customToken = _a7.sent();
              issuedAtTimeSeconds = issuedAtTime(customToken.token);
              issuedAtTimeMillis = issuedAtTimeSeconds !== null && issuedAtTimeSeconds < Date.now() && issuedAtTimeSeconds > 0 ? issuedAtTimeSeconds * 1e3 : Date.now();
              return [2, __assign(__assign({}, customToken), { issuedAtTimeMillis })];
          }
        });
      });
    };
    CustomProvider2.prototype.initialize = function(app) {
      this._app = app;
    };
    return CustomProvider2;
  }()
);
function activate(app, siteKeyOrProvider, platformLoggerProvider, isTokenAutoRefreshEnabled) {
  var state = getState(app);
  if (state.activated) {
    throw ERROR_FACTORY6.create("already-activated", {
      appName: app.name
    });
  }
  var newState = __assign(__assign({}, state), { activated: true });
  newState.cachedTokenPromise = readTokenFromStorage(app).then(function(cachedToken) {
    if (cachedToken && isValid(cachedToken)) {
      setState(app, __assign(__assign({}, getState(app)), { token: cachedToken }));
    }
    return cachedToken;
  });
  if (typeof siteKeyOrProvider === "string") {
    newState.provider = new ReCaptchaV3Provider(siteKeyOrProvider);
  } else if (siteKeyOrProvider instanceof ReCaptchaV3Provider || siteKeyOrProvider instanceof CustomProvider) {
    newState.provider = siteKeyOrProvider;
  } else {
    newState.provider = new CustomProvider({
      getToken: siteKeyOrProvider.getToken
    });
  }
  newState.isTokenAutoRefreshEnabled = isTokenAutoRefreshEnabled === void 0 ? app.automaticDataCollectionEnabled : isTokenAutoRefreshEnabled;
  setState(app, newState);
  newState.provider.initialize(app, platformLoggerProvider);
}
function setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled) {
  var state = getState(app);
  if (state.tokenRefresher) {
    if (isTokenAutoRefreshEnabled === true) {
      state.tokenRefresher.start();
    } else {
      state.tokenRefresher.stop();
    }
  }
  setState(app, __assign(__assign({}, state), { isTokenAutoRefreshEnabled }));
}
function getToken3(app, platformLoggerProvider, forceRefresh) {
  return __awaiter(this, void 0, void 0, function() {
    var result;
    return __generator(this, function(_a7) {
      switch (_a7.label) {
        case 0:
          return [4, getToken$2(app, platformLoggerProvider, forceRefresh)];
        case 1:
          result = _a7.sent();
          if (result.error) {
            throw result.error;
          }
          return [2, { token: result.token }];
      }
    });
  });
}
function onTokenChanged(app, platformLoggerProvider, onNextOrObserver, onError, onCompletion) {
  var nextFn = function() {
  };
  var errorFn = function() {
  };
  if (onNextOrObserver.next != null) {
    nextFn = onNextOrObserver.next.bind(onNextOrObserver);
  } else {
    nextFn = onNextOrObserver;
  }
  if (onNextOrObserver.error != null) {
    errorFn = onNextOrObserver.error.bind(onNextOrObserver);
  } else if (onError) {
    errorFn = onError;
  }
  addTokenListener(app, platformLoggerProvider, "EXTERNAL", nextFn, errorFn);
  return function() {
    return removeTokenListener(app, nextFn);
  };
}
function factory3(app, platformLoggerProvider) {
  return {
    app,
    activate: function(siteKeyOrProvider, isTokenAutoRefreshEnabled) {
      return activate(
        app,
        // Public types of ReCaptchaV3Provider/CustomProvider don't
        // expose getToken() and aren't recognized as the internal
        // class version of themselves.
        siteKeyOrProvider,
        platformLoggerProvider,
        isTokenAutoRefreshEnabled
      );
    },
    setTokenAutoRefreshEnabled: function(isTokenAutoRefreshEnabled) {
      return setTokenAutoRefreshEnabled(app, isTokenAutoRefreshEnabled);
    },
    getToken: function(forceRefresh) {
      return getToken3(app, platformLoggerProvider, forceRefresh);
    },
    onTokenChanged: function(onNextOrObserver, onError, onCompletion) {
      return onTokenChanged(
        app,
        platformLoggerProvider,
        /**
         * This can still be an observer. Need to do this casting because
         * according to Typescript: "Implementation signatures of overloads
         * are not externally visible"
         */
        onNextOrObserver,
        onError
      );
    },
    INTERNAL: {
      delete: function() {
        var tokenObservers = getState(app).tokenObservers;
        for (var _i = 0, tokenObservers_1 = tokenObservers; _i < tokenObservers_1.length; _i++) {
          var tokenObserver = tokenObservers_1[_i];
          removeTokenListener(app, tokenObserver.next);
        }
        return Promise.resolve();
      }
    }
  };
}
function internalFactory(app, platformLoggerProvider) {
  return {
    getToken: function(forceRefresh) {
      return getToken$2(app, platformLoggerProvider, forceRefresh);
    },
    addTokenListener: function(listener) {
      return addTokenListener(app, platformLoggerProvider, "INTERNAL", listener);
    },
    removeTokenListener: function(listener) {
      return removeTokenListener(app, listener);
    }
  };
}
var name8 = "@firebase/app-check";
var version8 = "0.3.2";
var APP_CHECK_NAME = "appCheck";
var APP_CHECK_NAME_INTERNAL = "app-check-internal";
function registerAppCheck(firebase) {
  firebase.INTERNAL.registerComponent(new Component(
    APP_CHECK_NAME,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var platformLoggerProvider = container.getProvider("platform-logger");
      return factory3(app, platformLoggerProvider);
    },
    "PUBLIC"
    /* PUBLIC */
  ).setServiceProps({
    ReCaptchaV3Provider,
    CustomProvider
  }).setInstantiationMode(
    "EXPLICIT"
    /* EXPLICIT */
  ).setInstanceCreatedCallback(function(container, _instanceIdentifier, _instance) {
    var appCheckInternalProvider = container.getProvider(APP_CHECK_NAME_INTERNAL);
    appCheckInternalProvider.initialize();
  }));
  firebase.INTERNAL.registerComponent(new Component(
    APP_CHECK_NAME_INTERNAL,
    function(container) {
      var app = container.getProvider("app").getImmediate();
      var platformLoggerProvider = container.getProvider("platform-logger");
      return internalFactory(app, platformLoggerProvider);
    },
    "PUBLIC"
    /* PUBLIC */
  ).setInstantiationMode(
    "EXPLICIT"
    /* EXPLICIT */
  ));
  firebase.registerVersion(name8, version8);
}
registerAppCheck(index_esm_default);
initializeDebugMode();

// node_modules/firebase/dist/index.esm.js
var name$1 = "firebase";
var version$1 = "8.10.1";
index_esm_default.registerVersion(name$1, version$1, "app");
index_esm_default.SDK_VERSION = version$1;
var name9 = "firebase";
var version9 = "8.10.1";
console.warn("\nIt looks like you're using the development build of the Firebase JS SDK.\nWhen deploying Firebase apps to production, it is advisable to only import\nthe individual SDK components you intend to use.\n\nFor the module builds, these are available in the following manner\n(replace <PACKAGE> with the name of a component - i.e. auth, database, etc):\n\nCommonJS Modules:\nconst firebase = require('firebase/app');\nrequire('firebase/<PACKAGE>');\n\nES Modules:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n\nTypescript:\nimport firebase from 'firebase/app';\nimport 'firebase/<PACKAGE>';\n");
index_esm_default.registerVersion(name9, version9);
export {
  index_esm_default as default
};
/*! Bundled license information:

@firebase/database/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/firestore/dist/esm5/bundle.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/functions/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/installations/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/messaging/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except
   * in compliance with the License. You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software distributed under the License
   * is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express
   * or implied. See the License for the specific language governing permissions and limitations under
   * the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/storage/dist/index.browser.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *  http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/performance/dist/index.esm.js:
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/analytics/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/remote-config/dist/index.esm.js:
  (**
   * @license
   * Copyright 2019 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

@firebase/app-check/dist/index.esm.js:
  (**
   * @license
   * Copyright 2020 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2021 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)

firebase/dist/index.esm.js:
  (**
   * @license
   * Copyright 2018 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
  (**
   * @license
   * Copyright 2017 Google LLC
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *)
*/
//# sourceMappingURL=firebase.js.map
